{"version":3,"sources":["../node_modules/codemirror/addon/mode/multiplex.js","../node_modules/codemirror/mode/twig/twig.js"],"names":["CodeMirror","multiplexingMode","outer","others","Array","prototype","slice","call","arguments","indexOf","string","pattern","from","returnEnd","found","length","m","exec","index","startState","innerActive","inner","copyState","state","mode","token","stream","curInner","oldContent","close","sol","this","pos","parseDelimiters","match","delimStyle","innerToken","innerStyle","cutOff","Infinity","i","other","open","outerIndent","indent","possibleOuterIndent","Pass","outerToken","textAfter","line","blankLine","electricChars","innerMode","mod","__webpack_require__","defineMode","keywords","operator","sign","atom","number","RegExp","join","ch","peek","incomment","skipTo","eatWhile","skipToEnd","intag","instring","next","eat","tokenBase","config","parserConfig","twigInner","getMode","base","defineMIME"],"mappings":"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","file":"static/js/25.4a1bf88b.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.multiplexingMode = function (outer\n  /*, others */\n  ) {\n    // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects\n    var others = Array.prototype.slice.call(arguments, 1);\n\n    function indexOf(string, pattern, from, returnEnd) {\n      if (typeof pattern == \"string\") {\n        var found = string.indexOf(pattern, from);\n        return returnEnd && found > -1 ? found + pattern.length : found;\n      }\n\n      var m = pattern.exec(from ? string.slice(from) : string);\n      return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          outer: CodeMirror.startState(outer),\n          innerActive: null,\n          inner: null\n        };\n      },\n      copyState: function copyState(state) {\n        return {\n          outer: CodeMirror.copyState(outer, state.outer),\n          innerActive: state.innerActive,\n          inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner)\n        };\n      },\n      token: function token(stream, state) {\n        if (!state.innerActive) {\n          var cutOff = Infinity,\n              oldContent = stream.string;\n\n          for (var i = 0; i < others.length; ++i) {\n            var other = others[i];\n            var found = indexOf(oldContent, other.open, stream.pos);\n\n            if (found == stream.pos) {\n              if (!other.parseDelimiters) stream.match(other.open);\n              state.innerActive = other; // Get the outer indent, making sure to handle CodeMirror.Pass\n\n              var outerIndent = 0;\n\n              if (outer.indent) {\n                var possibleOuterIndent = outer.indent(state.outer, \"\", \"\");\n                if (possibleOuterIndent !== CodeMirror.Pass) outerIndent = possibleOuterIndent;\n              }\n\n              state.inner = CodeMirror.startState(other.mode, outerIndent);\n              return other.delimStyle && other.delimStyle + \" \" + other.delimStyle + \"-open\";\n            } else if (found != -1 && found < cutOff) {\n              cutOff = found;\n            }\n          }\n\n          if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);\n          var outerToken = outer.token(stream, state.outer);\n          if (cutOff != Infinity) stream.string = oldContent;\n          return outerToken;\n        } else {\n          var curInner = state.innerActive,\n              oldContent = stream.string;\n\n          if (!curInner.close && stream.sol()) {\n            state.innerActive = state.inner = null;\n            return this.token(stream, state);\n          }\n\n          var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;\n\n          if (found == stream.pos && !curInner.parseDelimiters) {\n            stream.match(curInner.close);\n            state.innerActive = state.inner = null;\n            return curInner.delimStyle && curInner.delimStyle + \" \" + curInner.delimStyle + \"-close\";\n          }\n\n          if (found > -1) stream.string = oldContent.slice(0, found);\n          var innerToken = curInner.mode.token(stream, state.inner);\n          if (found > -1) stream.string = oldContent;\n          if (found == stream.pos && curInner.parseDelimiters) state.innerActive = state.inner = null;\n\n          if (curInner.innerStyle) {\n            if (innerToken) innerToken = innerToken + \" \" + curInner.innerStyle;else innerToken = curInner.innerStyle;\n          }\n\n          return innerToken;\n        }\n      },\n      indent: function indent(state, textAfter, line) {\n        var mode = state.innerActive ? state.innerActive.mode : outer;\n        if (!mode.indent) return CodeMirror.Pass;\n        return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);\n      },\n      blankLine: function blankLine(state) {\n        var mode = state.innerActive ? state.innerActive.mode : outer;\n\n        if (mode.blankLine) {\n          mode.blankLine(state.innerActive ? state.inner : state.outer);\n        }\n\n        if (!state.innerActive) {\n          for (var i = 0; i < others.length; ++i) {\n            var other = others[i];\n\n            if (other.open === \"\\n\") {\n              state.innerActive = other;\n              state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, \"\", \"\") : 0);\n            }\n          }\n        } else if (state.innerActive.close === \"\\n\") {\n          state.innerActive = state.inner = null;\n        }\n      },\n      electricChars: outer.electricChars,\n      innerMode: function innerMode(state) {\n        return state.inner ? {\n          state: state.inner,\n          mode: state.innerActive.mode\n        } : {\n          state: state.outer,\n          mode: outer\n        };\n      }\n    };\n  };\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../../addon/mode/multiplex\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../../addon/mode/multiplex\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"twig:inner\", function () {\n    var keywords = [\"and\", \"as\", \"autoescape\", \"endautoescape\", \"block\", \"do\", \"endblock\", \"else\", \"elseif\", \"extends\", \"for\", \"endfor\", \"embed\", \"endembed\", \"filter\", \"endfilter\", \"flush\", \"from\", \"if\", \"endif\", \"in\", \"is\", \"include\", \"import\", \"not\", \"or\", \"set\", \"spaceless\", \"endspaceless\", \"with\", \"endwith\", \"trans\", \"endtrans\", \"blocktrans\", \"endblocktrans\", \"macro\", \"endmacro\", \"use\", \"verbatim\", \"endverbatim\"],\n        operator = /^[+\\-*&%=<>!?|~^]/,\n        sign = /^[:\\[\\(\\{]/,\n        atom = [\"true\", \"false\", \"null\", \"empty\", \"defined\", \"divisibleby\", \"divisible by\", \"even\", \"odd\", \"iterable\", \"sameas\", \"same as\"],\n        number = /^(\\d[+\\-\\*\\/])?\\d+(\\.\\d+)?/;\n    keywords = new RegExp(\"((\" + keywords.join(\")|(\") + \"))\\\\b\");\n    atom = new RegExp(\"((\" + atom.join(\")|(\") + \"))\\\\b\");\n\n    function tokenBase(stream, state) {\n      var ch = stream.peek(); //Comment\n\n      if (state.incomment) {\n        if (!stream.skipTo(\"#}\")) {\n          stream.skipToEnd();\n        } else {\n          stream.eatWhile(/\\#|}/);\n          state.incomment = false;\n        }\n\n        return \"comment\"; //Tag\n      } else if (state.intag) {\n        //After operator\n        if (state.operator) {\n          state.operator = false;\n\n          if (stream.match(atom)) {\n            return \"atom\";\n          }\n\n          if (stream.match(number)) {\n            return \"number\";\n          }\n        } //After sign\n\n\n        if (state.sign) {\n          state.sign = false;\n\n          if (stream.match(atom)) {\n            return \"atom\";\n          }\n\n          if (stream.match(number)) {\n            return \"number\";\n          }\n        }\n\n        if (state.instring) {\n          if (ch == state.instring) {\n            state.instring = false;\n          }\n\n          stream.next();\n          return \"string\";\n        } else if (ch == \"'\" || ch == '\"') {\n          state.instring = ch;\n          stream.next();\n          return \"string\";\n        } else if (stream.match(state.intag + \"}\") || stream.eat(\"-\") && stream.match(state.intag + \"}\")) {\n          state.intag = false;\n          return \"tag\";\n        } else if (stream.match(operator)) {\n          state.operator = true;\n          return \"operator\";\n        } else if (stream.match(sign)) {\n          state.sign = true;\n        } else {\n          if (stream.eat(\" \") || stream.sol()) {\n            if (stream.match(keywords)) {\n              return \"keyword\";\n            }\n\n            if (stream.match(atom)) {\n              return \"atom\";\n            }\n\n            if (stream.match(number)) {\n              return \"number\";\n            }\n\n            if (stream.sol()) {\n              stream.next();\n            }\n          } else {\n            stream.next();\n          }\n        }\n\n        return \"variable\";\n      } else if (stream.eat(\"{\")) {\n        if (stream.eat(\"#\")) {\n          state.incomment = true;\n\n          if (!stream.skipTo(\"#}\")) {\n            stream.skipToEnd();\n          } else {\n            stream.eatWhile(/\\#|}/);\n            state.incomment = false;\n          }\n\n          return \"comment\"; //Open tag\n        } else if (ch = stream.eat(/\\{|%/)) {\n          //Cache close tag\n          state.intag = ch;\n\n          if (ch == \"{\") {\n            state.intag = \"}\";\n          }\n\n          stream.eat(\"-\");\n          return \"tag\";\n        }\n      }\n\n      stream.next();\n    }\n\n    ;\n    return {\n      startState: function startState() {\n        return {};\n      },\n      token: function token(stream, state) {\n        return tokenBase(stream, state);\n      }\n    };\n  });\n  CodeMirror.defineMode(\"twig\", function (config, parserConfig) {\n    var twigInner = CodeMirror.getMode(config, \"twig:inner\");\n    if (!parserConfig || !parserConfig.base) return twigInner;\n    return CodeMirror.multiplexingMode(CodeMirror.getMode(config, parserConfig.base), {\n      open: /\\{[{#%]/,\n      close: /[}#%]\\}/,\n      mode: twigInner,\n      parseDelimiters: true\n    });\n  });\n  CodeMirror.defineMIME(\"text/x-twig\", \"twig\");\n});"],"sourceRoot":""}