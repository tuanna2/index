{"version":3,"sources":["../node_modules/codemirror/lib/codemirror.js","../node_modules/codemirror/mode/meta.js","../node_modules/@babel/runtime/helpers/interopRequireWildcard.js","../node_modules/@babel/runtime/regenerator/index.js","../node_modules/@babel/runtime/helpers/asyncToGenerator.js","../node_modules/@uiw/react-codemirror/lib/index.js","../node_modules/regenerator-runtime/runtime.js","../node_modules/@uiw/react-codemirror/lib/CodeMirror.js","../node_modules/codemirror/keymap/sublime.js","../node_modules/codemirror/addon/search/searchcursor.js","../node_modules/codemirror/addon/edit/matchbrackets.js"],"names":["module","exports","userAgent","navigator","platform","gecko","test","ie_upto10","ie_11up","exec","edge","ie","ie_version","document","documentMode","webkit","qtwebkit","chrome","presto","safari","vendor","mac_geMountainLion","phantom","ios","android","mobile","mac","chromeOS","windows","presto_version","match","Number","flipCtrlCmd","captureRightClick","classTest","cls","RegExp","range","rmClass","node","current","className","after","slice","index","length","removeChildren","e","count","childNodes","removeChild","firstChild","removeChildrenAndAdd","parent","appendChild","elt","tag","content","style","createElement","cssText","createTextNode","i","eltP","setAttribute","contains","child","nodeType","parentNode","host","activeElt","activeElement","body","shadowRoot","addClass","joinClasses","a","b","as","split","createRange","start","end","endNode","r","setEnd","setStart","createTextRange","moveToElementText","collapse","moveEnd","moveStart","selectInput","select","bind","f","args","Array","prototype","call","arguments","apply","copyObj","obj","target","overwrite","prop","hasOwnProperty","countColumn","string","tabSize","startIndex","startValue","search","n","nextTab","indexOf","selectionStart","selectionEnd","value","_e","Delayed","this","id","array","set","ms","clearTimeout","setTimeout","scrollerGap","Pass","toString","sel_dontScroll","scroll","sel_mouse","origin","sel_move","findColumn","goal","pos","col","skipped","Math","min","spaceStrs","spaceStr","push","lst","arr","map","out","nothing","createObj","base","props","inst","Object","create","nonASCIISingleCaseWordChar","isWordCharBasic","ch","toUpperCase","toLowerCase","isWordChar","helper","source","isEmpty","extendingChars","isExtendingChar","charCodeAt","skipExtendingChars","str","dir","charAt","findFirst","pred","from","to","midF","mid","ceil","floor","bidiOther","getBidiPartAt","order","sticky","found","cur","bidiOrdering","lowTypes","arabicTypes","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","BidiSpan","level","direction","code","outerType","len","types","i$1","prev","type","i$2","type$1","i$3","prev$1","type$2","i$4","type$3","replace","j","i$5","cur$1","type$4","i$6","end$1","before","replace$1","j$1","m","i$7","at","j$2","splice","nstart","unshift","reverse","getOrder","line","text","noHandlers","on","emitter","addEventListener","attachEvent","map$$1","_handlers","concat","getHandlers","off","removeEventListener","detachEvent","signal","handlers","signalDOMEvent","cm","override","preventDefault","defaultPrevented","e_defaultPrevented","codemirrorIgnore","signalCursorActivity","cursorActivity","curOp","cursorActivityHandlers","hasHandler","eventMixin","ctor","e_preventDefault","returnValue","e_stopPropagation","stopPropagation","cancelBubble","e_stop","e_target","srcElement","e_button","which","button","ctrlKey","zwspSupported","badBidiRects","dragAndDrop","div","zeroWidthElement","measure","offsetHeight","offsetWidth","hasBadBidiRects","txt","r0","getBoundingClientRect","r1","left","right","splitLinesAuto","result","l","nl","rt","hasSelection","window","getSelection","te","range$$1","ownerDocument","selection","parentElement","compareEndPoints","hasCopyEvent","oncopy","badZoomedRects","modes","mimeModes","resolveMode","spec","name","getMode","options","mfactory","modeObj","modeExtensions","exts","helperType","modeProps","prop$1","extendMode","mode","properties","copyState","state","nstate","val","innerMode","info","startState","a1","a2","StringStream","lineOracle","lastColumnPos","lastColumnValue","lineStart","getLine","doc","first","size","Error","chunk","lines","children","sz","chunkSize","getBetween","iter","getLines","updateLineHeight","height","diff","lineNo","no","_lineAtHeight","h","outer","lh","isLine","lineNumberFor","String","lineNumberFormatter","firstLineNumber","Pos","cmp","equalCursorPos","copyPos","x","maxPos","minPos","clipLine","max","_clipPos","last","linelen","clipToLen","clipPosArray","eol","sol","peek","undefined","next","eat","eatWhile","eatSpace","skipToEnd","skipTo","backUp","column","indentation","pattern","consume","caseInsensitive","cased","substr","hideFirstChars","inner","lookAhead","oracle","baseToken","SavedContext","Context","maxLookAhead","baseTokens","baseTokenPos","highlightLine","context","forceToEnd","st","modeGen","lineClasses","runMode","loop","o","overlay","overlays","i_end","opaque","styles","classes","bgClass","textClass","getLineStyles","updateFrontier","getContextBefore","resetState","maxHighlightLength","stateAfter","save","styleClasses","highlightFrontier","modeFrontier","precise","display","minindent","minline","lim","indented","findStartLine","saved","fromSaved","processLine","viewFrom","viewTo","nextLine","startAt","stream","callBlankLine","readToken","blankLine","token","copy","Token","takeToken","asArray","tokens","extractLineClasses","output","lineClass","flattenSpans","curStart","curStyle","addModeClass","mName","sawReadOnlySpans","sawCollapsedSpans","MarkedSpan","marker","getMarkedSpanFor","spans","span","removeMarkedSpan","stretchSpansOverChange","change","full","oldFirst","markedSpans","oldLast","startCh","endCh","isInsert","old","nw","startsBefore","inclusiveLeft","insertLeft","endsAfter","inclusiveRight","markedSpansBefore","markedSpansAfter","sameLine","offset","span$1","found$1","clearEmptySpans","newMarkers","gapMarkers","gap","clearWhenEmpty","detachMarkedSpans","detachLine","attachMarkedSpans","attachLine","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","find","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","collapsedSpanAround","conflictingCollapsedRange","lineNo$$1","visualLine","merged","visualLineNo","lineN","vis","visualLineEndNo","lastLine","lineIsHidden","widgetNode","lineIsHiddenInner","_heightAtLine","lineObj","p","lineLength","findMaxLine","d","maxLine","maxLineLength","maxLineChanged","Line","estimateHeight","cleanUpLine","styleToClassCache","styleToClassCacheWithMode","interpretTokenStyle","cache","buildLineContent","lineView","builder","pre","trailingSpace","splitSpaces","getOption","rest","addToken","buildToken","buildTokenBadBidi","allowFrontierUpdate","externalMeasured","insertLineContent","maps","caches","lastChild","querySelector","defaultSpecialCharPlaceholder","title","startStyle","endStyle","css","attributes","displayText","trailingBefore","spaceBefore","special","specialChars","mustWrap","createDocumentFragment","lastIndex","txt$1","tabWidth","specialCharPlaceholder","fullStyle","attr","part","buildCollapsedSpan","ignoreWidget","widget","input","needsContentAttribute","setUneditable","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","Infinity","foundBookmarks","endStyles","upto","tokenText","LineView","visualLineContinued","hidden","buildViewArray","nextPos","view","operationGroup","orphanDelayedCallbacks","signalLater","list","delayedCallbacks","fireOrphanDelayed","delayed","updateLineForChanges","dims","changes","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","zIndex","getLineContent","ext","built","background","wrap","insertBefore","updateLineBackground","wrapClass","gutter","gutterBackground","gutterClass","fixedGutter","fixedPos","gutterTotalWidth","markers","gutterMarkers","lineNumbers","wrap$1","gutterWrap","lineNumber","gutterLeft","lineNumInnerWidth","k","gutterSpecs","gutterWidth","alignable","nextSibling","insertLineWidgets","buildLineElement","insertLineWidgetsFor","allowAbove","widgets","ws","handleMouseEvents","positionLineWidget","above","noHScroll","width","wrapperWidth","coverGutter","paddingLeft","position","marginLeft","widgetHeight","parentStyle","gutters","wrapper","clientWidth","eventInWidget","getAttribute","sizer","mover","paddingTop","lineSpace","offsetTop","paddingVert","paddingH","cachedPaddingH","getComputedStyle","currentStyle","data","parseInt","paddingRight","isNaN","scrollGap","nativeBarWidth","displayWidth","scroller","barWidth","displayHeight","clientHeight","barHeight","mapFromLineView","measureChar","bias","measureCharPrepared","prepareMeasureForLine","findViewForLine","findViewIndex","getDimensions","forceUpdate","lineMeasure","updateExternalMeasurement","rect","hasHeights","prepared","varHeight","key","wrapping","lineWrapping","curWidth","heights","rects","getClientRects","abs","bottom","top","ensureLineHeights","place","nodeAndOffsetInLineMap","coverStart","coverEnd","getUsefulRect","screen","logicalXDPI","deviceXDPI","normal","fromRange","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","maybeUpdateRectForZooming","rSpan","charWidth","nullRect","rtop","rbot","bot","bogus","singleCursorHeightPerLine","rbottom","measureCharInner","measureText","mStart","mEnd","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","clearCaches","cachedCharWidth","cachedTextHeight","lineNumChars","pageScrollX","pageXOffset","documentElement","scrollLeft","pageScrollY","marginTop","pageYOffset","scrollTop","widgetTopHeight","intoCoordSystem","includeWidgets","yOff","viewOffset","lOff","xOff","fromCoordSystem","coords","localBox","lineSpaceBox","_charCoords","_cursorCoords","preparedMeasure","get","getBidi","partPos","invert","other","estimateCoords","PosWithInfo","outside","xRel","_coordsChar","y","coordsCharInner","rangeEnd","wrappedLineExtent","begin","wrappedLineExtentChar","targetTop","boxIsAfter","box","widgetHeight$$1","ltr","_lineNo","ref","closestDist","endX","dist","baseX","chAround","boxAround","atLeft","atStart","textHeight","anchor","clientLeft","offsetLeft","compensateForHScroll","th","perLine","widgetsHeight","estimateLineHeights","est","estHeight","posFromMouse","liberal","forRect","space","clientX","clientY","colDiff","round","regChange","lendiff","updateLineNumbers","viewChanged","resetView","cut","viewCuttingPoint","cut$1","cutTop","cutBot","regLineChange","oldN","newN","countDirtyView","dirty","updateSelection","showSelection","prepareSelection","primary","curFragment","cursors","selFragment","sel","ranges","primIndex","empty","showCursorWhenSelecting","drawSelectionCursor","head","drawSelectionRange","cursor","cursorHeight","otherCursor","cmpCoords","fragment","padding","leftSide","rightSide","sizerWidth","docLTR","add","drawForLine","fromArg","toArg","lineLen","wrapX","side","extent","iterateBidiSections","fromPos","toPos","openStart","openEnd","openLeft","openRight","topLeft","topRight","botLeft","botRight","sFrom","sTo","fromLine","toLine","singleVLine","leftEnd","rightStart","restartBlink","focused","clearInterval","blinker","cursorDiv","visibility","cursorBlinkRate","setInterval","ensureFocus","focus","onFocus","delayBlurEvent","delayingBlurEvent","onBlur","readOnly","selForContextMenu","reset","receivedFocus","shift","updateHeightsInViewport","prevBottom","lineDiv","updateWidgetHeight","chWidth","w","visibleLines","viewport","ensure","ensureFrom","ensureTo","calculateScrollPos","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollTop","resolveScrollToPos","ensureCursorVisible","getCursor","scrollToPos","margin","cursorScrollMargin","scrollToCoords","scrollToCoordsRange","sPos","updateScrollTop","updateDisplaySimple","setScrollTop","startWorker","forceScroll","scrollHeight","scrollbars","setScrollLeft","isScroller","scrollWidth","alignHorizontally","measureForScrollbars","gutterW","docH","viewHeight","viewWidth","barLeft","docHeight","NativeScrollbars","vert","horiz","tabIndex","checkedZeroWidth","minHeight","minWidth","update","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","pointerEvents","bar","delay","maybeDisable","elt$$1","elementFromPoint","clear","NullScrollbars","updateScrollbars","startWidth","startHeight","updateScrollbarsInner","sizes","paddingBottom","heightForcer","borderBottom","scrollbarFiller","coverGutterNextToScrollbar","gutterFiller","scrollbarModel","native","null","initScrollbars","scrollbarStyle","axis","nextOpId","_startOperation","op","updateInput","typing","changeObjs","cursorActivityCalled","selectionChanged","updateMaxLine","ops","ownsGroup","_endOperation","endCb","group","callbacks","fireCallbacksForOps","finishOperation","endOperation_R1","updatedDisplay","mustUpdate","updateDisplayIfNeeded","endOperation_R2","endOperation_W2","endOperation_finish","endOperations","scrollbarsClipped","marginBottom","borderRightWidth","maybeClipScrollbars","DisplayUpdate","barMeasure","adjustWidthTo","maxScrollLeft","preparedSelection","takeFocus","setDocumentHeight","postUpdateDisplay","wheelStartX","wheelStartY","limit","changed","endCoords","scrollPos","startTop","startLeft","scrollPosIntoView","doScroll","innerHeight","scrollNode","scrollIntoView","maybeScrollWindow","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","finish","runInOp","operation","methodOp","docMethodOp","time","highlight","highlightWorker","Date","workTime","changedLines","oldStyles","highlighted","oldCls","newCls","ischange","workDelay","force","visible","editorIsHidden","wrapperHeight","oldDisplayWidth","events","renderedView","maybeUpdateLineNumberWidth","viewportMargin","different","lastWrapHeight","lastWrapWidth","adjustView","toUpdate","selSnapshot","hasFocus","active","anchorNode","extend","anchorOffset","focusNode","focusOffset","selectionSnapshot","updateNumbersFrom","container","rm","currentWheelTarget","updateNumber","patchDisplay","snapshot","removeAllRanges","addRange","restoreSelection","selectionDiv","reportedViewFrom","reportedViewTo","updateGutterSpace","alignWidgets","comp","align","innerW","lineGutter","lineNumWidth","getGutters","sawLineNumbers","renderGutters","specs","gElt","updateGutters","Display","draggable","wheelDX","wheelDY","activeTouch","init","wheelSamples","wheelPixelsPerUnit","wheelEventDelta","dx","wheelDeltaX","dy","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","delta","onScrollWheel","canScrollX","canScrollY","pixels","movedX","movedY","sample","Selection","equals","here","there","deepCopy","Range","somethingSelected","normalizeSelection","mayTouch","selectionsMayTouch","prim","sort","inv","simpleSelection","changeEnd","adjustForChange","computeSelAfterChange","offsetPos","loadMode","modeOption","resetModeState","isWholeLineUpdate","wholeLineUpdateBefore","updateDoc","estimateHeight$$1","spansFor","updateLine","linesFor","firstLine","lastText","lastSpans","nlines","insert","remove","added","added$1","added$2","linkedDocs","sharedHistOnly","propagate","skip","sharedHist","linked","rel","shared","attachDoc","setDirectionClass","History","startGen","done","undone","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","histChange","attachLocalSpans","clearSelectionEvents","pop","addChangeToHistory","selAfter","opId","hist","history","historyEventDelay","lastChangeEvent","pushSelectionToHistory","addSelectionToHistory","selectionEventCanBeMerged","clearRedo","dest","existing","removeClearedSpans","explicitlyCleared","mergeOldSpans","getOldSpans","stretched","oldCur","stretchCur","copyHistoryArray","newGroup","instantiateSel","event","newChanges","extendRange","posBefore","extendSelection","setSelection","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","setSelectionReplaceHistory","setSelectionNoUndo","NaN","filterSelectionChange","setSelectionInner","skipAtomicInSelection","reCheckSelection","mayClear","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","preventCursorLeft","selectLeft","preventCursorRight","selectRight","atomic","near","movePos","far","cantEdit","selectAll","filterChange","canceled","cancel","makeChange","ignoreReadOnly","suppressEdits","mark","parts","mk","newParts","dfrom","dto","removeReadOnlyRanges","makeChangeInner","makeChangeSingleDoc","rebased","rebaseHist","makeChangeFromHistory","allowSelectionOnly","suppress","antiChanges","filter","returned","v","shiftDoc","distance","removed","recomputeMaxLength","checkWidthStart","retreatFrontier","changesHandler","changeHandler","makeChangeSingleDocInEditor","_replaceRange","assign","splitLines","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","changeLine","handle","changeType","LeafChunk","BranchChunk","removeInner","insertInner","iterN","oldHeight","remaining","leaf","maybeSpill","me","spilled","sibling","myIndex","used","LineWidget","opt","adjustScrollWhenAboveVisible","this$1","oldH","nextMarkerId","TextMarker","_markText","cloneNode","isParent","SharedTextMarker","markTextShared","replacedWith","addToHistory","curLine","addMarkedSpan","clearOnEnter","clearHistory","withOp","visual","dHeight","findSharedMarkers","findMarks","clipPos","detachSharedMarkers","subMarker","nextDocId","Doc","lineSep","cleanGeneration","constructor","getValue","join","lineSeparator","setValue","replaceRange","getRange","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","listSelections","setCursor","extendSelectionsBy","setSelections","addSelection","getSelections","replaceSelection","dup","replaceSelections","hint","oldPrev","newPrev","computeReplacedSel","undo","redo","undoSelection","redoSelection","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","setGutterMarker","gutterID","clearGutter","lineInfo","addLineClass","where","removeLineClass","addLineWidget","insertAt","aboveVisible","removeLineWidget","markText","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","mFrom","mTo","subMark","copySharedMarkers","unlinkDoc","CodeMirror","link","splitIds","iterLinkedDocs","getEditor","setDirection","eachLine","lastDrop","onDrop","clearDragCursor","files","dataTransfer","isReadOnly","FileReader","File","read","loadFile","file","allowDropFileTypes","reader","onload","readAsText","draggingText","text$1","getData","selected","dragCursor","forEachCodeMirror","getElementsByClassName","byClass","editors","globalsRegistered","ensureGlobalHandlers","resizeTimer","onResize","registerGlobalHandlers","setSize","keyNames","3","8","9","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","93","106","107","109","110","111","145","173","186","187","188","189","190","191","192","219","220","221","222","63232","63233","63234","63235","63272","63273","63275","63276","63277","63302","fromCharCode","keyMap","normalizeKeyName","alt","ctrl","cmd","mod","normalizeKeyMap","keymap","keyname","keys","lookupKey","getKeyMap","fallthrough","isModifierKey","keyCode","addModifierNames","noShift","altKey","metaKey","shiftKey","keyName","altGraphKey","deleteNearSelection","compute","kill","toKill","replaced","moveCharLogically","moveLogically","endOfLine","visually","moveInStorageOrder","prep","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","Ctrl-O","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","commands","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","charCoords","leftPos","coordsChar","delWrappedLineRight","rightPos","goDocStart","goDocEnd","goLineStart","goLineStartSmart","lineStartSmart","goLineEnd","visualLineEnd","lineEnd","goLineRight","cursorCoords","goLineLeft","goLineLeftSmart","goLineUp","moveV","goLineDown","goPageUp","goPageDown","goCharLeft","moveH","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","deleteH","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentSelection","indentMore","indentLess","insertTab","insertSoftTab","spaces","defaultTab","execCommand","transposeChars","newlineAndIndent","sels","indentLine","openLine","toggleOverwrite","firstNonWS","inWS","doHandleBinding","bound","dropShift","ensurePolled","prevShift","stopSeq","dispatchKey","seq","keySeq","dispatchKeyInner","keyMaps","extraKeys","lookupKeyForEditor","handleKeyBinding","motion","lastStoppedKey","onKeyDown","handled","up","showCrossHair","onKeyUp","onKeyPress","charCode","handleCharBinding","lastClick","lastDoubleClick","PastClick","onMouseDown","supportsTouch","clickInGutter","repeat","now","compare","clickRepeat","selectingText","handleMappedButton","contained","behavior","option","unit","addNew","moveOnDrag","configureMouse","dragDrop","moved","dragEnd","mouseMove","dragStart","e2","leftButtonStartDrag","ourRange","ourIndex","startSel","rangeForUnit","lastPos","extendTo","startCol","posCol","oldRange","ranges$1","anchorLine","boundary","headIndex","usePart","bidiSimplify","editorSize","counter","move","buttons","curCount","leftButtonSelect","leftButtonDown","onContextMenu","findWordAt","gutterEvent","prevent","mX","mY","touches","lineBox","g","contextMenuInGutter","themeChanged","theme","Init","defaults","optionHandlers","dragDropChanged","wasOn","funcs","dragFunctions","toggle","enter","over","leave","drop","wrappingChanged","inputStyles","inputStyle","pasteIncoming","cutIncoming","autofocus","word","touchFinished","prevTouch","finishTouch","farAway","touch","radiusX","radiusY","isMouseLikeTouchEvent","pageX","pageY","frag","onDragOver","setData","effectAllowed","setDragImage","img","src","_top","onDragStart","inp","getField","registerEventHandlers","finishInit","initHooks","textRendering","how","aggressive","indent","curSpace","curSpaceString","indentUnit","indentString","indentWithTabs","pos$1","defineInitHook","lastCopied","setLastCopied","newLastCopied","applyTextInput","inserted","deleted","recent","paste","textLines","multiPaste","pasteLinesPerSelection","lineWise","changeEvent","triggerElectric","handlePaste","pasted","clipboardData","disableInput","electricChars","smartIndent","getModeAt","electricInput","copyableRanges","lineRange","disableBrowserMagic","field","spellcheck","autocorrect","autocapitalize","hiddenTextarea","border","_findPosH","origDir","moveOnce","boundToLine","bidi","mv","getWrappedLineExtent","searchInVisualLine","getRes","res","nextCh","moveVisually","findNextLine","sawType","getHelper","hitSide","_findPosV","pageSize","moveAmount","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","composing","gracePeriod","readDOMTimeout","posToDOM","badPos","bad","domToPos","lineNode","locateNodeInLineView","textNode","topNode","nodeValue","curNode","textContent","previousSibling","dist$1","onCopyCut","lineWiseCopyCut","clearData","kludge","hadFocus","showPrimarySelection","updateFromDOM","readFromDOMSoon","forceCompositionEnd","showMultipleSelections","curAnchor","curFocus","rng","rangeCount","getRangeAt","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","blur","pollSelection","pollInterval","poll","scan","isInGutter","triggerOnKeyDown","pollContent","fromIndex","fromNode","toNode","toIndex","newText","closing","extraLinebreak","close","addText","walk","cmText","markerID","isBlock","nodeName","domTextBetween","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","readOnlyChanged","resetPosition","TextareaInput","prevInput","pollingFast","createField","textarea","prepareCopyCut","fastPoll","dispatchEvent","Event","_display","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","slowPoll","missed","same","resetSelectionOnContextMenu","oldScrollY","oldCSS","oldWrapperCSS","wrapperBox","offsetParent","scrollY","scrollTo","rehide","detectingSelectAll","prepareSelectAllHack","mouseup","extval","disabled","deflt","notOnInit","defineOption","newBreaks","refresh","getInputField","detach","attach","integer","defineOptions","helpers","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","score","priority","insertSorted","modeSpec","removeOverlay","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","help","_global","getStateAfter","lineAtHeight","heightAtLine","defaultTextHeight","defaultCharWidth","getViewport","addWidget","vspace","hspace","triggerOnKeyPress","triggerOnKeyUp","triggerOnMouseDown","findPosH","amount","rtlMoveVisually","findPosV","goalColumn","goals","startChar","check","getScrollInfo","scrollToRange","interpret","startOperation","endOperation","swapDoc","phrase","phraseText","phrases","getWrapperElement","getScrollerElement","getGutterElement","registerHelper","registerGlobalHelper","predicate","addEditorMethods","dontDelegate","method","contenteditable","defineMode","dependencies","defineMIME","mime","defineExtension","func","defineDocExtension","fromTextArea","tabindex","placeholder","realSubmit","form","leaveSubmitMethodAlone","submit","wrappedSubmit","getTextArea","toTextArea","cmpPos","addLegacyProps","version","factory","modeInfo","mimes","alias","findModeByMIME","findModeByExtension","findModeByFileName","filename","dot","lastIndexOf","substring","findModeByName","__webpack_require__","__esModule","newObj","desc","defineProperty","getOwnPropertyDescriptor","asyncGeneratorStep","resolve","reject","_next","_throw","arg","error","Promise","then","fn","self","err","_interopRequireWildcard","_interopRequireDefault","default","_extends2","_objectWithoutProperties2","_regenerator","_asyncToGenerator2","_classCallCheck2","_createClass2","_possibleConstructorReturn2","_getPrototypeOf2","_inherits2","_assertThisInitialized2","_defineProperty2","_react","_propTypes","_CodeMirror","ReactCodeMirror","_Component","_this","instance","codemirror","editor","codeMirrorOptions","_componentDidMount","_callee","_context","autoCloseBrackets","matchBrackets","fullScreen","setState","stop","_componentWillReceiveProps","_callee2","nextPros","_context2","_x","_this$props","otherProps","getInstance","Component","defaultProps","propTypes","object","runtime","Op","hasOwn","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","_invoke","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","GenStateSuspendedYield","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","previousPromise","callInvokeWithMethodAndArg","invoke","__await","unwrapped","TypeError","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","iterable","iteratorMethod","displayName","isGeneratorFunction","genFun","setPrototypeOf","__proto__","awrap","async","skipTempReset","rootRecord","rval","exception","loc","caught","hasCatch","hasFinally","finallyEntry","complete","catch","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","_typeof2","_codemirror","renderCodeMirror","_this2","eventDict","getEventHandleFromProps","nextProps","setOptions","_setOptions","_this3","JSON","stringify","_x2","eventHandle","ele","s","_this4","oneOfType","number","cmds","moveSubword","cat","findPosSubword","insertLine","newSelection","wordAt","addCursorToSelection","newRange","goSubwordLeft","goSubwordRight","scrollLineUp","visibleBottomLine","scrollLineDown","visibleTopLine","splitSelectionByLine","lineRanges","singleSelectionTop","selectLine","extended","insertLineAfter","insertLineBefore","selectNextOccurrence","fullWord","sublimeFindFullWord","query","getSearchCursor","findNext","isSelectedRange","addCursorToPrevLine","addCursorToNextLine","mirror","selectBetweenBrackets","opening","scanForBracket","startPos","sortLines","caseSensitive","toSort","au","bu","modifyWordOrSelection","indices","replacements","getTarget","findAndGoTo","forward","findPrevious","selectScope","goToBracket","swapLineUp","linesToMove","newSels","swapLineDown","toggleCommentIndented","toggleComment","joinLines","joined","actual","duplicateLine","sortLinesInsensitive","nextBookmark","marks","sublimeBookmarks","prevBookmark","toggleBookmark","sublimeBookmark","clearBookmarks","selectBookmarks","smartBackspace","toStartOfLine","deletePos","prevIndent","delLineRight","upcaseAtCursor","downcaseAtCursor","setSublimeMark","sublimeMark","selectToSublimeMark","deleteToSublimeMark","tmp","sublimeKilled","swapWithSublimeMark","sublimeYank","showInCenter","findUnder","findUnderPrevious","findAllUnder","matches","primaryIndex","macSublime","Shift-Ctrl-K","Alt-Q","Ctrl-Alt-Up","Ctrl-Alt-Down","Cmd-L","Shift-Cmd-L","Cmd-Enter","Shift-Cmd-Enter","Shift-Cmd-Space","Shift-Cmd-M","Cmd-M","Cmd-Ctrl-Up","Cmd-Ctrl-Down","Cmd-/","Cmd-J","Shift-Cmd-D","F5","Cmd-F5","F2","Shift-F2","Cmd-F2","Shift-Cmd-F2","Alt-F2","Cmd-K Cmd-K","Cmd-K Cmd-U","Cmd-K Cmd-L","Cmd-K Cmd-Space","Cmd-K Cmd-A","Cmd-K Cmd-W","Cmd-K Cmd-X","Cmd-K Cmd-Y","Cmd-K Cmd-C","Cmd-K Cmd-G","Cmd-K Cmd-Backspace","Cmd-K Cmd-0","Cmd-K Cmd-J","Ctrl-Shift-Up","Ctrl-Shift-Down","Cmd-F3","Shift-Cmd-F3","Alt-F3","Shift-Cmd-[","Shift-Cmd-]","Cmd-I","Shift-Cmd-I","Cmd-H","F3","Shift-F3","pcSublime","Ctrl-L","Shift-Ctrl-L","Ctrl-Enter","Shift-Ctrl-Enter","Shift-Ctrl-Space","Shift-Ctrl-M","Ctrl-M","Shift-Ctrl-Up","Shift-Ctrl-Down","Ctrl-/","Ctrl-J","Shift-Ctrl-D","F9","Ctrl-F9","Ctrl-F2","Shift-Ctrl-F2","Ctrl-K Ctrl-K","Ctrl-K Ctrl-U","Ctrl-K Ctrl-L","Ctrl-K Ctrl-Space","Ctrl-K Ctrl-A","Ctrl-K Ctrl-W","Ctrl-K Ctrl-X","Ctrl-K Ctrl-Y","Ctrl-K Ctrl-C","Ctrl-K Ctrl-G","Ctrl-K Ctrl-Backspace","Ctrl-K Ctrl-0","Ctrl-K Ctrl-J","Ctrl-F3","Shift-Ctrl-F3","Shift-Ctrl-[","Shift-Ctrl-]","Ctrl-I","Shift-Ctrl-I","sublime","doFold","noFold","ensureFlags","regexp","flags","ignoreCase","global","multiline","regexpFlags","searchRegexpForward","lastMatchIn","cutOff","newMatch","adjustPos","orig","folded","foldFunc","SearchCursor","caseFold","atOccurrence","fold","topString","cutFrom","endString","inside","startLine","maybeMultiline","normalize","ie_lt8","matching","(",")","[","]","{","}","<",">","bracketRegex","config","findMatchingBracket","afterCursor","re","strict","maxScanLen","maxScanLineLength","maxScanLines","stack","autoclear","maxHighlightLen","maxHighlightLineLength","doMatchBrackets","currentlyHighlighted","oldConfig"],"mappings":"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tD,KAAA,QACAiT,IAAA,iBACG,CACH5T,KAAA,MACAiuD,KAAA,gBACAttD,KAAA,QACAiT,IAAA,gDACAy7C,MAAA,SACG,CACHrvD,KAAA,QACAiuD,KAAA,eACAttD,KAAA,QACAiT,IAAA,eACG,CACH5T,KAAA,KACAiuD,KAAA,gBACAttD,KAAA,QACAiT,IAAA,OACAy7C,MAAA,iBACG,CACHrvD,KAAA,UACAiuD,KAAA,iBACAttD,KAAA,UACAiT,IAAA,uBACG,CACH5T,KAAA,gBACAiuD,KAAA,uBACAttD,KAAA,UACAiT,IAAA,UACG,CACH5T,KAAA,4BACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,QACAiuD,KAAA,eACAttD,KAAA,QACAiT,IAAA,qBACAmzB,KAAA,oBACG,CACH/mC,KAAA,eACAovD,MAAA,2EACAzuD,KAAA,eACAiT,IAAA,WACAy7C,MAAA,4BACG,CACHrvD,KAAA,cACAiuD,KAAA,qBACAttD,KAAA,aACAiT,IAAA,mBACAy7C,MAAA,UACG,CACHrvD,KAAA,SACAiuD,KAAA,6BACAttD,KAAA,SACAiT,IAAA,kBACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,qBACG,CACH5T,KAAA,UACAiuD,KAAA,iBACAttD,KAAA,UACAiT,IAAA,QACG,CACH5T,KAAA,MACAiuD,KAAA,WACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,MACAiuD,KAAA,mBACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,IACAiuD,KAAA,WACAttD,KAAA,IACAiT,IAAA,OACG,CACH5T,KAAA,OACAovD,MAAA,mCACAzuD,KAAA,OACAiT,IAAA,UACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,OACAiT,IAAA,kBACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,UACG,CACHX,KAAA,aACAiuD,KAAA,oBACAttD,KAAA,aACAomC,KAAA,gBACG,CACH/mC,KAAA,MACAiuD,KAAA,sBACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,QACAiuD,KAAA,eACAttD,KAAA,QACAiT,IAAA,wBACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,QACG,CACHX,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,MACAiuD,KAAA,kBACAttD,KAAA,UACAiT,IAAA,SACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,OACG,CACH5T,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,sBACAiuD,KAAA,oBACAttD,KAAA,eACAiT,IAAA,SACG,CACH5T,KAAA,gBACAiuD,KAAA,oBACAttD,KAAA,eACAiT,IAAA,SACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,SACG,CACH5T,KAAA,QACAiuD,KAAA,eACAttD,KAAA,OACG,CACHX,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,YACG,CACH5T,KAAA,MACAiuD,KAAA,aACAttD,KAAA,OACG,CACHX,KAAA,QACAiuD,KAAA,eACAttD,KAAA,QACAiT,IAAA,uBACG,CACH5T,KAAA,UACAiuD,KAAA,iBACAttD,KAAA,UACAiT,IAAA,+BACG,CACH5T,KAAA,KACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,OACAy7C,MAAA,YACG,CACHrvD,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,OACG,CACH5T,KAAA,UACAiuD,KAAA,iBACAttD,KAAA,UACAiT,IAAA,aACG,CACH5T,KAAA,2BACAiuD,KAAA,aACAttD,KAAA,MACAomC,KAAA,uCACG,CACH/mC,KAAA,KACAiuD,KAAA,YACAttD,KAAA,KACAiT,IAAA,QACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,oBACAmzB,KAAA,iBACG,CACH/mC,KAAA,OACAiuD,KAAA,cACAttD,KAAA,OACAiT,IAAA,UACG,CACH5T,KAAA,UACAiuD,KAAA,iBACAttD,KAAA,UACAiT,IAAA,QACG,CACH5T,KAAA,qBACAiuD,KAAA,0BACAttD,KAAA,mBACAiT,IAAA,SACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,OACAiT,IAAA,QACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,OACAiT,IAAA,UACG,CACH5T,KAAA,UACAiuD,KAAA,qBACAttD,KAAA,eACAiT,IAAA,SACAy7C,MAAA,gBACG,CACHrvD,KAAA,OACAiuD,KAAA,YACAttD,KAAA,YACAiT,IAAA,kCACAy7C,MAAA,WACG,CACHrvD,KAAA,OACAiuD,KAAA,eACAttD,KAAA,QACG,CACHX,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,eACAy7C,MAAA,UACG,CACHrvD,KAAA,OACAiuD,KAAA,cACAttD,KAAA,QACAiT,IAAA,UACG,CACH5T,KAAA,oBACAiuD,KAAA,oBACAttD,KAAA,eACAiT,IAAA,QACAy7C,MAAA,SACG,CACHrvD,KAAA,aACAovD,MAAA,mHACAzuD,KAAA,aACAiT,IAAA,OACAy7C,MAAA,4BACG,CACHrvD,KAAA,OACAovD,MAAA,0CACAzuD,KAAA,aACAiT,IAAA,eACAy7C,MAAA,WACG,CACHrvD,KAAA,UACAiuD,KAAA,sBACAttD,KAAA,aACAiT,IAAA,WACAy7C,MAAA,YACG,CACHrvD,KAAA,MACAiuD,KAAA,WACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,SACAiuD,KAAA,cACAttD,KAAA,SACAiT,IAAA,yBACG,CACH5T,KAAA,QACAiuD,KAAA,eACAttD,KAAA,QACAiT,IAAA,QACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,QACAiT,IAAA,QACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,MACAiT,IAAA,UACG,CACH5T,KAAA,aACAiuD,KAAA,oBACAttD,KAAA,aACAiT,IAAA,OACAy7C,MAAA,QACG,CACHrvD,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,WACAiuD,KAAA,kBACAttD,KAAA,WACAiT,IAAA,yBACG,CACH5T,KAAA,OACAiuD,KAAA,YACAttD,KAAA,QACG,CACHX,KAAA,cACAiuD,KAAA,iBACAttD,KAAA,OACG,CACHX,KAAA,cACAiuD,KAAA,qBACAttD,KAAA,cACAiT,IAAA,YACG,CACH5T,KAAA,WACAiuD,KAAA,kBACAttD,KAAA,WACAiT,IAAA,QACG,CACH5T,KAAA,QACAiuD,KAAA,eACAttD,KAAA,QACAiT,IAAA,SACG,CACH5T,KAAA,SACAiuD,KAAA,eACAttD,KAAA,OACG,CACHX,KAAA,OACAiuD,KAAA,mBACAttD,KAAA,OACAiT,IAAA,UACG,CACH5T,KAAA,QACAiuD,KAAA,eACAttD,KAAA,OACG,CACHX,KAAA,QACAiuD,KAAA,oBACAttD,KAAA,QACAomC,KAAA,mBACG,CACH/mC,KAAA,OACAiuD,KAAA,cACAttD,KAAA,OACAiT,IAAA,eACG,CACH5T,KAAA,WACAovD,MAAA,iEACAzuD,KAAA,WACAiT,IAAA,aACG,CACH5T,KAAA,cACAiuD,KAAA,oBACAttD,KAAA,QACAiT,IAAA,WACAy7C,MAAA,wBACG,CACHrvD,KAAA,QACAiuD,KAAA,eACAttD,KAAA,SACAiT,IAAA,0BACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,OACG,CACH5T,KAAA,KACAiuD,KAAA,YACAttD,KAAA,KACAiT,IAAA,QACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,aACG,CACH5T,KAAA,SACAiuD,KAAA,OACAttD,KAAA,QACAiT,IAAA,YACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,OACAiT,IAAA,aACG,CACH5T,KAAA,MACAovD,MAAA,wEACAzuD,KAAA,MACAiT,IAAA,6CACG,CACH5T,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,aACAiuD,KAAA,aACAttD,KAAA,OACAiT,IAAA,0CACG,CACH5T,KAAA,QACAiuD,KAAA,eACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,aACAiuD,KAAA,eACAttD,KAAA,OACG,CACHX,KAAA,aACAiuD,KAAA,2BACAttD,KAAA,aACAiT,IAAA,uBACG,CACH5T,KAAA,mBACAiuD,KAAA,oBACAttD,KAAA,aACAiT,IAAA,0BACAy7C,MAAA,sBACG,CACHrvD,KAAA,WACAiuD,KAAA,kBACAttD,KAAA,WACAiT,IAAA,WACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,2BACAmzB,KAAA,kBACG,CACH/mC,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,QACG,CACH5T,KAAA,IACAiuD,KAAA,WACAttD,KAAA,IACAiT,IAAA,OACG,CACH5T,KAAA,IACAiuD,KAAA,cACAttD,KAAA,IACAiT,IAAA,UACAy7C,MAAA,aACG,CACHrvD,KAAA,mBACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,QACAy7C,MAAA,SACG,CACHrvD,KAAA,cACAiuD,KAAA,qBACAttD,KAAA,OACG,CACHX,KAAA,WACAiuD,KAAA,kBACAttD,KAAA,MACAiT,IAAA,UACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,OACAiT,IAAA,OACAy7C,MAAA,uCACG,CACHrvD,KAAA,OACAiuD,KAAA,iBACAttD,KAAA,OACAiT,IAAA,QACG,CACH5T,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,OACAiT,IAAA,UACG,CACH5T,KAAA,QACAiuD,KAAA,eACAttD,KAAA,QACAiT,IAAA,WACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,cACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,MACAiT,IAAA,UACG,CACH5T,KAAA,QACAovD,MAAA,iCACAzuD,KAAA,QACAiT,IAAA,oBACAy7C,MAAA,oBACAtoB,KAAA,cACG,CACH/mC,KAAA,QACAiuD,KAAA,oBACAttD,KAAA,QACAiT,IAAA,iBACG,CACH5T,KAAA,OACAovD,MAAA,qCACAzuD,KAAA,OACAiT,IAAA,UACG,CACH5T,KAAA,YACAiuD,KAAA,eACAttD,KAAA,YACAiT,IAAA,QACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,SACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,QACG,CACHX,KAAA,MACAiuD,KAAA,aACAttD,KAAA,SACAiT,IAAA,iCACG,CACH5T,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,QACAy7C,MAAA,sBACG,CACHrvD,KAAA,SACAiuD,KAAA,2BACAttD,KAAA,SACAiT,IAAA,gBACAy7C,MAAA,YACG,CACHrvD,KAAA,cACAiuD,KAAA,qBACAttD,KAAA,cACA0uD,MAAA,qBACG,CACHrvD,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,SACAiuD,KAAA,gBACAttD,KAAA,OACG,CACHX,KAAA,WACAiuD,KAAA,kBACAttD,KAAA,QACAiT,IAAA,SACG,CACH5T,KAAA,SACAiuD,KAAA,cACAttD,KAAA,SACAiT,IAAA,UACG,CACH5T,KAAA,QACAiuD,KAAA,eACAttD,KAAA,QACAiT,IAAA,WACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,QACG,CACHX,KAAA,QACAiuD,KAAA,eACAttD,KAAA,OACAiT,IAAA,qBACAy7C,MAAA,SACG,CACHrvD,KAAA,gBACAiuD,KAAA,uBACAttD,KAAA,UACAiT,IAAA,kBACG,CACH5T,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,UACAiuD,KAAA,iBACAttD,KAAA,UACAiT,IAAA,aACG,CACH5T,KAAA,cACAiuD,KAAA,oBACAttD,KAAA,cACG,CACHX,KAAA,YACAiuD,KAAA,YACAttD,KAAA,QACG,CACHX,KAAA,OACAiuD,KAAA,cACAttD,KAAA,OACAiT,IAAA,UACG,CACH5T,KAAA,UACAiuD,KAAA,iBACAttD,KAAA,WACG,CACHX,KAAA,QACAiuD,KAAA,aACAttD,KAAA,QACAiT,IAAA,uCACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,OACAiT,IAAA,2BACG,CACH5T,KAAA,WACAiuD,KAAA,kBACAttD,KAAA,WACAiT,IAAA,SACG,CACH5T,KAAA,SACAiuD,KAAA,cACAttD,KAAA,SACAiT,IAAA,SACG,CACH5T,KAAA,aACAiuD,KAAA,yBACAttD,KAAA,aACAiT,IAAA,OACAy7C,MAAA,QACG,CACHrvD,KAAA,iBACAiuD,KAAA,sBACAttD,KAAA,MACAiT,IAAA,QACAy7C,MAAA,SACG,CACHrvD,KAAA,OACAiuD,KAAA,cACAttD,KAAA,QACG,CACHX,KAAA,UACAiuD,KAAA,gBACAttD,KAAA,SACAiT,IAAA,YACG,CACH5T,KAAA,SACAiuD,KAAA,YACAttD,KAAA,KACAiT,IAAA,QACG,CACH5T,KAAA,WACAiuD,KAAA,gBACAttD,KAAA,WACAiT,IAAA,SACG,CACH5T,KAAA,WACAiuD,KAAA,gBACAttD,KAAA,WACAiT,IAAA,SACG,CACH5T,KAAA,UACAiuD,KAAA,iBACAttD,KAAA,UACAiT,IAAA,OACG,CACH5T,KAAA,OACAiuD,KAAA,cACAttD,KAAA,OACAiT,IAAA,gBACG,CACH5T,KAAA,mBACAovD,MAAA,8BACAzuD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,MACAovD,MAAA,+BACAzuD,KAAA,MACAiT,IAAA,0BACAy7C,MAAA,sBACG,CACHrvD,KAAA,SACAiuD,KAAA,qBACAttD,KAAA,SACAiT,IAAA,iBACG,CACH5T,KAAA,QACAiuD,KAAA,eACAttD,KAAA,QACAiT,IAAA,QACG,CACH5T,KAAA,OACAovD,MAAA,4BACAzuD,KAAA,OACAiT,IAAA,eACAy7C,MAAA,SACG,CACHrvD,KAAA,MACAiuD,KAAA,aACAttD,KAAA,MACAiT,IAAA,SACG,CACH5T,KAAA,SA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","file":"static/js/10.cc9840ab.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.CodeMirror = factory();\n})(this, function () {\n  'use strict'; // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n  var android = /Android/.test(userAgent); // This is woefully incomplete. Suggestions for alternative methods welcome.\n\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n\n  if (presto_version) {\n    presto_version = Number(presto_version[1]);\n  }\n\n  if (presto_version && presto_version >= 15) {\n    presto = false;\n    webkit = true;\n  } // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n\n\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || ie && ie_version >= 9;\n\n  function classTest(cls) {\n    return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\");\n  }\n\n  var rmClass = function rmClass(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count) {\n      e.removeChild(e.firstChild);\n    }\n\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n\n    if (className) {\n      e.className = className;\n    }\n\n    if (style) {\n      e.style.cssText = style;\n    }\n\n    if (typeof content == \"string\") {\n      e.appendChild(document.createTextNode(content));\n    } else if (content) {\n      for (var i = 0; i < content.length; ++i) {\n        e.appendChild(content[i]);\n      }\n    }\n\n    return e;\n  } // wrapper for elt, which removes the elt from the accessibility tree\n\n\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e;\n  }\n\n  var range;\n\n  if (document.createRange) {\n    range = function range(node, start, end, endNode) {\n      var r = document.createRange();\n      r.setEnd(endNode || node, end);\n      r.setStart(node, start);\n      return r;\n    };\n  } else {\n    range = function range(node, start, end) {\n      var r = document.body.createTextRange();\n\n      try {\n        r.moveToElementText(node.parentNode);\n      } catch (e) {\n        return r;\n      }\n\n      r.collapse(true);\n      r.moveEnd(\"character\", end);\n      r.moveStart(\"character\", start);\n      return r;\n    };\n  }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      {\n        child = child.parentNode;\n      }\n\n    if (parent.contains) {\n      return parent.contains(child);\n    }\n\n    do {\n      if (child.nodeType == 11) {\n        child = child.host;\n      }\n\n      if (child == parent) {\n        return true;\n      }\n    } while (child = child.parentNode);\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n\n    try {\n      activeElement = document.activeElement;\n    } catch (e) {\n      activeElement = document.body || null;\n    }\n\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {\n      activeElement = activeElement.shadowRoot.activeElement;\n    }\n\n    return activeElement;\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n\n    if (!classTest(cls).test(current)) {\n      node.className += (current ? \" \" : \"\") + cls;\n    }\n  }\n\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n\n    for (var i = 0; i < as.length; i++) {\n      if (as[i] && !classTest(as[i]).test(b)) {\n        b += \" \" + as[i];\n      }\n    }\n\n    return b;\n  }\n\n  var selectInput = function selectInput(node) {\n    node.select();\n  };\n\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    {\n      selectInput = function selectInput(node) {\n        node.selectionStart = 0;\n        node.selectionEnd = node.value.length;\n      };\n    } else if (ie) // Suppress mysterious IE10 errors\n    {\n      selectInput = function selectInput(node) {\n        try {\n          node.select();\n        } catch (_e) {}\n      };\n    }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function () {\n      return f.apply(null, args);\n    };\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) {\n      target = {};\n    }\n\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {\n        target[prop] = obj[prop];\n      }\n    }\n\n    return target;\n  } // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n\n\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n\n      if (end == -1) {\n        end = string.length;\n      }\n    }\n\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n\n      if (nextTab < 0 || nextTab >= end) {\n        return n + (end - i);\n      }\n\n      n += nextTab - i;\n      n += tabSize - n % tabSize;\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function Delayed() {\n    this.id = null;\n  };\n\n  Delayed.prototype.set = function (ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i) {\n      if (array[i] == elt) {\n        return i;\n      }\n    }\n\n    return -1;\n  } // Number of pixels added to scroller and sizer to hide scrollbar\n\n\n  var scrollerGap = 30; // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n\n  var Pass = {\n    toString: function toString() {\n      return \"CodeMirror.Pass\";\n    }\n  }; // Reused option objects for setSelection & friends\n\n  var sel_dontScroll = {\n    scroll: false\n  },\n      sel_mouse = {\n    origin: \"*mouse\"\n  },\n      sel_move = {\n    origin: \"+move\"\n  }; // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n\n      if (nextTab == -1) {\n        nextTab = string.length;\n      }\n\n      var skipped = nextTab - pos;\n\n      if (nextTab == string.length || col + skipped >= goal) {\n        return pos + Math.min(skipped, goal - col);\n      }\n\n      col += nextTab - pos;\n      col += tabSize - col % tabSize;\n      pos = nextTab + 1;\n\n      if (col >= goal) {\n        return pos;\n      }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n\n  function spaceStr(n) {\n    while (spaceStrs.length <= n) {\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    }\n\n    return spaceStrs[n];\n  }\n\n  function lst(arr) {\n    return arr[arr.length - 1];\n  }\n\n  function map(array, f) {\n    var out = [];\n\n    for (var i = 0; i < array.length; i++) {\n      out[i] = f(array[i], i);\n    }\n\n    return out;\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0,\n        priority = score(value);\n\n    while (pos < array.length && score(array[pos]) <= priority) {\n      pos++;\n    }\n\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n\n    if (props) {\n      copyObj(props, inst);\n    }\n\n    return inst;\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  }\n\n  function isWordChar(ch, helper) {\n    if (!helper) {\n      return isWordCharBasic(ch);\n    }\n\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) {\n      return true;\n    }\n\n    return helper.test(ch);\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) {\n      if (obj.hasOwnProperty(n) && obj[n]) {\n        return false;\n      }\n    }\n\n    return true;\n  } // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n\n\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n\n  function isExtendingChar(ch) {\n    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n  } // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n\n\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {\n      pos += dir;\n    }\n\n    return pos;\n  } // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n\n\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n\n    for (;;) {\n      if (from == to) {\n        return from;\n      }\n\n      var midF = (from + to) / 2,\n          mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n\n      if (mid == from) {\n        return pred(mid) ? from : to;\n      }\n\n      if (pred(mid)) {\n        to = mid;\n      } else {\n        from = mid + dir;\n      }\n    }\n  } // BIDI HELPERS\n\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) {\n      return f(from, to, \"ltr\", 0);\n    }\n\n    var found = false;\n\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n\n    if (!found) {\n      f(from, to, \"ltr\");\n    }\n  }\n\n  var bidiOther = null;\n\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n\n      if (cur.from < ch && cur.to > ch) {\n        return i;\n      }\n\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") {\n          found = i;\n        } else {\n          bidiOther = i;\n        }\n      }\n\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") {\n          found = i;\n        } else {\n          bidiOther = i;\n        }\n      }\n    }\n\n    return found != null ? found : bidiOther;\n  } // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n\n\n  var bidiOrdering = function () {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\"; // Character types for codepoints 0x600 to 0x6f9\n\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n\n    function charType(code) {\n      if (code <= 0xf7) {\n        return lowTypes.charAt(code);\n      } else if (0x590 <= code && code <= 0x5f4) {\n        return \"R\";\n      } else if (0x600 <= code && code <= 0x6f9) {\n        return arabicTypes.charAt(code - 0x600);\n      } else if (0x6ee <= code && code <= 0x8ac) {\n        return \"r\";\n      } else if (0x2000 <= code && code <= 0x200b) {\n        return \"w\";\n      } else if (code == 0x200c) {\n        return \"b\";\n      } else {\n        return \"L\";\n      }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/,\n        isStrong = /[LRr]/,\n        countsAsLeft = /[Lb1n]/,\n        countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from;\n      this.to = to;\n    }\n\n    return function (str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) {\n        return false;\n      }\n\n      var len = str.length,\n          types = [];\n\n      for (var i = 0; i < len; ++i) {\n        types.push(charType(str.charCodeAt(i)));\n      } // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n\n\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n\n        if (type == \"m\") {\n          types[i$1] = prev;\n        } else {\n          prev = type;\n        }\n      } // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n\n\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n\n        if (type$1 == \"1\" && cur == \"r\") {\n          types[i$2] = \"n\";\n        } else if (isStrong.test(type$1)) {\n          cur = type$1;\n\n          if (type$1 == \"r\") {\n            types[i$2] = \"R\";\n          }\n        }\n      } // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n\n\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3 + 1] == \"1\") {\n          types[i$3] = \"1\";\n        } else if (type$2 == \",\" && prev$1 == types[i$3 + 1] && (prev$1 == \"1\" || prev$1 == \"n\")) {\n          types[i$3] = prev$1;\n        }\n\n        prev$1 = type$2;\n      } // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n\n\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n\n        if (type$3 == \",\") {\n          types[i$4] = \"N\";\n        } else if (type$3 == \"%\") {\n          var end = void 0;\n\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n\n          var replace = i$4 && types[i$4 - 1] == \"!\" || end < len && types[end] == \"1\" ? \"1\" : \"N\";\n\n          for (var j = i$4; j < end; ++j) {\n            types[j] = replace;\n          }\n\n          i$4 = end - 1;\n        }\n      } // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n\n\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n\n        if (cur$1 == \"L\" && type$4 == \"1\") {\n          types[i$5] = \"L\";\n        } else if (isStrong.test(type$4)) {\n          cur$1 = type$4;\n        }\n      } // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n\n\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = void 0;\n\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n\n          var before = (i$6 ? types[i$6 - 1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? before ? \"L\" : \"R\" : outerType;\n\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) {\n            types[j$1] = replace$1;\n          }\n\n          i$6 = end$1 - 1;\n        }\n      } // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n\n\n      var order = [],\n          m;\n\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7,\n              at = order.length;\n\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) {\n                order.splice(at, 0, new BidiSpan(1, pos, j$2));\n              }\n\n              var nstart = j$2;\n\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              pos = j$2;\n            } else {\n              ++j$2;\n            }\n          }\n\n          if (pos < i$7) {\n            order.splice(at, 0, new BidiSpan(1, pos, i$7));\n          }\n        }\n      }\n\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order;\n    };\n  }(); // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n\n\n  function getOrder(line, direction) {\n    var order = line.order;\n\n    if (order == null) {\n      order = line.order = bidiOrdering(line.text, direction);\n    }\n\n    return order;\n  } // EVENT HANDLING\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n\n  var noHandlers = [];\n\n  var on = function on(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers || (emitter._handlers = {});\n      map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers;\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers,\n          arr = map$$1 && map$$1[type];\n\n      if (arr) {\n        var index = indexOf(arr, f);\n\n        if (index > -1) {\n          map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n        }\n      }\n    }\n  }\n\n  function signal(emitter, type\n  /*, values...*/\n  ) {\n    var handlers = getHandlers(emitter, type);\n\n    if (!handlers.length) {\n      return;\n    }\n\n    var args = Array.prototype.slice.call(arguments, 2);\n\n    for (var i = 0; i < handlers.length; ++i) {\n      handlers[i].apply(null, args);\n    }\n  } // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n\n\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\") {\n      e = {\n        type: e,\n        preventDefault: function preventDefault() {\n          this.defaultPrevented = true;\n        }\n      };\n    }\n\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n\n    if (!arr) {\n      return;\n    }\n\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n\n    for (var i = 0; i < arr.length; ++i) {\n      if (indexOf(set, arr[i]) == -1) {\n        set.push(arr[i]);\n      }\n    }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0;\n  } // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n\n\n  function eventMixin(ctor) {\n    ctor.prototype.on = function (type, f) {\n      on(this, type, f);\n    };\n\n    ctor.prototype.off = function (type, f) {\n      off(this, type, f);\n    };\n  } // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n  }\n\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else {\n      e.cancelBubble = true;\n    }\n  }\n\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n\n  function e_stop(e) {\n    e_preventDefault(e);\n    e_stopPropagation(e);\n  }\n\n  function e_target(e) {\n    return e.target || e.srcElement;\n  }\n\n  function e_button(e) {\n    var b = e.which;\n\n    if (b == null) {\n      if (e.button & 1) {\n        b = 1;\n      } else if (e.button & 2) {\n        b = 3;\n      } else if (e.button & 4) {\n        b = 2;\n      }\n    }\n\n    if (mac && e.ctrlKey && b == 1) {\n      b = 3;\n    }\n\n    return b;\n  } // Detect drag-and-drop\n\n\n  var dragAndDrop = function () {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) {\n      return false;\n    }\n\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  var zwspSupported;\n\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200B\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n\n      if (measure.firstChild.offsetHeight != 0) {\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n      }\n    }\n\n    var node = zwspSupported ? elt(\"span\", \"\\u200B\") : elt(\"span\", \"\\xA0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node;\n  } // Feature-detect IE's crummy client rect reporting for bidi text\n\n\n  var badBidiRects;\n\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) {\n      return badBidiRects;\n    }\n\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062EA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n\n    if (!r0 || r0.left == r0.right) {\n      return false;\n    } // Safari returns null in some cases (#2780)\n\n\n    return badBidiRects = r1.right - r0.right < 3;\n  } // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n\n\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0,\n        result = [],\n        l = string.length;\n\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n\n      if (nl == -1) {\n        nl = string.length;\n      }\n\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n\n    return result;\n  } : function (string) {\n    return string.split(/\\r\\n?|\\n/);\n  };\n  var hasSelection = window.getSelection ? function (te) {\n    try {\n      return te.selectionStart != te.selectionEnd;\n    } catch (e) {\n      return false;\n    }\n  } : function (te) {\n    var range$$1;\n\n    try {\n      range$$1 = te.ownerDocument.selection.createRange();\n    } catch (e) {}\n\n    if (!range$$1 || range$$1.parentElement() != te) {\n      return false;\n    }\n\n    return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0;\n  };\n\n  var hasCopyEvent = function () {\n    var e = elt(\"div\");\n\n    if (\"oncopy\" in e) {\n      return true;\n    }\n\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\";\n  }();\n\n  var badZoomedRects = null;\n\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) {\n      return badZoomedRects;\n    }\n\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n  } // Known modes, by name and by MIME\n\n\n  var modes = {},\n      mimeModes = {}; // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n\n  function defineMode(name, mode) {\n    if (arguments.length > 2) {\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    }\n\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  } // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n\n\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n\n      if (typeof found == \"string\") {\n        found = {\n          name: found\n        };\n      }\n\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\");\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\");\n    }\n\n    if (typeof spec == \"string\") {\n      return {\n        name: spec\n      };\n    } else {\n      return spec || {\n        name: \"null\"\n      };\n    }\n  } // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n\n\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n\n    if (!mfactory) {\n      return getMode(options, \"text/plain\");\n    }\n\n    var modeObj = mfactory(options, spec);\n\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) {\n          continue;\n        }\n\n        if (modeObj.hasOwnProperty(prop)) {\n          modeObj[\"_\" + prop] = modeObj[prop];\n        }\n\n        modeObj[prop] = exts[prop];\n      }\n    }\n\n    modeObj.name = spec.name;\n\n    if (spec.helperType) {\n      modeObj.helperType = spec.helperType;\n    }\n\n    if (spec.modeProps) {\n      for (var prop$1 in spec.modeProps) {\n        modeObj[prop$1] = spec.modeProps[prop$1];\n      }\n    }\n\n    return modeObj;\n  } // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n\n\n  var modeExtensions = {};\n\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) {\n      return state;\n    }\n\n    if (mode.copyState) {\n      return mode.copyState(state);\n    }\n\n    var nstate = {};\n\n    for (var n in state) {\n      var val = state[n];\n\n      if (val instanceof Array) {\n        val = val.concat([]);\n      }\n\n      nstate[n] = val;\n    }\n\n    return nstate;\n  } // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n\n\n  function innerMode(mode, state) {\n    var info;\n\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n\n      if (!info || info.mode == mode) {\n        break;\n      }\n\n      state = info.state;\n      mode = info.mode;\n    }\n\n    return info || {\n      mode: mode,\n      state: state\n    };\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  } // STRING STREAM\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n\n  var StringStream = function StringStream(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {\n    return this.pos >= this.string.length;\n  };\n\n  StringStream.prototype.sol = function () {\n    return this.pos == this.lineStart;\n  };\n\n  StringStream.prototype.peek = function () {\n    return this.string.charAt(this.pos) || undefined;\n  };\n\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length) {\n      return this.string.charAt(this.pos++);\n    }\n  };\n\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n\n    if (typeof match == \"string\") {\n      ok = ch == match;\n    } else {\n      ok = ch && (match.test ? match.test(ch) : match(ch));\n    }\n\n    if (ok) {\n      ++this.pos;\n      return ch;\n    }\n  };\n\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n\n    while (this.eat(match)) {}\n\n    return this.pos > start;\n  };\n\n  StringStream.prototype.eatSpace = function () {\n    var this$1 = this;\n    var start = this.pos;\n\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n      ++this$1.pos;\n    }\n\n    return this.pos > start;\n  };\n\n  StringStream.prototype.skipToEnd = function () {\n    this.pos = this.string.length;\n  };\n\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n\n    if (found > -1) {\n      this.pos = found;\n      return true;\n    }\n  };\n\n  StringStream.prototype.backUp = function (n) {\n    this.pos -= n;\n  };\n\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  };\n\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  };\n\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function cased(str) {\n        return caseInsensitive ? str.toLowerCase() : str;\n      };\n\n      var substr = this.string.substr(this.pos, pattern.length);\n\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) {\n          this.pos += pattern.length;\n        }\n\n        return true;\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n\n      if (match && match.index > 0) {\n        return null;\n      }\n\n      if (match && consume !== false) {\n        this.pos += match[0].length;\n      }\n\n      return match;\n    }\n  };\n\n  StringStream.prototype.current = function () {\n    return this.string.slice(this.start, this.pos);\n  };\n\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n\n    try {\n      return inner();\n    } finally {\n      this.lineStart -= n;\n    }\n  };\n\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n);\n  };\n\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos);\n  }; // Find the line object corresponding to the given line number.\n\n\n  function getLine(doc, n) {\n    n -= doc.first;\n\n    if (n < 0 || n >= doc.size) {\n      throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n    }\n\n    var chunk = doc;\n\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i],\n            sz = child.chunkSize();\n\n        if (n < sz) {\n          chunk = child;\n          break;\n        }\n\n        n -= sz;\n      }\n    }\n\n    return chunk.lines[n];\n  } // Get the part of a document between two positions, as an array of\n  // strings.\n\n\n  function getBetween(doc, start, end) {\n    var out = [],\n        n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n\n      if (n == end.line) {\n        text = text.slice(0, end.ch);\n      }\n\n      if (n == start.line) {\n        text = text.slice(start.ch);\n      }\n\n      out.push(text);\n      ++n;\n    });\n    return out;\n  } // Get the lines between from and to, as array of strings.\n\n\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) {\n      out.push(line.text);\n    }); // iter aborts when callback returns truthy value\n\n    return out;\n  } // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n\n\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n\n    if (diff) {\n      for (var n = line; n; n = n.parent) {\n        n.height += diff;\n      }\n    }\n  } // Given a line object, find its line number by walking up through\n  // its parent links.\n\n\n  function lineNo(line) {\n    if (line.parent == null) {\n      return null;\n    }\n\n    var cur = line.parent,\n        no = indexOf(cur.lines, line);\n\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) {\n          break;\n        }\n\n        no += chunk.children[i].chunkSize();\n      }\n    }\n\n    return no + cur.first;\n  } // Find the line at the given vertical position, using the height\n  // information in the document tree.\n\n\n  function _lineAtHeight(chunk, h) {\n    var n = chunk.first;\n\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1],\n            ch = child.height;\n\n        if (h < ch) {\n          chunk = child;\n          continue outer;\n        }\n\n        h -= ch;\n        n += child.chunkSize();\n      }\n\n      return n;\n    } while (!chunk.lines);\n\n    var i = 0;\n\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i],\n          lh = line.height;\n\n      if (h < lh) {\n        break;\n      }\n\n      h -= lh;\n    }\n\n    return n + i;\n  }\n\n  function isLine(doc, l) {\n    return l >= doc.first && l < doc.first + doc.size;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  } // A Pos instance represents a position within the text.\n\n\n  function Pos(line, ch, sticky) {\n    if (sticky === void 0) sticky = null;\n\n    if (!(this instanceof Pos)) {\n      return new Pos(line, ch, sticky);\n    }\n\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  } // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n\n\n  function cmp(a, b) {\n    return a.line - b.line || a.ch - b.ch;\n  }\n\n  function equalCursorPos(a, b) {\n    return a.sticky == b.sticky && cmp(a, b) == 0;\n  }\n\n  function copyPos(x) {\n    return Pos(x.line, x.ch);\n  }\n\n  function maxPos(a, b) {\n    return cmp(a, b) < 0 ? b : a;\n  }\n\n  function minPos(a, b) {\n    return cmp(a, b) < 0 ? a : b;\n  } // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n\n\n  function clipLine(doc, n) {\n    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));\n  }\n\n  function _clipPos(doc, pos) {\n    if (pos.line < doc.first) {\n      return Pos(doc.first, 0);\n    }\n\n    var last = doc.first + doc.size - 1;\n\n    if (pos.line > last) {\n      return Pos(last, getLine(doc, last).text.length);\n    }\n\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n\n    if (ch == null || ch > linelen) {\n      return Pos(pos.line, linelen);\n    } else if (ch < 0) {\n      return Pos(pos.line, 0);\n    } else {\n      return pos;\n    }\n  }\n\n  function clipPosArray(doc, array) {\n    var out = [];\n\n    for (var i = 0; i < array.length; i++) {\n      out[i] = _clipPos(doc, array[i]);\n    }\n\n    return out;\n  }\n\n  var SavedContext = function SavedContext(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function Context(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n\n    if (line != null && n > this.maxLookAhead) {\n      this.maxLookAhead = n;\n    }\n\n    return line;\n  };\n\n  Context.prototype.baseToken = function (n) {\n    var this$1 = this;\n\n    if (!this.baseTokens) {\n      return null;\n    }\n\n    while (this.baseTokens[this.baseTokenPos] <= n) {\n      this$1.baseTokenPos += 2;\n    }\n\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {\n      type: type && type.replace(/( |^)overlay .*/, \"\"),\n      size: this.baseTokens[this.baseTokenPos] - n\n    };\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n\n    if (this.maxLookAhead > 0) {\n      this.maxLookAhead--;\n    }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext) {\n      return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);\n    } else {\n      return new Context(doc, copyState(doc.mode, saved), line);\n    }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;\n  }; // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n\n\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen],\n        lineClasses = {}; // Compute the base array of styles\n\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) {\n      return st.push(end, style);\n    }, lineClasses, forceToEnd);\n    var state = context.state; // Run overlays, adjust style array.\n\n    var loop = function loop(o) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o],\n          i = 1,\n          at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i; // Ensure there's a token end at the current position, and that i points at it\n\n        while (at < end) {\n          var i_end = st[i];\n\n          if (i_end > end) {\n            st.splice(i, 1, end, st[i + 1], i_end);\n          }\n\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n\n        if (!style) {\n          return;\n        }\n\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start + 1];\n            st[start + 1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      loop(o);\n    }\n\n    return {\n      styles: st,\n      classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null\n    };\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n\n      if (resetState) {\n        context.state = resetState;\n      }\n\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n\n      if (result.classes) {\n        line.styleClasses = result.classes;\n      } else if (line.styleClasses) {\n        line.styleClasses = null;\n      }\n\n      if (updateFrontier === cm.doc.highlightFrontier) {\n        cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);\n      }\n    }\n\n    return line.styles;\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc,\n        display = cm.display;\n\n    if (!doc.mode.startState) {\n      return new Context(doc, true, n);\n    }\n\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n\n    if (precise) {\n      doc.modeFrontier = context.line;\n    }\n\n    return context;\n  } // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n\n\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n\n    if (text == \"\") {\n      callBlankLine(mode, context.state);\n    }\n\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) {\n      return mode.blankLine(state);\n    }\n\n    if (!mode.innerMode) {\n      return;\n    }\n\n    var inner = innerMode(mode, state);\n\n    if (inner.mode.blankLine) {\n      return inner.mode.blankLine(inner.state);\n    }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) {\n        inner[0] = innerMode(mode, state).mode;\n      }\n\n      var style = mode.token(stream, state);\n\n      if (stream.pos > stream.start) {\n        return style;\n      }\n    }\n\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n  }\n\n  var Token = function Token(stream, type, state) {\n    this.start = stream.start;\n    this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  }; // Utility for getTokenAt and getLineTokens\n\n\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc,\n        mode = doc.mode,\n        style;\n    pos = _clipPos(doc, pos);\n    var line = getLine(doc, pos.line),\n        context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context),\n        tokens;\n\n    if (asArray) {\n      tokens = [];\n    }\n\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n\n      if (asArray) {\n        tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));\n      }\n    }\n\n    return asArray ? tokens : new Token(stream, style, context.state);\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) {\n      for (;;) {\n        var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n\n        if (!lineClass) {\n          break;\n        }\n\n        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n        var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n\n        if (output[prop] == null) {\n          output[prop] = lineClass[2];\n        } else if (!new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\").test(output[prop])) {\n          output[prop] += \" \" + lineClass[2];\n        }\n      }\n    }\n\n    return type;\n  } // Run the given mode's parser over a line, calling f for each token.\n\n\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n\n    if (flattenSpans == null) {\n      flattenSpans = cm.options.flattenSpans;\n    }\n\n    var curStart = 0,\n        curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context),\n        style;\n    var inner = cm.options.addModeClass && [null];\n\n    if (text == \"\") {\n      extractLineClasses(callBlankLine(mode, context.state), lineClasses);\n    }\n\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n\n        if (forceToEnd) {\n          processLine(cm, text, context, stream.pos);\n        }\n\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n\n      if (inner) {\n        var mName = inner[0].name;\n\n        if (mName) {\n          style = \"m-\" + (style ? mName + \" \" + style : mName);\n        }\n      }\n\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n\n        curStyle = style;\n      }\n\n      stream.start = stream.pos;\n    }\n\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  } // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n\n\n  function findStartLine(cm, n, precise) {\n    var minindent,\n        minline,\n        doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) {\n        return doc.first;\n      }\n\n      var line = getLine(doc, search - 1),\n          after = line.stateAfter;\n\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {\n        return search;\n      }\n\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n\n    return minline;\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n\n    if (doc.highlightFrontier < n - 10) {\n      return;\n    }\n\n    var start = doc.first;\n\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter; // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break;\n      }\n    }\n\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  } // Optimize some code when these features are not used.\n\n\n  var sawReadOnlySpans = false,\n      sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  } // TEXTMARKER SPANS\n\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from;\n    this.to = to;\n  } // Search an array of spans for a span matching the given marker.\n\n\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) {\n      for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n\n        if (span.marker == marker) {\n          return span;\n        }\n      }\n    }\n  } // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n\n\n  function removeMarkedSpan(spans, span) {\n    var r;\n\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i] != span) {\n        (r || (r = [])).push(spans[i]);\n      }\n    }\n\n    return r;\n  } // Add a span to a line.\n\n\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  } // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n\n\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n\n    if (old) {\n      for (var i = 0; i < old.length; ++i) {\n        var span = old[i],\n            marker = span.marker;\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n\n        if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n          (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n        }\n      }\n    }\n\n    return nw;\n  }\n\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n\n    if (old) {\n      for (var i = 0; i < old.length; ++i) {\n        var span = old[i],\n            marker = span.marker;\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n\n        if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n          (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));\n        }\n      }\n    }\n\n    return nw;\n  } // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n\n\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) {\n      return null;\n    }\n\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n\n    if (!oldFirst && !oldLast) {\n      return null;\n    }\n\n    var startCh = change.from.ch,\n        endCh = change.to.ch,\n        isInsert = cmp(change.from, change.to) == 0; // Get the spans that 'stick out' on both sides\n\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert); // Next, merge those two ends\n\n    var sameLine = change.text.length == 1,\n        offset = lst(change.text).length + (sameLine ? startCh : 0);\n\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n\n          if (!found) {\n            span.to = startCh;\n          } else if (sameLine) {\n            span.to = found.to == null ? null : found.to + offset;\n          }\n        }\n      }\n    }\n\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n\n        if (span$1.to != null) {\n          span$1.to += offset;\n        }\n\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n\n          if (!found$1) {\n            span$1.from = offset;\n\n            if (sameLine) {\n              (first || (first = [])).push(span$1);\n            }\n          }\n        } else {\n          span$1.from += offset;\n\n          if (sameLine) {\n            (first || (first = [])).push(span$1);\n          }\n        }\n      }\n    } // Make sure we didn't create any zero-length spans\n\n\n    if (first) {\n      first = clearEmptySpans(first);\n    }\n\n    if (last && last != first) {\n      last = clearEmptySpans(last);\n    }\n\n    var newMarkers = [first];\n\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2,\n          gapMarkers;\n\n      if (gap > 0 && first) {\n        for (var i$2 = 0; i$2 < first.length; ++i$2) {\n          if (first[i$2].to == null) {\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));\n          }\n        }\n      }\n\n      for (var i$3 = 0; i$3 < gap; ++i$3) {\n        newMarkers.push(gapMarkers);\n      }\n\n      newMarkers.push(last);\n    }\n\n    return newMarkers;\n  } // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n\n\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {\n        spans.splice(i--, 1);\n      }\n    }\n\n    if (!spans.length) {\n      return null;\n    }\n\n    return spans;\n  } // Used to 'clip' out readOnly ranges when making a change.\n\n\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var mark = line.markedSpans[i].marker;\n\n          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {\n            (markers || (markers = [])).push(mark);\n          }\n        }\n      }\n    });\n\n    if (!markers) {\n      return null;\n    }\n\n    var parts = [{\n      from: from,\n      to: to\n    }];\n\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i],\n          m = mk.find(0);\n\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {\n          continue;\n        }\n\n        var newParts = [j, 1],\n            dfrom = cmp(p.from, m.from),\n            dto = cmp(p.to, m.to);\n\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {\n          newParts.push({\n            from: p.from,\n            to: m.from\n          });\n        }\n\n        if (dto > 0 || !mk.inclusiveRight && !dto) {\n          newParts.push({\n            from: m.to,\n            to: p.to\n          });\n        }\n\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n\n    return parts;\n  } // Connect or disconnect spans from a line.\n\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n\n    if (!spans) {\n      return;\n    }\n\n    for (var i = 0; i < spans.length; ++i) {\n      spans[i].marker.detachLine(line);\n    }\n\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) {\n      return;\n    }\n\n    for (var i = 0; i < spans.length; ++i) {\n      spans[i].marker.attachLine(line);\n    }\n\n    line.markedSpans = spans;\n  } // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n\n\n  function extraLeft(marker) {\n    return marker.inclusiveLeft ? -1 : 0;\n  }\n\n  function extraRight(marker) {\n    return marker.inclusiveRight ? 1 : 0;\n  } // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n\n\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n\n    if (lenDiff != 0) {\n      return lenDiff;\n    }\n\n    var aPos = a.find(),\n        bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n\n    if (fromCmp) {\n      return -fromCmp;\n    }\n\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n\n    if (toCmp) {\n      return toCmp;\n    }\n\n    return b.id - a.id;\n  } // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n\n\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans,\n        found;\n\n    if (sps) {\n      for (var sp = void 0, i = 0; i < sps.length; ++i) {\n        sp = sps[i];\n\n        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n          found = sp.marker;\n        }\n      }\n    }\n\n    return found;\n  }\n\n  function collapsedSpanAtStart(line) {\n    return collapsedSpanAtSide(line, true);\n  }\n\n  function collapsedSpanAtEnd(line) {\n    return collapsedSpanAtSide(line, false);\n  }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans,\n        found;\n\n    if (sps) {\n      for (var i = 0; i < sps.length; ++i) {\n        var sp = sps[i];\n\n        if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n          found = sp.marker;\n        }\n      }\n    }\n\n    return found;\n  } // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n\n\n  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n    var line = getLine(doc, lineNo$$1);\n    var sps = sawCollapsedSpans && line.markedSpans;\n\n    if (sps) {\n      for (var i = 0; i < sps.length; ++i) {\n        var sp = sps[i];\n\n        if (!sp.marker.collapsed) {\n          continue;\n        }\n\n        var found = sp.marker.find(0);\n        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n\n        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {\n          continue;\n        }\n\n        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {\n          return true;\n        }\n      }\n    }\n  } // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n\n\n  function visualLine(line) {\n    var merged;\n\n    while (merged = collapsedSpanAtStart(line)) {\n      line = merged.find(-1, true).line;\n    }\n\n    return line;\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n    }\n\n    return line;\n  } // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n\n\n  function visualLineContinued(line) {\n    var merged, lines;\n\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      (lines || (lines = [])).push(line);\n    }\n\n    return lines;\n  } // Get the line number of the start of the visual line that the\n  // given line number is part of.\n\n\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN),\n        vis = visualLine(line);\n\n    if (line == vis) {\n      return lineN;\n    }\n\n    return lineNo(vis);\n  } // Get the line number of the start of the next visual line after\n  // the given line.\n\n\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) {\n      return lineN;\n    }\n\n    var line = getLine(doc, lineN),\n        merged;\n\n    if (!lineIsHidden(doc, line)) {\n      return lineN;\n    }\n\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n    }\n\n    return lineNo(line) + 1;\n  } // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n\n\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n\n    if (sps) {\n      for (var sp = void 0, i = 0; i < sps.length; ++i) {\n        sp = sps[i];\n\n        if (!sp.marker.collapsed) {\n          continue;\n        }\n\n        if (sp.from == null) {\n          return true;\n        }\n\n        if (sp.marker.widgetNode) {\n          continue;\n        }\n\n        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n    }\n\n    if (span.marker.inclusiveRight && span.to == line.text.length) {\n      return true;\n    }\n\n    for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {\n        return true;\n      }\n    }\n  } // Find the height above the given line.\n\n\n  function _heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n    var h = 0,\n        chunk = lineObj.parent;\n\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n\n      if (line == lineObj) {\n        break;\n      } else {\n        h += line.height;\n      }\n    }\n\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n\n        if (cur == chunk) {\n          break;\n        } else {\n          h += cur.height;\n        }\n      }\n    }\n\n    return h;\n  } // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n\n\n  function lineLength(line) {\n    if (line.height == 0) {\n      return 0;\n    }\n\n    var len = line.text.length,\n        merged,\n        cur = line;\n\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n\n    cur = line;\n\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n\n    return len;\n  } // Find the longest line in the document.\n\n\n  function findMaxLine(cm) {\n    var d = cm.display,\n        doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  } // LINE DATA STRUCTURE\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n\n\n  var Line = function Line(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () {\n    return lineNo(this);\n  };\n\n  eventMixin(Line); // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n\n    if (line.stateAfter) {\n      line.stateAfter = null;\n    }\n\n    if (line.styles) {\n      line.styles = null;\n    }\n\n    if (line.order != null) {\n      line.order = null;\n    }\n\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n\n    if (estHeight != line.height) {\n      updateLineHeight(line, estHeight);\n    }\n  } // Detach a line from the document tree and its markers.\n\n\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  } // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n\n\n  var styleToClassCache = {},\n      styleToClassCacheWithMode = {};\n\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) {\n      return null;\n    }\n\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] || (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  } // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n\n\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {\n      pre: eltP(\"pre\", [content], \"CodeMirror-line\"),\n      content: content,\n      col: 0,\n      pos: 0,\n      cm: cm,\n      trailingSpace: false,\n      splitSpaces: cm.getOption(\"lineWrapping\")\n    };\n    lineView.measure = {}; // Iterate over the logical lines that make up this visual line.\n\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line,\n          order = void 0;\n      builder.pos = 0;\n      builder.addToken = buildToken; // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      }\n\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass) {\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        }\n\n        if (line.styleClasses.textClass) {\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n        }\n      } // Ensure at least a single node is present, for measuring.\n\n\n      if (builder.map.length == 0) {\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n      } // Store the map and a cache object for the current logical line\n\n\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    } // See issue #2901\n\n\n    if (webkit) {\n      var last = builder.content.lastChild;\n\n      if (/\\bcm-tab\\b/.test(last.className) || last.querySelector && last.querySelector(\".cm-tab\")) {\n        builder.content.className = \"cm-tab-wrap-hack\";\n      }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n\n    if (builder.pre.className) {\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n    }\n\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token;\n  } // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n\n\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) {\n      return;\n    }\n\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars,\n        mustWrap = false;\n    var content;\n\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n\n      if (ie && ie_version < 9) {\n        mustWrap = true;\n      }\n\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n\n          if (ie && ie_version < 9) {\n            content.appendChild(elt(\"span\", [txt]));\n          } else {\n            content.appendChild(txt);\n          }\n\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n\n        if (!m) {\n          break;\n        }\n\n        pos += skipped + 1;\n        var txt$1 = void 0;\n\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize,\n              tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240D\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n\n          if (ie && ie_version < 9) {\n            content.appendChild(elt(\"span\", [txt$1]));\n          } else {\n            content.appendChild(txt$1);\n          }\n\n          builder.col += 1;\n        }\n\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n\n      if (startStyle) {\n        fullStyle += startStyle;\n      }\n\n      if (endStyle) {\n        fullStyle += endStyle;\n      }\n\n      var token = elt(\"span\", [content], fullStyle, css);\n\n      if (attributes) {\n        for (var attr in attributes) {\n          if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\") {\n            token.setAttribute(attr, attributes[attr]);\n          }\n        }\n      }\n\n      return builder.content.appendChild(token);\n    }\n\n    builder.content.appendChild(content);\n  } // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n\n\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) {\n      return text;\n    }\n\n    var spaceBefore = trailingBefore,\n        result = \"\";\n\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {\n        ch = \"\\xA0\";\n      }\n\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n\n    return result;\n  } // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n\n\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos,\n          end = start + text.length;\n\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = void 0;\n\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n\n          if (part.to > start && part.from <= start) {\n            break;\n          }\n        }\n\n        if (part.to >= end) {\n          return inner(builder, text, style, startStyle, endStyle, css, attributes);\n        }\n\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n\n    if (widget) {\n      builder.map.push(builder.pos, builder.pos + size, widget);\n    }\n\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget) {\n        widget = builder.content.appendChild(document.createElement(\"span\"));\n      }\n\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n\n    builder.pos += size;\n    builder.trailingSpace = false;\n  } // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n\n\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans,\n        allText = line.text,\n        at = 0;\n\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {\n        builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));\n      }\n\n      return;\n    }\n\n    var len = allText.length,\n        pos = 0,\n        i = 1,\n        text = \"\",\n        style,\n        css;\n    var nextChange = 0,\n        spanStyle,\n        spanEndStyle,\n        spanStartStyle,\n        collapsed,\n        attributes;\n\n    for (;;) {\n      if (nextChange == pos) {\n        // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null;\n        nextChange = Infinity;\n        var foundBookmarks = [],\n            endStyles = void 0;\n\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j],\n              m = sp.marker;\n\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n\n            if (m.className) {\n              spanStyle += \" \" + m.className;\n            }\n\n            if (m.css) {\n              css = (css ? css + \";\" : \"\") + m.css;\n            }\n\n            if (m.startStyle && sp.from == pos) {\n              spanStartStyle += \" \" + m.startStyle;\n            }\n\n            if (m.endStyle && sp.to == nextChange) {\n              (endStyles || (endStyles = [])).push(m.endStyle, sp.to);\n            } // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n\n\n            if (m.title) {\n              (attributes || (attributes = {})).title = m.title;\n            }\n\n            if (m.attributes) {\n              for (var attr in m.attributes) {\n                (attributes || (attributes = {}))[attr] = m.attributes[attr];\n              }\n            }\n\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {\n              collapsed = sp;\n            }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n\n        if (endStyles) {\n          for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {\n            if (endStyles[j$1 + 1] == nextChange) {\n              spanEndStyle += \" \" + endStyles[j$1];\n            }\n          }\n        }\n\n        if (!collapsed || collapsed.from == pos) {\n          for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {\n            buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);\n          }\n        }\n\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);\n\n          if (collapsed.to == null) {\n            return;\n          }\n\n          if (collapsed.to == pos) {\n            collapsed = false;\n          }\n        }\n      }\n\n      if (pos >= len) {\n        break;\n      }\n\n      var upto = Math.min(len, nextChange);\n\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n\n          if (end >= upto) {\n            text = text.slice(upto - pos);\n            pos = upto;\n            break;\n          }\n\n          pos = end;\n          spanStartStyle = \"\";\n        }\n\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  } // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n\n\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line; // Continuing lines, if any\n\n    this.rest = visualLineContinued(line); // Number of logical lines in this visual line\n\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  } // Create a range of LineView objects for the given lines.\n\n\n  function buildViewArray(cm, from, to) {\n    var array = [],\n        nextPos;\n\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n\n    return array;\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks,\n        i = 0;\n\n    do {\n      for (; i < callbacks.length; i++) {\n        callbacks[i].call(null);\n      }\n\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n\n        if (op.cursorActivityHandlers) {\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {\n            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n          }\n        }\n      }\n    } while (i < callbacks.length);\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n\n    if (!group) {\n      return;\n    }\n\n    try {\n      fireCallbacksForOps(group);\n    } finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null; // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n\n  function signalLater(emitter, type\n  /*, values...*/\n  ) {\n    var arr = getHandlers(emitter, type);\n\n    if (!arr.length) {\n      return;\n    }\n\n    var args = Array.prototype.slice.call(arguments, 2),\n        list;\n\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n\n    var loop = function loop(i) {\n      list.push(function () {\n        return arr[i].apply(null, args);\n      });\n    };\n\n    for (var i = 0; i < arr.length; ++i) {\n      loop(i);\n    }\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n\n    for (var i = 0; i < delayed.length; ++i) {\n      delayed[i]();\n    }\n  } // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n\n\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n\n      if (type == \"text\") {\n        updateLineText(cm, lineView);\n      } else if (type == \"gutter\") {\n        updateLineGutter(cm, lineView, lineN, dims);\n      } else if (type == \"class\") {\n        updateLineClasses(cm, lineView);\n      } else if (type == \"widget\") {\n        updateLineWidgets(cm, lineView, dims);\n      }\n    }\n\n    lineView.changes = null;\n  } // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n\n\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n\n      if (lineView.text.parentNode) {\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n      }\n\n      lineView.node.appendChild(lineView.text);\n\n      if (ie && ie_version < 8) {\n        lineView.node.style.zIndex = 2;\n      }\n    }\n\n    return lineView.node;\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n\n    if (cls) {\n      cls += \" CodeMirror-linebackground\";\n    }\n\n    if (lineView.background) {\n      if (cls) {\n        lineView.background.className = cls;\n      } else {\n        lineView.background.parentNode.removeChild(lineView.background);\n        lineView.background = null;\n      }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  } // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n\n\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built;\n    }\n\n    return buildLineContent(cm, lineView);\n  } // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n\n\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n\n    if (lineView.text == lineView.node) {\n      lineView.node = built.pre;\n    }\n\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n\n    if (lineView.line.wrapClass) {\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n    } else if (lineView.node != lineView.text) {\n      lineView.node.className = \"\";\n    }\n\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass, \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + dims.gutterTotalWidth + \"px\");\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n\n    var markers = lineView.line.gutterMarkers;\n\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n\n      if (lineView.line.gutterClass) {\n        gutterWrap.className += \" \" + lineView.line.gutterClass;\n      }\n\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"])) {\n        lineView.lineNumber = gutterWrap.appendChild(elt(\"div\", lineNumberFor(cm.options, lineN), \"CodeMirror-linenumber CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \" + cm.display.lineNumInnerWidth + \"px\"));\n      }\n\n      if (markers) {\n        for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n          var id = cm.display.gutterSpecs[k].className,\n              found = markers.hasOwnProperty(id) && markers[id];\n\n          if (found) {\n            gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n          }\n        }\n      }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) {\n      lineView.alignable = null;\n    }\n\n    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {\n      next = node.nextSibling;\n\n      if (node.className == \"CodeMirror-linewidget\") {\n        lineView.node.removeChild(node);\n      }\n    }\n\n    insertLineWidgets(cm, lineView, dims);\n  } // Build a line's DOM representation from scratch\n\n\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n\n    if (built.bgClass) {\n      lineView.bgClass = built.bgClass;\n    }\n\n    if (built.textClass) {\n      lineView.textClass = built.textClass;\n    }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node;\n  } // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n\n\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n\n    if (lineView.rest) {\n      for (var i = 0; i < lineView.rest.length; i++) {\n        insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n      }\n    }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) {\n      return;\n    }\n\n    var wrap = ensureLineWrapped(lineView);\n\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i],\n          node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n\n      if (!widget.handleMouseEvents) {\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n      }\n\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n\n      if (allowAbove && widget.above) {\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\n      } else {\n        wrap.appendChild(node);\n      }\n\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n      (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n\n      node.style.width = width + \"px\";\n    }\n\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n\n      if (!widget.noHScroll) {\n        node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n      }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) {\n      return widget.height;\n    }\n\n    var cm = widget.doc.cm;\n\n    if (!cm) {\n      return 0;\n    }\n\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n\n      if (widget.coverGutter) {\n        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n      }\n\n      if (widget.noHScroll) {\n        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n      }\n\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n\n    return widget.height = widget.node.parentNode.offsetHeight;\n  } // Return true when the given mouse event happened in a widget\n\n\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\" || n.parentNode == display.sizer && n != display.mover) {\n        return true;\n      }\n    }\n  } // POSITION MEASUREMENT\n\n\n  function paddingTop(display) {\n    return display.lineSpace.offsetTop;\n  }\n\n  function paddingVert(display) {\n    return display.mover.offsetHeight - display.lineSpace.offsetHeight;\n  }\n\n  function paddingH(display) {\n    if (display.cachedPaddingH) {\n      return display.cachedPaddingH;\n    }\n\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {\n      left: parseInt(style.paddingLeft),\n      right: parseInt(style.paddingRight)\n    };\n\n    if (!isNaN(data.left) && !isNaN(data.right)) {\n      display.cachedPaddingH = data;\n    }\n\n    return data;\n  }\n\n  function scrollGap(cm) {\n    return scrollerGap - cm.display.nativeBarWidth;\n  }\n\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n  }\n\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n  } // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n\n\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i],\n              next = rects[i + 1];\n\n          if (Math.abs(cur.bottom - next.bottom) > 2) {\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\n          }\n        }\n      }\n\n      heights.push(rect.bottom - rect.top);\n    }\n  } // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n\n\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line) {\n      return {\n        map: lineView.measure.map,\n        cache: lineView.measure.cache\n      };\n    }\n\n    for (var i = 0; i < lineView.rest.length; i++) {\n      if (lineView.rest[i] == line) {\n        return {\n          map: lineView.measure.maps[i],\n          cache: lineView.measure.caches[i]\n        };\n      }\n    }\n\n    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {\n      if (lineNo(lineView.rest[i$1]) > lineN) {\n        return {\n          map: lineView.measure.maps[i$1],\n          cache: lineView.measure.caches[i$1],\n          before: true\n        };\n      }\n    }\n  } // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n\n\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view;\n  } // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n\n\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n  } // Find a line view that corresponds to the given line number.\n\n\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {\n      return cm.display.view[findViewIndex(cm, lineN)];\n    }\n\n    var ext = cm.display.externalMeasured;\n\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {\n      return ext;\n    }\n  } // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n\n\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n\n    if (!view) {\n      view = updateExternalMeasurement(cm, line);\n    }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line,\n      view: view,\n      rect: null,\n      map: info.map,\n      cache: info.cache,\n      before: info.before,\n      hasHeights: false\n    };\n  } // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n\n\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) {\n      ch = -1;\n    }\n\n    var key = ch + (bias || \"\"),\n        found;\n\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect) {\n        prepared.rect = prepared.view.text.getBoundingClientRect();\n      }\n\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n\n      found = measureCharInner(cm, prepared, ch, bias);\n\n      if (!found.bogus) {\n        prepared.cache[key] = found;\n      }\n    }\n\n    return {\n      left: found.left,\n      right: found.right,\n      top: varHeight ? found.rtop : found.top,\n      bottom: varHeight ? found.rbottom : found.bottom\n    };\n  }\n\n  var nullRect = {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n\n  function nodeAndOffsetInLineMap(map$$1, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd; // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n\n    for (var i = 0; i < map$$1.length; i += 3) {\n      mStart = map$$1[i];\n      mEnd = map$$1[i + 1];\n\n      if (ch < mStart) {\n        start = 0;\n        end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n\n        if (ch >= mEnd) {\n          collapse = \"right\";\n        }\n      }\n\n      if (start != null) {\n        node = map$$1[i + 2];\n\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\")) {\n          collapse = bias;\n        }\n\n        if (bias == \"left\" && start == 0) {\n          while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n            node = map$$1[(i -= 3) + 2];\n            collapse = \"left\";\n          }\n        }\n\n        if (bias == \"right\" && start == mEnd - mStart) {\n          while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n            node = map$$1[(i += 3) + 2];\n            collapse = \"right\";\n          }\n        }\n\n        break;\n      }\n    }\n\n    return {\n      node: node,\n      start: start,\n      end: end,\n      collapse: collapse,\n      coverStart: mStart,\n      coverEnd: mEnd\n    };\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n\n    if (bias == \"left\") {\n      for (var i = 0; i < rects.length; i++) {\n        if ((rect = rects[i]).left != rect.right) {\n          break;\n        }\n      }\n    } else {\n      for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n        if ((rect = rects[i$1]).left != rect.right) {\n          break;\n        }\n      }\n    }\n\n    return rect;\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node,\n        start = place.start,\n        end = place.end,\n        collapse = place.collapse;\n    var rect;\n\n    if (node.nodeType == 3) {\n      // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) {\n        // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {\n          --start;\n        }\n\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {\n          ++end;\n        }\n\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n          rect = node.parentNode.getBoundingClientRect();\n        } else {\n          rect = getUsefulRect(range(node, start, end).getClientRects(), bias);\n        }\n\n        if (rect.left || rect.right || start == 0) {\n          break;\n        }\n\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n\n      if (ie && ie_version < 11) {\n        rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n      }\n    } else {\n      // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) {\n        collapse = bias = \"right\";\n      }\n\n      var rects;\n\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n      } else {\n        rect = node.getBoundingClientRect();\n      }\n    }\n\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n\n      if (rSpan) {\n        rect = {\n          left: rSpan.left,\n          right: rSpan.left + charWidth(cm.display),\n          top: rSpan.top,\n          bottom: rSpan.bottom\n        };\n      } else {\n        rect = nullRect;\n      }\n    }\n\n    var rtop = rect.top - prepared.rect.top,\n        rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n\n    for (; i < heights.length - 1; i++) {\n      if (mid < heights[i]) {\n        break;\n      }\n    }\n\n    var top = i ? heights[i - 1] : 0,\n        bot = heights[i];\n    var result = {\n      left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n      right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n      top: top,\n      bottom: bot\n    };\n\n    if (!rect.left && !rect.right) {\n      result.bogus = true;\n    }\n\n    if (!cm.options.singleCursorHeightPerLine) {\n      result.rtop = rtop;\n      result.rbottom = rbot;\n    }\n\n    return result;\n  } // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n\n\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {\n      return rect;\n    }\n\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {\n      left: rect.left * scaleX,\n      right: rect.right * scaleX,\n      top: rect.top * scaleY,\n      bottom: rect.bottom * scaleY\n    };\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n\n      if (lineView.rest) {\n        for (var i = 0; i < lineView.rest.length; i++) {\n          lineView.measure.caches[i] = {};\n        }\n      }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n\n    for (var i = 0; i < cm.display.view.length; i++) {\n      clearLineMeasurementCacheFor(cm.display.view[i]);\n    }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n\n    if (!cm.options.lineWrapping) {\n      cm.display.maxLineChanged = true;\n    }\n\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) {\n      return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));\n    }\n\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;\n  }\n\n  function pageScrollY() {\n    if (chrome && android) {\n      return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));\n    }\n\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop;\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n\n    if (lineObj.widgets) {\n      for (var i = 0; i < lineObj.widgets.length; ++i) {\n        if (lineObj.widgets[i].above) {\n          height += widgetHeight(lineObj.widgets[i]);\n        }\n      }\n    }\n\n    return height;\n  } // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n\n\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height;\n      rect.bottom += height;\n    }\n\n    if (context == \"line\") {\n      return rect;\n    }\n\n    if (!context) {\n      context = \"local\";\n    }\n\n    var yOff = _heightAtLine(lineObj);\n\n    if (context == \"local\") {\n      yOff += paddingTop(cm.display);\n    } else {\n      yOff -= cm.display.viewOffset;\n    }\n\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff;\n      rect.right += xOff;\n    }\n\n    rect.top += yOff;\n    rect.bottom += yOff;\n    return rect;\n  } // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n\n\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") {\n      return coords;\n    }\n\n    var left = coords.left,\n        top = coords.top; // First move into \"page\" coordinate system\n\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {\n      left: left - lineSpaceBox.left,\n      top: top - lineSpaceBox.top\n    };\n  }\n\n  function _charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) {\n      lineObj = getLine(cm.doc, pos.line);\n    }\n\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n  } // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n\n\n  function _cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n\n    if (!preparedMeasure) {\n      preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    }\n\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n\n      if (right) {\n        m.left = m.right;\n      } else {\n        m.right = m.left;\n      }\n\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n\n    var order = getOrder(lineObj, cm.doc.direction),\n        ch = pos.ch,\n        sticky = pos.sticky;\n\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n\n    if (!order) {\n      return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\");\n    }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos],\n          right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert);\n    }\n\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n\n    if (other != null) {\n      val.other = getBidi(ch, other, sticky != \"before\");\n    }\n\n    return val;\n  } // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n\n\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = _clipPos(cm.doc, pos);\n\n    if (!cm.options.lineWrapping) {\n      left = charWidth(cm.display) * pos.ch;\n    }\n\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = _heightAtLine(lineObj) + paddingTop(cm.display);\n    return {\n      left: left,\n      right: left,\n      top: top,\n      bottom: top + lineObj.height\n    };\n  } // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n\n\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n\n    if (outside) {\n      pos.outside = true;\n    }\n\n    return pos;\n  } // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n\n\n  function _coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n\n    if (y < 0) {\n      return PosWithInfo(doc.first, 0, null, true, -1);\n    }\n\n    var lineN = _lineAtHeight(doc, y),\n        last = doc.first + doc.size - 1;\n\n    if (lineN > last) {\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1);\n    }\n\n    if (x < 0) {\n      x = 0;\n    }\n\n    var lineObj = getLine(doc, lineN);\n\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));\n\n      if (!collapsed) {\n        return found;\n      }\n\n      var rangeEnd = collapsed.find(1);\n\n      if (rangeEnd.line == lineN) {\n        return rangeEnd;\n      }\n\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) {\n      return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;\n    }, end, 0);\n    end = findFirst(function (ch) {\n      return measureCharPrepared(cm, preparedMeasure, ch).top > y;\n    }, begin, end);\n    return {\n      begin: begin,\n      end: end\n    };\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) {\n      preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    }\n\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);\n  } // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n\n\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n    // Move y into line-local coordinate space\n    y -= _heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj); // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n\n    var widgetHeight$$1 = widgetTopHeight(lineObj);\n    var begin = 0,\n        end = lineObj.text.length,\n        ltr = true;\n    var order = getOrder(lineObj, cm.doc.direction); // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\n      ltr = part.level != 1; // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    } // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n\n\n    var chAround = null,\n        boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight$$1;\n      box.bottom += widgetHeight$$1;\n\n      if (!boxIsAfter(box, x, y, false)) {\n        return false;\n      }\n\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n\n      return true;\n    }, begin, end);\n    var baseX,\n        sticky,\n        outside = false; // If a box around the coordinates was found, use that\n\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x,\n          atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) {\n        ch++;\n      } // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n\n\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y == ltr ? \"after\" : \"before\"; // Now get accurate coordinates for this place, in order to get a\n      // base X position\n\n      var coords = _cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \"line\", lineObj, preparedMeasure);\n\n      baseX = coords.left;\n      outside = y < coords.top || y >= coords.bottom;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX);\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i],\n          ltr = part.level != 1;\n      return boxIsAfter(_cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"), \"line\", lineObj, preparedMeasure), x, y, true);\n    }, 0, order.length - 1);\n    var part = order[index]; // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n\n    if (index > 0) {\n      var ltr = part.level != 1;\n\n      var start = _cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"), \"line\", lineObj, preparedMeasure);\n\n      if (boxIsAfter(start, x, y, true) && start.top > y) {\n        part = order[index - 1];\n      }\n    }\n\n    return part;\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) {\n      end--;\n    }\n\n    var part = null,\n        closestDist = null;\n\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n\n      if (p.from >= end || p.to <= begin) {\n        continue;\n      }\n\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right; // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n\n    if (!part) {\n      part = order[order.length - 1];\n    } // Clip the part to the wrapped line.\n\n\n    if (part.from < begin) {\n      part = {\n        from: begin,\n        to: part.to,\n        level: part.level\n      };\n    }\n\n    if (part.to > end) {\n      part = {\n        from: part.from,\n        to: end,\n        level: part.level\n      };\n    }\n\n    return part;\n  }\n\n  var measureText; // Compute the default text height.\n\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) {\n      return display.cachedTextHeight;\n    }\n\n    if (measureText == null) {\n      measureText = elt(\"pre\"); // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n\n    if (height > 3) {\n      display.cachedTextHeight = height;\n    }\n\n    removeChildren(display.measure);\n    return height || 1;\n  } // Compute the default character width.\n\n\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) {\n      return display.cachedCharWidth;\n    }\n\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(),\n        width = (rect.right - rect.left) / 10;\n\n    if (width > 2) {\n      display.cachedCharWidth = width;\n    }\n\n    return width || 10;\n  } // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n\n\n  function getDimensions(cm) {\n    var d = cm.display,\n        left = {},\n        width = {};\n    var gutterLeft = d.gutters.clientLeft;\n\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n\n    return {\n      fixedPos: compensateForHScroll(d),\n      gutterTotalWidth: d.gutters.offsetWidth,\n      gutterLeft: left,\n      gutterWidth: width,\n      wrapperWidth: d.wrapper.clientWidth\n    };\n  } // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n\n\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  } // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n\n\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display),\n        wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) {\n        return 0;\n      }\n\n      var widgetsHeight = 0;\n\n      if (line.widgets) {\n        for (var i = 0; i < line.widgets.length; i++) {\n          if (line.widgets[i].height) {\n            widgetsHeight += line.widgets[i].height;\n          }\n        }\n      }\n\n      if (wrapping) {\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n      } else {\n        return widgetsHeight + th;\n      }\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc,\n        est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n\n      if (estHeight != line.height) {\n        updateLineHeight(line, estHeight);\n      }\n    });\n  } // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n\n\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") {\n      return null;\n    }\n\n    var x,\n        y,\n        space = display.lineSpace.getBoundingClientRect(); // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n\n    try {\n      x = e.clientX - space.left;\n      y = e.clientY - space.top;\n    } catch (e) {\n      return null;\n    }\n\n    var coords = _coordsChar(cm, x, y),\n        line;\n\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n\n    return coords;\n  } // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n\n\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) {\n      return null;\n    }\n\n    n -= cm.display.viewFrom;\n\n    if (n < 0) {\n      return null;\n    }\n\n    var view = cm.display.view;\n\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n\n      if (n < 0) {\n        return i;\n      }\n    }\n  } // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n\n\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) {\n      from = cm.doc.first;\n    }\n\n    if (to == null) {\n      to = cm.doc.first + cm.doc.size;\n    }\n\n    if (!lendiff) {\n      lendiff = 0;\n    }\n\n    var display = cm.display;\n\n    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {\n      display.updateLineNumbers = from;\n    }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) {\n      // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {\n        resetView(cm);\n      }\n    } else if (to <= display.viewFrom) {\n      // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) {\n      // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) {\n      // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) {\n      // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else {\n      // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n\n    if (ext) {\n      if (to < ext.lineN) {\n        ext.lineN += lendiff;\n      } else if (from < ext.lineN + ext.size) {\n        display.externalMeasured = null;\n      }\n    }\n  } // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n\n\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display,\n        ext = cm.display.externalMeasured;\n\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {\n      display.externalMeasured = null;\n    }\n\n    if (line < display.viewFrom || line >= display.viewTo) {\n      return;\n    }\n\n    var lineView = display.view[findViewIndex(cm, line)];\n\n    if (lineView.node == null) {\n      return;\n    }\n\n    var arr = lineView.changes || (lineView.changes = []);\n\n    if (indexOf(arr, type) == -1) {\n      arr.push(type);\n    }\n  } // Clear the view.\n\n\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN),\n        diff,\n        view = cm.display.view;\n\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {\n      return {\n        index: index,\n        lineN: newN\n      };\n    }\n\n    var n = cm.display.viewFrom;\n\n    for (var i = 0; i < index; i++) {\n      n += view[i].size;\n    }\n\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) {\n          return null;\n        }\n\n        diff = n + view[index].size - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n\n      oldN += diff;\n      newN += diff;\n    }\n\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) {\n        return null;\n      }\n\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n\n    return {\n      index: index,\n      lineN: newN\n    };\n  } // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n\n\n  function adjustView(cm, from, to) {\n    var display = cm.display,\n        view = display.view;\n\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from) {\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n      } else if (display.viewFrom < from) {\n        display.view = display.view.slice(findViewIndex(cm, from));\n      }\n\n      display.viewFrom = from;\n\n      if (display.viewTo < to) {\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n      } else if (display.viewTo > to) {\n        display.view = display.view.slice(0, findViewIndex(cm, to));\n      }\n    }\n\n    display.viewTo = to;\n  } // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n\n\n  function countDirtyView(cm) {\n    var view = cm.display.view,\n        dirty = 0;\n\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) {\n        ++dirty;\n      }\n    }\n\n    return dirty;\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if (primary === void 0) primary = true;\n    var doc = cm.doc,\n        result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) {\n        continue;\n      }\n\n      var range$$1 = doc.sel.ranges[i];\n\n      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) {\n        continue;\n      }\n\n      var collapsed = range$$1.empty();\n\n      if (collapsed || cm.options.showCursorWhenSelecting) {\n        drawSelectionCursor(cm, range$$1.head, curFragment);\n      }\n\n      if (!collapsed) {\n        drawSelectionRange(cm, range$$1, selFragment);\n      }\n    }\n\n    return result;\n  } // Draws a cursor for the given range\n\n\n  function drawSelectionCursor(cm, head, output) {\n    var pos = _cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\xA0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\xA0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) {\n    return a.top - b.top || a.left - b.left;\n  } // Draws the given range as a highlighted selection\n\n\n  function drawSelectionRange(cm, range$$1, output) {\n    var display = cm.display,\n        doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display),\n        leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) {\n        top = 0;\n      }\n\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n\n      function coords(ch, bias) {\n        return _charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = dir == \"ltr\" == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop];\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n        var openStart = fromArg == null && from == 0,\n            openEnd = toArg == null && to == lineLen;\n        var first = i == 0,\n            last = !order || i == order.length - 1;\n\n        if (toPos.top - fromPos.top <= 3) {\n          // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else {\n          // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n\n          if (fromPos.bottom < toPos.top) {\n            add(leftSide, fromPos.bottom, null, toPos.top);\n          }\n\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) {\n          start = fromPos;\n        }\n\n        if (cmpCoords(toPos, start) < 0) {\n          start = toPos;\n        }\n\n        if (!end || cmpCoords(fromPos, end) < 0) {\n          end = fromPos;\n        }\n\n        if (cmpCoords(toPos, end) < 0) {\n          end = toPos;\n        }\n      });\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    var sFrom = range$$1.from(),\n        sTo = range$$1.to();\n\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line),\n          toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n\n      if (leftEnd.bottom < rightStart.top) {\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n      }\n    }\n\n    output.appendChild(fragment);\n  } // Cursor-blinking\n\n\n  function restartBlink(cm) {\n    if (!cm.state.focused) {\n      return;\n    }\n\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n\n    if (cm.options.cursorBlinkRate > 0) {\n      display.blinker = setInterval(function () {\n        return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n    } else if (cm.options.cursorBlinkRate < 0) {\n      display.cursorDiv.style.visibility = \"hidden\";\n    }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) {\n      cm.display.input.focus();\n      onFocus(cm);\n    }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () {\n      if (cm.state.delayingBlurEvent) {\n        cm.state.delayingBlurEvent = false;\n        onBlur(cm);\n      }\n    }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n    }\n\n    if (cm.options.readOnly == \"nocursor\") {\n      return;\n    }\n\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\"); // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n\n        if (webkit) {\n          setTimeout(function () {\n            return cm.display.input.reset(true);\n          }, 20);\n        } // Issue #1730\n\n      }\n\n      cm.display.input.receivedFocus();\n    }\n\n    restartBlink(cm);\n  }\n\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) {\n      return;\n    }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n\n    clearInterval(cm.display.blinker);\n    setTimeout(function () {\n      if (!cm.state.focused) {\n        cm.display.shift = false;\n      }\n    }, 150);\n  } // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n\n\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i],\n          wrapping = cm.options.lineWrapping;\n      var height = void 0,\n          width = 0;\n\n      if (cur.hidden) {\n        continue;\n      }\n\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top; // Check that lines don't extend past the right of the current\n        // editor width\n\n        if (!wrapping && cur.text.firstChild) {\n          width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;\n        }\n      }\n\n      var diff = cur.line.height - height;\n\n      if (diff > .005 || diff < -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n\n        if (cur.rest) {\n          for (var j = 0; j < cur.rest.length; j++) {\n            updateWidgetHeight(cur.rest[j]);\n          }\n        }\n      }\n\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  } // Read and store the height of line widgets associated with the\n  // given line.\n\n\n  function updateWidgetHeight(line) {\n    if (line.widgets) {\n      for (var i = 0; i < line.widgets.length; ++i) {\n        var w = line.widgets[i],\n            parent = w.node.parentNode;\n\n        if (parent) {\n          w.height = parent.offsetHeight;\n        }\n      }\n    }\n  } // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n\n\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = _lineAtHeight(doc, top),\n        to = _lineAtHeight(doc, bottom); // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n\n\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line,\n          ensureTo = viewport.ensure.to.line;\n\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n\n    return {\n      from: from,\n      to: Math.max(to, from + 1)\n    };\n  } // SCROLLING THINGS INTO VIEW\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n\n\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) {\n      return;\n    }\n\n    var display = cm.display,\n        box = display.sizer.getBoundingClientRect(),\n        doScroll = null;\n\n    if (rect.top + box.top < 0) {\n      doScroll = true;\n    } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {\n      doScroll = false;\n    }\n\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200B\", null, \"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + rect.left + \"px; width: \" + Math.max(2, rect.right - rect.left) + \"px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  } // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n\n\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) {\n      margin = 0;\n    }\n\n    var rect;\n\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n    }\n\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n\n      var coords = _cursorCoords(cm, pos);\n\n      var endCoords = !end || end == pos ? coords : _cursorCoords(cm, end);\n      rect = {\n        left: Math.min(coords.left, endCoords.left),\n        top: Math.min(coords.top, endCoords.top) - margin,\n        right: Math.max(coords.left, endCoords.left),\n        bottom: Math.max(coords.bottom, endCoords.bottom) + margin\n      };\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop,\n          startLeft = cm.doc.scrollLeft;\n\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) {\n          changed = true;\n        }\n      }\n\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {\n          changed = true;\n        }\n      }\n\n      if (!changed) {\n        break;\n      }\n    }\n\n    return rect;\n  } // Scroll a given set of coordinates into view (immediately).\n\n\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n\n    if (scrollPos.scrollTop != null) {\n      updateScrollTop(cm, scrollPos.scrollTop);\n    }\n\n    if (scrollPos.scrollLeft != null) {\n      setScrollLeft(cm, scrollPos.scrollLeft);\n    }\n  } // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n\n\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display,\n        snapMargin = textHeight(cm.display);\n\n    if (rect.top < 0) {\n      rect.top = 0;\n    }\n\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm),\n        result = {};\n\n    if (rect.bottom - rect.top > screen) {\n      rect.bottom = rect.top + screen;\n    }\n\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin,\n        atBottom = rect.bottom > docBottom - snapMargin;\n\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n\n      if (newTop != screentop) {\n        result.scrollTop = newTop;\n      }\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = rect.right - rect.left > screenw;\n\n    if (tooWide) {\n      rect.right = rect.left + screenw;\n    }\n\n    if (rect.left < 10) {\n      result.scrollLeft = 0;\n    } else if (rect.left < screenleft) {\n      result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10));\n    } else if (rect.right > screenw + screenleft - 3) {\n      result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;\n    }\n\n    return result;\n  } // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n\n\n  function addToScrollTop(cm, top) {\n    if (top == null) {\n      return;\n    }\n\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  } // Make sure that at the end of the operation the current cursor is\n  // shown.\n\n\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {\n      from: cur,\n      to: cur,\n      margin: cm.options.cursorScrollMargin\n    };\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) {\n      resolveScrollToPos(cm);\n    }\n\n    if (x != null) {\n      cm.curOp.scrollLeft = x;\n    }\n\n    if (y != null) {\n      cm.curOp.scrollTop = y;\n    }\n  }\n\n  function scrollToRange(cm, range$$1) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range$$1;\n  } // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n\n\n  function resolveScrollToPos(cm) {\n    var range$$1 = cm.curOp.scrollToPos;\n\n    if (range$$1) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range$$1.from),\n          to = estimateCoords(cm, range$$1.to);\n      scrollToCoordsRange(cm, from, to, range$$1.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  } // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n\n\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) {\n      return;\n    }\n\n    if (!gecko) {\n      updateDisplaySimple(cm, {\n        top: val\n      });\n    }\n\n    setScrollTop(cm, val, true);\n\n    if (gecko) {\n      updateDisplaySimple(cm);\n    }\n\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n\n    if (cm.display.scroller.scrollTop == val && !forceScroll) {\n      return;\n    }\n\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n\n    if (cm.display.scroller.scrollTop != val) {\n      cm.display.scroller.scrollTop = val;\n    }\n  } // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n\n\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {\n      return;\n    }\n\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n\n    if (cm.display.scroller.scrollLeft != val) {\n      cm.display.scroller.scrollLeft = val;\n    }\n\n    cm.display.scrollbars.setScrollLeft(val);\n  } // SCROLLBARS\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n\n\n  function measureForScrollbars(cm) {\n    var d = cm.display,\n        gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth,\n      clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    };\n  }\n\n  var NativeScrollbars = function NativeScrollbars(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert);\n    place(horiz);\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) {\n        scroll(vert.scrollTop, \"vertical\");\n      }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) {\n        scroll(horiz.scrollLeft, \"horizontal\");\n      }\n    });\n    this.checkedZeroWidth = false; // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n\n    if (ie && ie_version < 8) {\n      this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n    }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0); // A bug in IE8 can cause this value to be negative, so guard it.\n\n      this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) {\n        this.zeroWidthHack();\n      }\n\n      this.checkedZeroWidth = true;\n    }\n\n    return {\n      right: needsV ? sWidth : 0,\n      bottom: needsH ? sWidth : 0\n    };\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) {\n      this.horiz.scrollLeft = pos;\n    }\n\n    if (this.disableHoriz) {\n      this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\");\n    }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) {\n      this.vert.scrollTop = pos;\n    }\n\n    if (this.disableVert) {\n      this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\");\n    }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed();\n    this.disableVert = new Delayed();\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n\n      if (elt$$1 != bar) {\n        bar.style.pointerEvents = \"none\";\n      } else {\n        delay.set(1000, maybeDisable);\n      }\n    }\n\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function NullScrollbars() {};\n\n  NullScrollbars.prototype.update = function () {\n    return {\n      bottom: 0,\n      right: 0\n    };\n  };\n\n  NullScrollbars.prototype.setScrollLeft = function () {};\n\n  NullScrollbars.prototype.setScrollTop = function () {};\n\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) {\n      measure = measureForScrollbars(cm);\n    }\n\n    var startWidth = cm.display.barWidth,\n        startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {\n        updateHeightsInViewport(cm);\n      }\n\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth;\n      startHeight = cm.display.barHeight;\n    }\n  } // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n\n\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else {\n      d.scrollbarFiller.style.display = \"\";\n    }\n\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else {\n      d.gutterFiller.style.display = \"\";\n    }\n  }\n\n  var scrollbarModel = {\n    \"native\": NativeScrollbars,\n    \"null\": NullScrollbars\n  };\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n\n      if (cm.display.scrollbars.addClass) {\n        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n      }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller); // Prevent clicks in the scrollbars from killing focus\n\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) {\n          setTimeout(function () {\n            return cm.display.input.focus();\n          }, 0);\n        }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") {\n        setScrollLeft(cm, pos);\n      } else {\n        updateScrollTop(cm, pos);\n      }\n    }, cm);\n\n    if (cm.display.scrollbars.addClass) {\n      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n    }\n  } // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n\n  var nextOpId = 0; // Start a new operation.\n\n  function _startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,\n      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height,\n      // Used to detect need to update scrollbar\n      forceUpdate: false,\n      // Used to force a redraw\n      updateInput: 0,\n      // Whether to reset the input textarea\n      typing: false,\n      // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,\n      // Accumulated changes, for firing change events\n      cursorActivityHandlers: null,\n      // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0,\n      // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false,\n      // Whether the selection needs to be redrawn\n      updateMaxLine: false,\n      // Set when the widest line needs to be determined anew\n      scrollLeft: null,\n      scrollTop: null,\n      // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,\n      // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId // Unique ID\n\n    };\n    pushOperation(cm.curOp);\n  } // Finish an operation, updating the display and signalling delayed events\n\n\n  function _endOperation(cm) {\n    var op = cm.curOp;\n\n    if (op) {\n      finishOperation(op, function (group) {\n        for (var i = 0; i < group.ops.length; i++) {\n          group.ops[i].cm.curOp = null;\n        }\n\n        endOperations(group);\n      });\n    }\n  } // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n\n\n  function endOperations(group) {\n    var ops = group.ops;\n\n    for (var i = 0; i < ops.length; i++) // Read DOM\n    {\n      endOperation_R1(ops[i]);\n    }\n\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n    {\n      endOperation_W1(ops[i$1]);\n    }\n\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n    {\n      endOperation_R2(ops[i$2]);\n    }\n\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n    {\n      endOperation_W2(ops[i$3]);\n    }\n\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n    {\n      endOperation_finish(ops[i$4]);\n    }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm,\n        display = cm.display;\n    maybeClipScrollbars(cm);\n\n    if (op.updateMaxLine) {\n      findMaxLine(cm);\n    }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {\n      top: op.scrollTop,\n      ensure: op.scrollToPos\n    }, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm,\n        display = cm.display;\n\n    if (op.updatedDisplay) {\n      updateHeightsInViewport(cm);\n    }\n\n    op.barMeasure = measureForScrollbars(cm); // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged) {\n      op.preparedSelection = display.input.prepareSelection();\n    }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n\n      if (op.maxScrollLeft < cm.doc.scrollLeft) {\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n      }\n\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n\n    if (op.preparedSelection) {\n      cm.display.input.showSelection(op.preparedSelection, takeFocus);\n    }\n\n    if (op.updatedDisplay || op.startHeight != cm.doc.height) {\n      updateScrollbars(cm, op.barMeasure);\n    }\n\n    if (op.updatedDisplay) {\n      setDocumentHeight(cm, op.barMeasure);\n    }\n\n    if (op.selectionChanged) {\n      restartBlink(cm);\n    }\n\n    if (cm.state.focused && op.updateInput) {\n      cm.display.input.reset(op.typing);\n    }\n\n    if (takeFocus) {\n      ensureFocus(op.cm);\n    }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm,\n        display = cm.display,\n        doc = cm.doc;\n\n    if (op.updatedDisplay) {\n      postUpdateDisplay(cm, op.update);\n    } // Abort mouse wheel delta measurement, when scrolling explicitly\n\n\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {\n      display.wheelStartX = display.wheelStartY = null;\n    } // Propagate the scroll position to the actual DOM scroller\n\n\n    if (op.scrollTop != null) {\n      setScrollTop(cm, op.scrollTop, op.forceScroll);\n    }\n\n    if (op.scrollLeft != null) {\n      setScrollLeft(cm, op.scrollLeft, true, true);\n    } // If we need to scroll a specific position into view, do so.\n\n\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, _clipPos(doc, op.scrollToPos.from), _clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    } // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n\n\n    var hidden = op.maybeHiddenMarkers,\n        unhidden = op.maybeUnhiddenMarkers;\n\n    if (hidden) {\n      for (var i = 0; i < hidden.length; ++i) {\n        if (!hidden[i].lines.length) {\n          signal(hidden[i], \"hide\");\n        }\n      }\n    }\n\n    if (unhidden) {\n      for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {\n        if (unhidden[i$1].lines.length) {\n          signal(unhidden[i$1], \"unhide\");\n        }\n      }\n    }\n\n    if (display.wrapper.offsetHeight) {\n      doc.scrollTop = cm.display.scroller.scrollTop;\n    } // Fire change events, and delayed event handlers\n\n\n    if (op.changeObjs) {\n      signal(cm, \"changes\", cm, op.changeObjs);\n    }\n\n    if (op.update) {\n      op.update.finish();\n    }\n  } // Run the given function in an operation\n\n\n  function runInOp(cm, f) {\n    if (cm.curOp) {\n      return f();\n    }\n\n    _startOperation(cm);\n\n    try {\n      return f();\n    } finally {\n      _endOperation(cm);\n    }\n  } // Wraps a function in an operation. Returns the wrapped function.\n\n\n  function operation(cm, f) {\n    return function () {\n      if (cm.curOp) {\n        return f.apply(cm, arguments);\n      }\n\n      _startOperation(cm);\n\n      try {\n        return f.apply(cm, arguments);\n      } finally {\n        _endOperation(cm);\n      }\n    };\n  } // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n\n\n  function methodOp(f) {\n    return function () {\n      if (this.curOp) {\n        return f.apply(this, arguments);\n      }\n\n      _startOperation(this);\n\n      try {\n        return f.apply(this, arguments);\n      } finally {\n        _endOperation(this);\n      }\n    };\n  }\n\n  function docMethodOp(f) {\n    return function () {\n      var cm = this.cm;\n\n      if (!cm || cm.curOp) {\n        return f.apply(this, arguments);\n      }\n\n      _startOperation(cm);\n\n      try {\n        return f.apply(this, arguments);\n      } finally {\n        _endOperation(cm);\n      }\n    };\n  } // HIGHLIGHT WORKER\n\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo) {\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n    }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n\n    if (doc.highlightFrontier >= cm.display.viewTo) {\n      return;\n    }\n\n    var end = +new Date() + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) {\n        // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n\n        if (resetState) {\n          context.state = resetState;\n        }\n\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses,\n            newCls = highlighted.classes;\n\n        if (newCls) {\n          line.styleClasses = newCls;\n        } else if (oldCls) {\n          line.styleClasses = null;\n        }\n\n        var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) {\n          ischange = oldStyles[i] != line.styles[i];\n        }\n\n        if (ischange) {\n          changedLines.push(context.line);\n        }\n\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength) {\n          processLine(cm, line.text, context);\n        }\n\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n\n      if (+new Date() > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n\n    if (changedLines.length) {\n      runInOp(cm, function () {\n        for (var i = 0; i < changedLines.length; i++) {\n          regLineChange(cm, changedLines[i], \"text\");\n        }\n      });\n    }\n  } // DISPLAY DRAWING\n\n\n  var DisplayUpdate = function DisplayUpdate(cm, viewport, force) {\n    var display = cm.display;\n    this.viewport = viewport; // Store some values that we'll need later (but don't want to force a relayout for)\n\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type)) {\n      this.events.push(arguments);\n    }\n  };\n\n  DisplayUpdate.prototype.finish = function () {\n    var this$1 = this;\n\n    for (var i = 0; i < this.events.length; i++) {\n      signal.apply(null, this$1.events[i]);\n    }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) {\n      return null;\n    }\n\n    var active = activeElt();\n\n    if (!active || !contains(cm.display.lineDiv, active)) {\n      return null;\n    }\n\n    var result = {\n      activeElt: active\n    };\n\n    if (window.getSelection) {\n      var sel = window.getSelection();\n\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n\n    return result;\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {\n      return;\n    }\n\n    snapshot.activeElt.focus();\n\n    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(),\n          range$$1 = document.createRange();\n      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range$$1.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range$$1);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  } // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n\n\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display,\n        doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false;\n    } // Bail out if the visible area is already rendered and nothing changed.\n\n\n    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {\n      return false;\n    }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    } // Compute a suitable new viewport (from & to)\n\n\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n\n    if (display.viewFrom < from && from - display.viewFrom < 20) {\n      from = Math.max(doc.first, display.viewFrom);\n    }\n\n    if (display.viewTo > to && display.viewTo - to < 20) {\n      to = Math.min(end, display.viewTo);\n    }\n\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n    display.viewOffset = _heightAtLine(getLine(cm.doc, display.viewFrom)); // Position the mover div to align with the current scroll position\n\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n    var toUpdate = countDirtyView(cm);\n\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {\n      return false;\n    } // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n\n\n    var selSnapshot = selectionSnapshot(cm);\n\n    if (toUpdate > 4) {\n      display.lineDiv.style.display = \"none\";\n    }\n\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n\n    if (toUpdate > 4) {\n      display.lineDiv.style.display = \"\";\n    }\n\n    display.renderedView = display.view; // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n\n    restoreSelection(selSnapshot); // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n    return true;\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null) {\n          viewport = {\n            top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)\n          };\n        } // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n\n\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {\n          break;\n        }\n      }\n\n      if (!updateDisplayIfNeeded(cm, update)) {\n        break;\n      }\n\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom;\n      cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  } // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n\n\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display,\n        lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv,\n        cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling; // Works around a throw-scroll bug in OS X Webkit\n\n      if (webkit && mac && cm.display.currentWheelTarget == node) {\n        node.style.display = \"none\";\n      } else {\n        node.parentNode.removeChild(node);\n      }\n\n      return next;\n    }\n\n    var view = display.view,\n        lineN = display.viewFrom; // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ;else if (!lineView.node || lineView.node.parentNode != container) {\n        // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else {\n        // Already drawn\n        while (cur != lineView.node) {\n          cur = rm(cur);\n        }\n\n        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;\n\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) {\n            updateNumber = false;\n          }\n\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n\n    while (cur) {\n      cur = rm(cur);\n    }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + \"px\";\n  } // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n\n\n  function alignHorizontally(cm) {\n    var display = cm.display,\n        view = display.view;\n\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {\n      return;\n    }\n\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth,\n        left = comp + \"px\";\n\n    for (var i = 0; i < view.length; i++) {\n      if (!view[i].hidden) {\n        if (cm.options.fixedGutter) {\n          if (view[i].gutter) {\n            view[i].gutter.style.left = left;\n          }\n\n          if (view[i].gutterBackground) {\n            view[i].gutterBackground.style.left = left;\n          }\n        }\n\n        var align = view[i].alignable;\n\n        if (align) {\n          for (var j = 0; j < align.length; j++) {\n            align[j].style.left = left;\n          }\n        }\n      }\n    }\n\n    if (cm.options.fixedGutter) {\n      display.gutters.style.left = comp + gutterW + \"px\";\n    }\n  } // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n\n\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) {\n      return false;\n    }\n\n    var doc = cm.doc,\n        last = lineNumberFor(cm.options, doc.first + doc.size - 1),\n        display = cm.display;\n\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)], \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth,\n          padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm.display);\n      return true;\n    }\n\n    return false;\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [],\n        sawLineNumbers = false;\n\n    for (var i = 0; i < gutters.length; i++) {\n      var name = gutters[i],\n          style = null;\n\n      if (typeof name != \"string\") {\n        style = name.style;\n        name = name.className;\n      }\n\n      if (name == \"CodeMirror-linenumbers\") {\n        if (!lineNumbers) {\n          continue;\n        } else {\n          sawLineNumbers = true;\n        }\n      }\n\n      result.push({\n        className: name,\n        style: style\n      });\n    }\n\n    if (lineNumbers && !sawLineNumbers) {\n      result.push({\n        className: \"CodeMirror-linenumbers\",\n        style: null\n      });\n    }\n\n    return result;\n  } // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n\n\n  function renderGutters(display) {\n    var gutters = display.gutters,\n        specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n\n    for (var i = 0; i < specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n\n      if (style) {\n        gElt.style.cssText = style;\n      }\n\n      if (className == \"CodeMirror-linenumbers\") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n      }\n    }\n\n    gutters.style.display = specs.length ? \"\" : \"none\";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  } // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input; // Covers bottom-right square when both scrollbars are present.\n\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\"); // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\"); // Will contain the actual code, positioned to cover the viewport.\n\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\"); // Elements are added to these to represent selection and cursors.\n\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\"); // A visibility: hidden element used to find the size of things.\n\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\"); // When lines outside of the viewport are measured, they are drawn in this.\n\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\"); // Wraps everything that needs to exist inside the vertically-padded coordinate system\n\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\"); // Moved around its parent to cover visible view.\n\n    d.mover = elt(\"div\", [lines], null, \"position: relative\"); // Set to the height of the document, allowing scrolling.\n\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null; // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\"); // Will contain the gutters, if any.\n\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null; // Actual scrollable element.\n\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\"); // The element in which the editor lives.\n\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\"); // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n\n    if (ie && ie_version < 8) {\n      d.gutters.style.zIndex = -1;\n      d.scroller.style.paddingRight = 0;\n    }\n\n    if (!webkit && !(gecko && mobile)) {\n      d.scroller.draggable = true;\n    }\n\n    if (place) {\n      if (place.appendChild) {\n        place.appendChild(d.wrapper);\n      } else {\n        place(d.wrapper);\n      }\n    } // Current rendered range (may be bigger than the view window).\n\n\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first; // Information about the rendered lines.\n\n    d.view = [];\n    d.renderedView = null; // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n\n    d.externalMeasured = null; // Empty space (in pixels) above the view\n\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false; // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null; // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n\n    d.alignWidgets = false;\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null; // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false; // Used for measuring wheel scrolling granularity\n\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null; // True when shift is held down.\n\n    d.shift = false; // Used to track whether anything happened since the context menu\n    // was opened.\n\n    d.selForContextMenu = null;\n    d.activeTouch = null;\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n    input.init(d);\n  } // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n\n  var wheelSamples = 0,\n      wheelPixelsPerUnit = null; // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n\n  if (ie) {\n    wheelPixelsPerUnit = -.53;\n  } else if (gecko) {\n    wheelPixelsPerUnit = 15;\n  } else if (chrome) {\n    wheelPixelsPerUnit = -.7;\n  } else if (safari) {\n    wheelPixelsPerUnit = -1 / 3;\n  }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX,\n        dy = e.wheelDeltaY;\n\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {\n      dx = e.detail;\n    }\n\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {\n      dy = e.detail;\n    } else if (dy == null) {\n      dy = e.wheelDelta;\n    }\n\n    return {\n      x: dx,\n      y: dy\n    };\n  }\n\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta;\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e),\n        dx = delta.x,\n        dy = delta.y;\n    var display = cm.display,\n        scroll = display.scroller; // Quit if there's nothing to scroll here\n\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n\n    if (!(dx && canScrollX || dy && canScrollY)) {\n      return;\n    } // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n\n\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer;\n          }\n        }\n      }\n    } // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n\n\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY) {\n        updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));\n      }\n\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)); // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n\n      if (!dy || dy && canScrollY) {\n        e_preventDefault(e);\n      }\n\n      display.wheelStartX = null; // Abort measurement, if in progress\n\n      return;\n    } // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n\n\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop,\n          bot = top + display.wrapper.clientHeight;\n\n      if (pixels < 0) {\n        top = Math.max(0, top + pixels - 50);\n      } else {\n        bot = Math.min(cm.doc.height, bot + pixels + 50);\n      }\n\n      updateDisplaySimple(cm, {\n        top: top,\n        bottom: bot\n      });\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft;\n        display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx;\n        display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) {\n            return;\n          }\n\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;\n          display.wheelStartX = display.wheelStartY = null;\n\n          if (!sample) {\n            return;\n          }\n\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx;\n        display.wheelDY += dy;\n      }\n    }\n  } // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n\n\n  var Selection = function Selection(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () {\n    return this.ranges[this.primIndex];\n  };\n\n  Selection.prototype.equals = function (other) {\n    var this$1 = this;\n\n    if (other == this) {\n      return true;\n    }\n\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {\n      return false;\n    }\n\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this$1.ranges[i],\n          there = other.ranges[i];\n\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Selection.prototype.deepCopy = function () {\n    var this$1 = this;\n    var out = [];\n\n    for (var i = 0; i < this.ranges.length; i++) {\n      out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));\n    }\n\n    return new Selection(out, this.primIndex);\n  };\n\n  Selection.prototype.somethingSelected = function () {\n    var this$1 = this;\n\n    for (var i = 0; i < this.ranges.length; i++) {\n      if (!this$1.ranges[i].empty()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n    var this$1 = this;\n\n    if (!end) {\n      end = pos;\n    }\n\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this$1.ranges[i];\n\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  var Range = function Range(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  };\n\n  Range.prototype.from = function () {\n    return minPos(this.anchor, this.head);\n  };\n\n  Range.prototype.to = function () {\n    return maxPos(this.anchor, this.head);\n  };\n\n  Range.prototype.empty = function () {\n    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n  }; // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n\n\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) {\n      return cmp(a.from(), b.from());\n    });\n    primIndex = indexOf(ranges, prim);\n\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i],\n          prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()),\n            to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n\n        if (i <= primIndex) {\n          --primIndex;\n        }\n\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n\n    return new Selection(ranges, primIndex);\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0);\n  } // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n\n\n  function changeEnd(change) {\n    if (!change.text) {\n      return change.to;\n    }\n\n    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  } // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n\n\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) {\n      return pos;\n    }\n\n    if (cmp(pos, change.to) <= 0) {\n      return changeEnd(change);\n    }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,\n        ch = pos.ch;\n\n    if (pos.line == change.to.line) {\n      ch += changeEnd(change).ch - change.to.ch;\n    }\n\n    return Pos(line, ch);\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));\n    }\n\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex);\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line) {\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n    } else {\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\n    }\n  } // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n\n\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0),\n        newPrev = oldPrev;\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i],\n            inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n\n    return new Selection(out, doc.sel.primIndex);\n  } // Used to get the editor into a consistent state again when options change.\n\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) {\n        line.stateAfter = null;\n      }\n\n      if (line.styles) {\n        line.styles = null;\n      }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n\n    if (cm.curOp) {\n      regChange(cm);\n    }\n  } // DOCUMENT DATA STRUCTURE\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n\n\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n  } // Perform a change on the document data structure.\n\n\n  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n    function spansFor(n) {\n      return markedSpans ? markedSpans[n] : null;\n    }\n\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight$$1);\n      signalLater(line, \"change\", line, change);\n    }\n\n    function linesFor(start, end) {\n      var result = [];\n\n      for (var i = start; i < end; ++i) {\n        result.push(new Line(text[i], spansFor(i), estimateHeight$$1));\n      }\n\n      return result;\n    }\n\n    var from = change.from,\n        to = change.to,\n        text = change.text;\n    var firstLine = getLine(doc, from.line),\n        lastLine = getLine(doc, to.line);\n    var lastText = lst(text),\n        lastSpans = spansFor(text.length - 1),\n        nlines = to.line - from.line; // Adjust the line structure\n\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n\n      if (nlines) {\n        doc.remove(from.line, nlines);\n      }\n\n      if (added.length) {\n        doc.insert(from.line, added);\n      }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n\n      if (nlines > 1) {\n        doc.remove(from.line + 1, nlines - 1);\n      }\n\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  } // Call f for all linked documents.\n\n\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) {\n        for (var i = 0; i < doc.linked.length; ++i) {\n          var rel = doc.linked[i];\n\n          if (rel.doc == skip) {\n            continue;\n          }\n\n          var shared = sharedHist && rel.sharedHist;\n\n          if (sharedHistOnly && !shared) {\n            continue;\n          }\n\n          f(rel.doc, shared);\n          propagate(rel.doc, doc, shared);\n        }\n      }\n    }\n\n    propagate(doc, null, true);\n  } // Attach a document to an editor.\n\n\n  function attachDoc(cm, doc) {\n    if (doc.cm) {\n      throw new Error(\"This document is already in use.\");\n    }\n\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n\n    if (!cm.options.lineWrapping) {\n      findMaxLine(cm);\n    }\n\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n    (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = [];\n    this.undone = [];\n    this.undoDepth = Infinity; // Used to track when changes can be merged into a single undo\n    // event\n\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null; // Used by the isClean() method\n\n    this.generation = this.maxGeneration = startGen || 1;\n  } // Create a history change event from an updateDoc-style change\n  // object.\n\n\n  function historyChangeFromChange(doc, change) {\n    var histChange = {\n      from: copyPos(change.from),\n      to: changeEnd(change),\n      text: getBetween(doc, change.from, change.to)\n    };\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) {\n      return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    }, true);\n    return histChange;\n  } // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n\n\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n\n      if (last.ranges) {\n        array.pop();\n      } else {\n        break;\n      }\n    }\n  } // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n\n\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done);\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done);\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done);\n    }\n  } // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n\n\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date(),\n        cur;\n    var last;\n\n    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == \"*\")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n\n      if (!before || !before.ranges) {\n        pushSelectionToHistory(doc.sel, hist.done);\n      }\n\n      cur = {\n        changes: [historyChangeFromChange(doc, change)],\n        generation: hist.generation\n      };\n      hist.done.push(cur);\n\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n\n        if (!hist.done[0].ranges) {\n          hist.done.shift();\n        }\n      }\n    }\n\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) {\n      signal(doc, \"historyAdded\");\n    }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" || ch == \"+\" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n  } // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n\n\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history,\n        origin = options && options.origin; // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n\n    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {\n      hist.done[hist.done.length - 1] = sel;\n    } else {\n      pushSelectionToHistory(sel, hist.done);\n    }\n\n    hist.lastSelTime = +new Date();\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n\n    if (options && options.clearRedo !== false) {\n      clearSelectionEvents(hist.undone);\n    }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n\n    if (!(top && top.ranges && top.equals(sel))) {\n      dest.push(sel);\n    }\n  } // Used to store marked span information in the history.\n\n\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id],\n        n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans) {\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      }\n\n      ++n;\n    });\n  } // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n\n\n  function removeClearedSpans(spans) {\n    if (!spans) {\n      return null;\n    }\n\n    var out;\n\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) {\n        if (!out) {\n          out = spans.slice(0, i);\n        }\n      } else if (out) {\n        out.push(spans[i]);\n      }\n    }\n\n    return !out ? spans : out.length ? out : null;\n  } // Retrieve and filter the old marked spans stored in a change event.\n\n\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n\n    if (!found) {\n      return null;\n    }\n\n    var nw = [];\n\n    for (var i = 0; i < change.text.length; ++i) {\n      nw.push(removeClearedSpans(found[i]));\n    }\n\n    return nw;\n  } // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n\n\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n\n    if (!old) {\n      return stretched;\n    }\n\n    if (!stretched) {\n      return old;\n    }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i],\n          stretchCur = stretched[i];\n\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n\n          for (var k = 0; k < oldCur.length; ++k) {\n            if (oldCur[k].marker == span.marker) {\n              continue spans;\n            }\n          }\n\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n\n    return old;\n  } // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n\n\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue;\n      }\n\n      var changes = event.changes,\n          newChanges = [];\n      copy.push({\n        changes: newChanges\n      });\n\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j],\n            m = void 0;\n        newChanges.push({\n          from: change.from,\n          to: change.to,\n          text: change.text\n        });\n\n        if (newGroup) {\n          for (var prop in change) {\n            if (m = prop.match(/^spans_(\\d+)$/)) {\n              if (indexOf(newGroup, Number(m[1])) > -1) {\n                lst(newChanges)[prop] = change[prop];\n                delete change[prop];\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return copy;\n  } // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n\n\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n\n        if (posBefore != cmp(other, anchor) < 0) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != cmp(head, other) < 0) {\n          head = other;\n        }\n      }\n\n      return new Range(anchor, head);\n    } else {\n      return new Range(other || head, head);\n    }\n  } // Extend the primary selection range, discard the rest.\n\n\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) {\n      extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    }\n\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  } // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n\n\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);\n    }\n\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  } // Updates a single range in the selection.\n\n\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  } // Reset the selection to a single range.\n\n\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  } // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n\n\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function update(ranges) {\n        var this$1 = this;\n        this.ranges = [];\n\n        for (var i = 0; i < ranges.length; i++) {\n          this$1.ranges[i] = new Range(_clipPos(doc, ranges[i].anchor), _clipPos(doc, ranges[i].head));\n        }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n\n    if (doc.cm) {\n      signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    }\n\n    if (obj.ranges != sel.ranges) {\n      return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);\n    } else {\n      return sel;\n    }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done,\n        last = lst(done);\n\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  } // Set a new selection.\n\n\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\")) {\n      sel = filterSelectionChange(doc, sel, options);\n    }\n\n    var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm) {\n      ensureCursorVisible(doc.cm);\n    }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) {\n      return;\n    }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n\n    signalLater(doc, \"cursorActivity\", doc);\n  } // Verify that the selection does not partially select any atomic\n  // marked ranges.\n\n\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  } // Return a selection that does not partially select any atomic\n  // ranges.\n\n\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) {\n          out = sel.ranges.slice(0, i);\n        }\n\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n\n    if (line.markedSpans) {\n      for (var i = 0; i < line.markedSpans.length; ++i) {\n        var sp = line.markedSpans[i],\n            m = sp.marker; // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n        // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n        // is with selectLeft/Right\n\n        var preventCursorLeft = \"selectLeft\" in m ? !m.selectLeft : m.inclusiveLeft;\n        var preventCursorRight = \"selectRight\" in m ? !m.selectRight : m.inclusiveRight;\n\n        if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n          if (mayClear) {\n            signal(m, \"beforeCursorEnter\");\n\n            if (m.explicitlyCleared) {\n              if (!line.markedSpans) {\n                break;\n              } else {\n                --i;\n                continue;\n              }\n            }\n          }\n\n          if (!m.atomic) {\n            continue;\n          }\n\n          if (oldPos) {\n            var near = m.find(dir < 0 ? 1 : -1),\n                diff = void 0;\n\n            if (dir < 0 ? preventCursorRight : preventCursorLeft) {\n              near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\n            }\n\n            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {\n              return skipAtomicInner(doc, near, pos, dir, mayClear);\n            }\n          }\n\n          var far = m.find(dir < 0 ? -1 : 1);\n\n          if (dir < 0 ? preventCursorLeft : preventCursorRight) {\n            far = movePos(doc, far, dir, far.line == pos.line ? line : null);\n          }\n\n          return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n        }\n      }\n    }\n\n    return pos;\n  } // Ensure a given position is not inside an atomic range.\n\n\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);\n\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0);\n    }\n\n    return found;\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) {\n        return _clipPos(doc, Pos(pos.line - 1));\n      } else {\n        return null;\n      }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) {\n        return Pos(pos.line + 1, 0);\n      } else {\n        return null;\n      }\n    } else {\n      return new Pos(pos.line, pos.ch + dir);\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  } // UPDATING\n  // Allow \"beforeChange\" event handlers to influence a change\n\n\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function cancel() {\n        return obj.canceled = true;\n      }\n    };\n\n    if (update) {\n      obj.update = function (from, to, text, origin) {\n        if (from) {\n          obj.from = _clipPos(doc, from);\n        }\n\n        if (to) {\n          obj.to = _clipPos(doc, to);\n        }\n\n        if (text) {\n          obj.text = text;\n        }\n\n        if (origin !== undefined) {\n          obj.origin = origin;\n        }\n      };\n    }\n\n    signal(doc, \"beforeChange\", doc, obj);\n\n    if (doc.cm) {\n      signal(doc.cm, \"beforeChange\", doc.cm, obj);\n    }\n\n    if (obj.canceled) {\n      if (doc.cm) {\n        doc.cm.curOp.updateInput = 2;\n      }\n\n      return null;\n    }\n\n    return {\n      from: obj.from,\n      to: obj.to,\n      text: obj.text,\n      origin: obj.origin\n    };\n  } // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n\n\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) {\n        return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n      }\n\n      if (doc.cm.state.suppressEdits) {\n        return;\n      }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n\n      if (!change) {\n        return;\n      }\n    } // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n\n\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i) {\n        makeChangeInner(doc, {\n          from: split[i].from,\n          to: split[i].to,\n          text: i ? [\"\"] : change.text,\n          origin: change.origin\n        });\n      }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) {\n      return;\n    }\n\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  } // Revert a change stored in a document's history.\n\n\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n\n    if (suppress && !allowSelectionOnly) {\n      return;\n    }\n\n    var hist = doc.history,\n        event,\n        selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone,\n        dest = type == \"undo\" ? hist.undone : hist.done; // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n\n    var i = 0;\n\n    for (; i < source.length; i++) {\n      event = source[i];\n\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {\n        break;\n      }\n    }\n\n    if (i == source.length) {\n      return;\n    }\n\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {\n            clearRedo: false\n          });\n          return;\n        }\n\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return;\n      } else {\n        break;\n      }\n    } // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n\n\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({\n      changes: antiChanges,\n      generation: hist.generation\n    });\n    hist.generation = event.generation || ++hist.maxGeneration;\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function loop(i) {\n      var change = event.changes[i];\n      change.origin = type;\n\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {};\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n\n      if (!i && doc.cm) {\n        doc.cm.scrollIntoView({\n          from: change.from,\n          to: changeEnd(change)\n        });\n      }\n\n      var rebased = []; // Propagate to the linked documents\n\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop(i$1);\n      if (returned) return returned.v;\n    }\n  } // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n\n\n  function shiftDoc(doc, distance) {\n    if (distance == 0) {\n      return;\n    }\n\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) {\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));\n    }), doc.sel.primIndex);\n\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {\n        regLineChange(doc.cm, l, \"gutter\");\n      }\n    }\n  } // More lower-level change function, handling only a single document\n  // (not linked ones).\n\n\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp) {\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n    }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n\n    if (change.from.line > doc.lastLine()) {\n      return;\n    } // Clip the change to the size of this doc\n\n\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {\n        from: Pos(doc.first, 0),\n        to: Pos(change.to.line + shift, change.to.ch),\n        text: [lst(change.text)],\n        origin: change.origin\n      };\n    }\n\n    var last = doc.lastLine();\n\n    if (change.to.line > last) {\n      change = {\n        from: change.from,\n        to: Pos(last, getLine(doc, last).text.length),\n        text: [change.text[0]],\n        origin: change.origin\n      };\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) {\n      selAfter = computeSelAfterChange(doc, change);\n    }\n\n    if (doc.cm) {\n      makeChangeSingleDocInEditor(doc.cm, change, spans);\n    } else {\n      updateDoc(doc, change, spans);\n    }\n\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  } // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n\n\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc,\n        display = cm.display,\n        from = change.from,\n        to = change.to;\n    var recomputeMaxLength = false,\n        checkWidthStart = from.line;\n\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1) {\n      signalCursorActivity(cm);\n    }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n\n      if (recomputeMaxLength) {\n        cm.curOp.updateMaxLine = true;\n      }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n    var lendiff = change.text.length - (to.line - from.line) - 1; // Remember that these lines changed, for updating the display\n\n    if (change.full) {\n      regChange(cm);\n    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {\n      regLineChange(cm, from.line, \"text\");\n    } else {\n      regChange(cm, from.line, to.line + 1, lendiff);\n    }\n\n    var changesHandler = hasHandler(cm, \"changes\"),\n        changeHandler = hasHandler(cm, \"change\");\n\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from,\n        to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n\n      if (changeHandler) {\n        signalLater(cm, \"change\", cm, obj);\n      }\n\n      if (changesHandler) {\n        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n      }\n    }\n\n    cm.display.selForContextMenu = null;\n  }\n\n  function _replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) {\n      to = from;\n    }\n\n    if (cmp(to, from) < 0) {\n      assign = [to, from], from = assign[0], to = assign[1];\n    }\n\n    if (typeof code == \"string\") {\n      code = doc.splitLines(code);\n    }\n\n    makeChange(doc, {\n      from: from,\n      to: to,\n      text: code,\n      origin: origin\n    });\n  } // Rebasing/resetting history to deal with externally-sourced changes\n\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  } // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n\n\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i],\n          ok = true;\n\n      if (sub.ranges) {\n        if (!sub.copied) {\n          sub = array[i] = sub.deepCopy();\n          sub.copied = true;\n        }\n\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n\n        continue;\n      }\n\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line,\n        to = change.to.line,\n        diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  } // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n\n\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle,\n        line = handle;\n\n    if (typeof handle == \"number\") {\n      line = getLine(doc, clipLine(doc, handle));\n    } else {\n      no = lineNo(handle);\n    }\n\n    if (no == null) {\n      return null;\n    }\n\n    if (op(line, no) && doc.cm) {\n      regLineChange(doc.cm, no, changeType);\n    }\n\n    return line;\n  } // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n\n  function LeafChunk(lines) {\n    var this$1 = this;\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this$1;\n      height += lines[i].height;\n    }\n\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function chunkSize() {\n      return this.lines.length;\n    },\n    // Remove the n lines at offset 'at'.\n    removeInner: function removeInner(at, n) {\n      var this$1 = this;\n\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this$1.lines[i];\n        this$1.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n\n      this.lines.splice(at, n);\n    },\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function collapse(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function insertInner(at, lines, height) {\n      var this$1 = this;\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n\n      for (var i = 0; i < lines.length; ++i) {\n        lines[i].parent = this$1;\n      }\n    },\n    // Used to iterate over a part of the tree.\n    iterN: function iterN(at, n, op) {\n      var this$1 = this;\n\n      for (var e = at + n; at < e; ++at) {\n        if (op(this$1.lines[at])) {\n          return true;\n        }\n      }\n    }\n  };\n\n  function BranchChunk(children) {\n    var this$1 = this;\n    this.children = children;\n    var size = 0,\n        height = 0;\n\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize();\n      height += ch.height;\n      ch.parent = this$1;\n    }\n\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function chunkSize() {\n      return this.size;\n    },\n    removeInner: function removeInner(at, n) {\n      var this$1 = this;\n      this.size -= n;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i],\n            sz = child.chunkSize();\n\n        if (at < sz) {\n          var rm = Math.min(n, sz - at),\n              oldHeight = child.height;\n          child.removeInner(at, rm);\n          this$1.height -= oldHeight - child.height;\n\n          if (sz == rm) {\n            this$1.children.splice(i--, 1);\n            child.parent = null;\n          }\n\n          if ((n -= rm) == 0) {\n            break;\n          }\n\n          at = 0;\n        } else {\n          at -= sz;\n        }\n      } // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n\n\n      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function collapse(lines) {\n      var this$1 = this;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        this$1.children[i].collapse(lines);\n      }\n    },\n    insertInner: function insertInner(at, lines, height) {\n      var this$1 = this;\n      this.size += lines.length;\n      this.height += height;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i],\n            sz = child.chunkSize();\n\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this$1.children.splice(++i, 0, leaf);\n              leaf.parent = this$1;\n            }\n\n            child.lines = child.lines.slice(0, remaining);\n            this$1.maybeSpill();\n          }\n\n          break;\n        }\n\n        at -= sz;\n      }\n    },\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function maybeSpill() {\n      if (this.children.length <= 10) {\n        return;\n      }\n\n      var me = this;\n\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n\n        if (!me.parent) {\n          // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n\n      me.parent.maybeSpill();\n    },\n    iterN: function iterN(at, n, op) {\n      var this$1 = this;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i],\n            sz = child.chunkSize();\n\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n\n          if (child.iterN(at, used, op)) {\n            return true;\n          }\n\n          if ((n -= used) == 0) {\n            break;\n          }\n\n          at = 0;\n        } else {\n          at -= sz;\n        }\n      }\n    }\n  }; // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function LineWidget(doc, node, options) {\n    var this$1 = this;\n\n    if (options) {\n      for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n          this$1[opt] = options[opt];\n        }\n      }\n    }\n\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n    var this$1 = this;\n    var cm = this.doc.cm,\n        ws = this.line.widgets,\n        line = this.line,\n        no = lineNo(line);\n\n    if (no == null || !ws) {\n      return;\n    }\n\n    for (var i = 0; i < ws.length; ++i) {\n      if (ws[i] == this$1) {\n        ws.splice(i--, 1);\n      }\n    }\n\n    if (!ws.length) {\n      line.widgets = null;\n    }\n\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n    var this$1 = this;\n    var oldH = this.height,\n        cm = this.doc.cm,\n        line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n\n    if (!diff) {\n      return;\n    }\n\n    if (!lineIsHidden(this.doc, line)) {\n      updateLineHeight(line, line.height + diff);\n    }\n\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (_heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {\n      addToScrollTop(cm, diff);\n    }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n\n    if (cm && widget.noHScroll) {\n      cm.display.alignWidgets = true;\n    }\n\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n\n      if (widget.insertAt == null) {\n        widgets.push(widget);\n      } else {\n        widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      }\n\n      widget.line = line;\n\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = _heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n\n        if (aboveVisible) {\n          addToScrollTop(cm, widget.height);\n        }\n\n        cm.curOp.forceUpdate = true;\n      }\n\n      return true;\n    });\n\n    if (cm) {\n      signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n    }\n\n    return widget;\n  } // TEXTMARKERS\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n\n\n  var nextMarkerId = 0;\n\n  var TextMarker = function TextMarker(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  }; // Clear the marker.\n\n\n  TextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n    if (this.explicitlyCleared) {\n      return;\n    }\n\n    var cm = this.doc.cm,\n        withOp = cm && !cm.curOp;\n\n    if (withOp) {\n      _startOperation(cm);\n    }\n\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n\n      if (found) {\n        signalLater(this, \"clear\", found.from, found.to);\n      }\n    }\n\n    var min = null,\n        max = null;\n\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n\n      if (cm && !this$1.collapsed) {\n        regLineChange(cm, lineNo(line), \"text\");\n      } else if (cm) {\n        if (span.to != null) {\n          max = lineNo(line);\n        }\n\n        if (span.from != null) {\n          min = lineNo(line);\n        }\n      }\n\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n\n      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm) {\n        updateLineHeight(line, textHeight(cm.display));\n      }\n    }\n\n    if (cm && this.collapsed && !cm.options.lineWrapping) {\n      for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n        var visual = visualLine(this$1.lines[i$1]),\n            len = lineLength(visual);\n\n        if (len > cm.display.maxLineLength) {\n          cm.display.maxLine = visual;\n          cm.display.maxLineLength = len;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n\n    if (min != null && cm && this.collapsed) {\n      regChange(cm, min, max + 1);\n    }\n\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n\n      if (cm) {\n        reCheckSelection(cm.doc);\n      }\n    }\n\n    if (cm) {\n      signalLater(cm, \"markerCleared\", cm, this, min, max);\n    }\n\n    if (withOp) {\n      _endOperation(cm);\n    }\n\n    if (this.parent) {\n      this.parent.clear();\n    }\n  }; // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n\n\n  TextMarker.prototype.find = function (side, lineObj) {\n    var this$1 = this;\n\n    if (side == null && this.type == \"bookmark\") {\n      side = 1;\n    }\n\n    var from, to;\n\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n\n        if (side == -1) {\n          return from;\n        }\n      }\n\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n\n        if (side == 1) {\n          return to;\n        }\n      }\n    }\n\n    return from && {\n      from: from,\n      to: to\n    };\n  }; // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n\n\n  TextMarker.prototype.changed = function () {\n    var this$1 = this;\n    var pos = this.find(-1, true),\n        widget = this,\n        cm = this.doc.cm;\n\n    if (!pos || !cm) {\n      return;\n    }\n\n    runInOp(cm, function () {\n      var line = pos.line,\n          lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n\n      cm.curOp.updateMaxLine = true;\n\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n\n        if (dHeight) {\n          updateLineHeight(line, line.height + dHeight);\n        }\n      }\n\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n      }\n    }\n\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  eventMixin(TextMarker); // Create a marker, wire it up to the right lines, and\n\n  function _markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) {\n      return markTextShared(doc, from, to, options, type);\n    } // Ensure we are in an operation.\n\n\n    if (doc.cm && !doc.cm.curOp) {\n      return operation(doc.cm, _markText)(doc, from, to, options, type);\n    }\n\n    var marker = new TextMarker(doc, type),\n        diff = cmp(from, to);\n\n    if (options) {\n      copyObj(options, marker, false);\n    } // Don't connect empty markers unless clearWhenEmpty is false\n\n\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {\n      return marker;\n    }\n\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n\n      if (!options.handleMouseEvents) {\n        marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n      }\n\n      if (options.insertLeft) {\n        marker.widgetNode.insertLeft = true;\n      }\n    }\n\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      }\n\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory) {\n      addChangeToHistory(doc, {\n        from: from,\n        to: to,\n        origin: \"markText\"\n      }, doc.sel, NaN);\n    }\n\n    var curLine = from.line,\n        cm = doc.cm,\n        updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {\n        updateMaxLine = true;\n      }\n\n      if (marker.collapsed && curLine != from.line) {\n        updateLineHeight(line, 0);\n      }\n\n      addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));\n      ++curLine;\n    }); // lineIsHidden depends on the presence of the spans, so needs a second pass\n\n    if (marker.collapsed) {\n      doc.iter(from.line, to.line + 1, function (line) {\n        if (lineIsHidden(doc, line)) {\n          updateLineHeight(line, 0);\n        }\n      });\n    }\n\n    if (marker.clearOnEnter) {\n      on(marker, \"beforeCursorEnter\", function () {\n        return marker.clear();\n      });\n    }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n\n      if (doc.history.done.length || doc.history.undone.length) {\n        doc.clearHistory();\n      }\n    }\n\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) {\n        cm.curOp.updateMaxLine = true;\n      }\n\n      if (marker.collapsed) {\n        regChange(cm, from.line, to.line + 1);\n      } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {\n        for (var i = from.line; i <= to.line; i++) {\n          regLineChange(cm, i, \"text\");\n        }\n      }\n\n      if (marker.atomic) {\n        reCheckSelection(cm.doc);\n      }\n\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n\n    return marker;\n  } // SHARED TEXTMARKERS\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n\n\n  var SharedTextMarker = function SharedTextMarker(markers, primary) {\n    var this$1 = this;\n    this.markers = markers;\n    this.primary = primary;\n\n    for (var i = 0; i < markers.length; ++i) {\n      markers[i].parent = this$1;\n    }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n    if (this.explicitlyCleared) {\n      return;\n    }\n\n    this.explicitlyCleared = true;\n\n    for (var i = 0; i < this.markers.length; ++i) {\n      this$1.markers[i].clear();\n    }\n\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj);\n  };\n\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [_markText(doc, from, to, options, type)],\n        primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) {\n        options.widgetNode = widget.cloneNode(true);\n      }\n\n      markers.push(_markText(doc, _clipPos(doc, from), _clipPos(doc, to), options, type));\n\n      for (var i = 0; i < doc.linked.length; ++i) {\n        if (doc.linked[i].isParent) {\n          return;\n        }\n      }\n\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {\n      return m.parent;\n    });\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i],\n          pos = marker.find();\n      var mFrom = doc.clipPos(pos.from),\n          mTo = doc.clipPos(pos.to);\n\n      if (cmp(mFrom, mTo)) {\n        var subMark = _markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function loop(i) {\n      var marker = markers[i],\n          linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) {\n        return linked.push(d);\n      });\n\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) {\n      loop(i);\n    }\n  }\n\n  var nextDocId = 0;\n\n  var Doc = function Doc(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) {\n      return new Doc(text, mode, firstLine, lineSep, direction);\n    }\n\n    if (firstLine == null) {\n      firstLine = 0;\n    }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = direction == \"rtl\" ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") {\n      text = this.splitLines(text);\n    }\n\n    updateDoc(this, {\n      from: start,\n      to: start,\n      text: text\n    });\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function iter(from, to, op) {\n      if (op) {\n        this.iterN(from - this.first, to - from, op);\n      } else {\n        this.iterN(this.first, this.first + this.size, from);\n      }\n    },\n    // Non-public interface for adding and removing lines.\n    insert: function insert(at, lines) {\n      var height = 0;\n\n      for (var i = 0; i < lines.length; ++i) {\n        height += lines[i].height;\n      }\n\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function remove(at, n) {\n      this.removeInner(at - this.first, n);\n    },\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n    getValue: function getValue(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n\n      if (lineSep === false) {\n        return lines;\n      }\n\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    setValue: docMethodOp(function (code) {\n      var top = Pos(this.first, 0),\n          last = this.first + this.size - 1;\n      makeChange(this, {\n        from: top,\n        to: Pos(last, getLine(this, last).text.length),\n        text: this.splitLines(code),\n        origin: \"setValue\",\n        full: true\n      }, true);\n\n      if (this.cm) {\n        scrollToCoords(this.cm, 0, 0);\n      }\n\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function replaceRange(code, from, to, origin) {\n      from = _clipPos(this, from);\n      to = to ? _clipPos(this, to) : from;\n\n      _replaceRange(this, code, from, to, origin);\n    },\n    getRange: function getRange(from, to, lineSep) {\n      var lines = getBetween(this, _clipPos(this, from), _clipPos(this, to));\n\n      if (lineSep === false) {\n        return lines;\n      }\n\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    getLine: function getLine(line) {\n      var l = this.getLineHandle(line);\n      return l && l.text;\n    },\n    getLineHandle: function getLineHandle(line) {\n      if (isLine(this, line)) {\n        return getLine(this, line);\n      }\n    },\n    getLineNumber: function getLineNumber(line) {\n      return lineNo(line);\n    },\n    getLineHandleVisualStart: function getLineHandleVisualStart(line) {\n      if (typeof line == \"number\") {\n        line = getLine(this, line);\n      }\n\n      return visualLine(line);\n    },\n    lineCount: function lineCount() {\n      return this.size;\n    },\n    firstLine: function firstLine() {\n      return this.first;\n    },\n    lastLine: function lastLine() {\n      return this.first + this.size - 1;\n    },\n    clipPos: function clipPos(pos) {\n      return _clipPos(this, pos);\n    },\n    getCursor: function getCursor(start) {\n      var range$$1 = this.sel.primary(),\n          pos;\n\n      if (start == null || start == \"head\") {\n        pos = range$$1.head;\n      } else if (start == \"anchor\") {\n        pos = range$$1.anchor;\n      } else if (start == \"end\" || start == \"to\" || start === false) {\n        pos = range$$1.to();\n      } else {\n        pos = range$$1.from();\n      }\n\n      return pos;\n    },\n    listSelections: function listSelections() {\n      return this.sel.ranges;\n    },\n    somethingSelected: function somethingSelected() {\n      return this.sel.somethingSelected();\n    },\n    setCursor: docMethodOp(function (line, ch, options) {\n      setSimpleSelection(this, _clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function (anchor, head, options) {\n      setSimpleSelection(this, _clipPos(this, anchor), _clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function (head, other, options) {\n      extendSelection(this, _clipPos(this, head), other && _clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function (heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function (f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function (ranges, primary, options) {\n      var this$1 = this;\n\n      if (!ranges.length) {\n        return;\n      }\n\n      var out = [];\n\n      for (var i = 0; i < ranges.length; i++) {\n        out[i] = new Range(_clipPos(this$1, ranges[i].anchor), _clipPos(this$1, ranges[i].head));\n      }\n\n      if (primary == null) {\n        primary = Math.min(ranges.length - 1, this.sel.primIndex);\n      }\n\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function (anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(_clipPos(this, anchor), _clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n    getSelection: function getSelection(lineSep) {\n      var this$1 = this;\n      var ranges = this.sel.ranges,\n          lines;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n\n      if (lineSep === false) {\n        return lines;\n      } else {\n        return lines.join(lineSep || this.lineSeparator());\n      }\n    },\n    getSelections: function getSelections(lineSep) {\n      var this$1 = this;\n      var parts = [],\n          ranges = this.sel.ranges;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n\n        if (lineSep !== false) {\n          sel = sel.join(lineSep || this$1.lineSeparator());\n        }\n\n        parts[i] = sel;\n      }\n\n      return parts;\n    },\n    replaceSelection: function replaceSelection(code, collapse, origin) {\n      var dup = [];\n\n      for (var i = 0; i < this.sel.ranges.length; i++) {\n        dup[i] = code;\n      }\n\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function (code, collapse, origin) {\n      var this$1 = this;\n      var changes = [],\n          sel = this.sel;\n\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range$$1 = sel.ranges[i];\n        changes[i] = {\n          from: range$$1.from(),\n          to: range$$1.to(),\n          text: this$1.splitLines(code[i]),\n          origin: origin\n        };\n      }\n\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {\n        makeChange(this$1, changes[i$1]);\n      }\n\n      if (newSel) {\n        setSelectionReplaceHistory(this, newSel);\n      } else if (this.cm) {\n        ensureCursorVisible(this.cm);\n      }\n    }),\n    undo: docMethodOp(function () {\n      makeChangeFromHistory(this, \"undo\");\n    }),\n    redo: docMethodOp(function () {\n      makeChangeFromHistory(this, \"redo\");\n    }),\n    undoSelection: docMethodOp(function () {\n      makeChangeFromHistory(this, \"undo\", true);\n    }),\n    redoSelection: docMethodOp(function () {\n      makeChangeFromHistory(this, \"redo\", true);\n    }),\n    setExtending: function setExtending(val) {\n      this.extend = val;\n    },\n    getExtending: function getExtending() {\n      return this.extend;\n    },\n    historySize: function historySize() {\n      var hist = this.history,\n          done = 0,\n          undone = 0;\n\n      for (var i = 0; i < hist.done.length; i++) {\n        if (!hist.done[i].ranges) {\n          ++done;\n        }\n      }\n\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {\n        if (!hist.undone[i$1].ranges) {\n          ++undone;\n        }\n      }\n\n      return {\n        undo: done,\n        redo: undone\n      };\n    },\n    clearHistory: function clearHistory() {\n      this.history = new History(this.history.maxGeneration);\n    },\n    markClean: function markClean() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function changeGeneration(forceSplit) {\n      if (forceSplit) {\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n      }\n\n      return this.history.generation;\n    },\n    isClean: function isClean(gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n    getHistory: function getHistory() {\n      return {\n        done: copyHistoryArray(this.history.done),\n        undone: copyHistoryArray(this.history.undone)\n      };\n    },\n    setHistory: function setHistory(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n    setGutterMarker: docMethodOp(function (line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n\n        if (!value && isEmpty(markers)) {\n          line.gutterMarkers = null;\n        }\n\n        return true;\n      });\n    }),\n    clearGutter: docMethodOp(function (gutterID) {\n      var this$1 = this;\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n\n            if (isEmpty(line.gutterMarkers)) {\n              line.gutterMarkers = null;\n            }\n\n            return true;\n          });\n        }\n      });\n    }),\n    lineInfo: function lineInfo(line) {\n      var n;\n\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) {\n          return null;\n        }\n\n        n = line;\n        line = getLine(this, line);\n\n        if (!line) {\n          return null;\n        }\n      } else {\n        n = lineNo(line);\n\n        if (n == null) {\n          return null;\n        }\n      }\n\n      return {\n        line: n,\n        handle: line,\n        text: line.text,\n        gutterMarkers: line.gutterMarkers,\n        textClass: line.textClass,\n        bgClass: line.bgClass,\n        wrapClass: line.wrapClass,\n        widgets: line.widgets\n      };\n    },\n    addLineClass: docMethodOp(function (handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\n        if (!line[prop]) {\n          line[prop] = cls;\n        } else if (classTest(cls).test(line[prop])) {\n          return false;\n        } else {\n          line[prop] += \" \" + cls;\n        }\n\n        return true;\n      });\n    }),\n    removeLineClass: docMethodOp(function (handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n\n        if (!cur) {\n          return false;\n        } else if (cls == null) {\n          line[prop] = null;\n        } else {\n          var found = cur.match(classTest(cls));\n\n          if (!found) {\n            return false;\n          }\n\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n\n        return true;\n      });\n    }),\n    addLineWidget: docMethodOp(function (handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n    removeLineWidget: function removeLineWidget(widget) {\n      widget.clear();\n    },\n    markText: function markText(from, to, options) {\n      return _markText(this, _clipPos(this, from), _clipPos(this, to), options, options && options.type || \"range\");\n    },\n    setBookmark: function setBookmark(pos, options) {\n      var realOpts = {\n        replacedWith: options && (options.nodeType == null ? options.widget : options),\n        insertLeft: options && options.insertLeft,\n        clearWhenEmpty: false,\n        shared: options && options.shared,\n        handleMouseEvents: options && options.handleMouseEvents\n      };\n      pos = _clipPos(this, pos);\n      return _markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function findMarksAt(pos) {\n      pos = _clipPos(this, pos);\n      var markers = [],\n          spans = getLine(this, pos.line).markedSpans;\n\n      if (spans) {\n        for (var i = 0; i < spans.length; ++i) {\n          var span = spans[i];\n\n          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {\n            markers.push(span.marker.parent || span.marker);\n          }\n        }\n      }\n\n      return markers;\n    },\n    findMarks: function findMarks(from, to, filter) {\n      from = _clipPos(this, from);\n      to = _clipPos(this, to);\n      var found = [],\n          lineNo$$1 = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n\n        if (spans) {\n          for (var i = 0; i < spans.length; i++) {\n            var span = spans[i];\n\n            if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to || span.from == null && lineNo$$1 != from.line || span.from != null && lineNo$$1 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {\n              found.push(span.marker.parent || span.marker);\n            }\n          }\n        }\n\n        ++lineNo$$1;\n      });\n      return found;\n    },\n    getAllMarks: function getAllMarks() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n\n        if (sps) {\n          for (var i = 0; i < sps.length; ++i) {\n            if (sps[i].from != null) {\n              markers.push(sps[i].marker);\n            }\n          }\n        }\n      });\n      return markers;\n    },\n    posFromIndex: function posFromIndex(off) {\n      var ch,\n          lineNo$$1 = this.first,\n          sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n\n        if (sz > off) {\n          ch = off;\n          return true;\n        }\n\n        off -= sz;\n        ++lineNo$$1;\n      });\n      return _clipPos(this, Pos(lineNo$$1, ch));\n    },\n    indexFromPos: function indexFromPos(coords) {\n      coords = _clipPos(this, coords);\n      var index = coords.ch;\n\n      if (coords.line < this.first || coords.ch < 0) {\n        return 0;\n      }\n\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) {\n        // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index;\n    },\n    copy: function copy(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop;\n      doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n\n      return doc;\n    },\n    linkedDoc: function linkedDoc(options) {\n      if (!options) {\n        options = {};\n      }\n\n      var from = this.first,\n          to = this.first + this.size;\n\n      if (options.from != null && options.from > from) {\n        from = options.from;\n      }\n\n      if (options.to != null && options.to < to) {\n        to = options.to;\n      }\n\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n\n      if (options.sharedHist) {\n        copy.history = this.history;\n      }\n\n      (this.linked || (this.linked = [])).push({\n        doc: copy,\n        sharedHist: options.sharedHist\n      });\n      copy.linked = [{\n        doc: this,\n        isParent: true,\n        sharedHist: options.sharedHist\n      }];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy;\n    },\n    unlinkDoc: function unlinkDoc(other) {\n      var this$1 = this;\n\n      if (other instanceof CodeMirror) {\n        other = other.doc;\n      }\n\n      if (this.linked) {\n        for (var i = 0; i < this.linked.length; ++i) {\n          var link = this$1.linked[i];\n\n          if (link.doc != other) {\n            continue;\n          }\n\n          this$1.linked.splice(i, 1);\n          other.unlinkDoc(this$1);\n          detachSharedMarkers(findSharedMarkers(this$1));\n          break;\n        }\n      } // If the histories were shared, split them again\n\n\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) {\n          return splitIds.push(doc.id);\n        }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function iterLinkedDocs(f) {\n      linkedDocs(this, f);\n    },\n    getMode: function getMode() {\n      return this.mode;\n    },\n    getEditor: function getEditor() {\n      return this.cm;\n    },\n    splitLines: function splitLines(str) {\n      if (this.lineSep) {\n        return str.split(this.lineSep);\n      }\n\n      return splitLinesAuto(str);\n    },\n    lineSeparator: function lineSeparator() {\n      return this.lineSep || \"\\n\";\n    },\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") {\n        dir = \"ltr\";\n      }\n\n      if (dir == this.direction) {\n        return;\n      }\n\n      this.direction = dir;\n      this.iter(function (line) {\n        return line.order = null;\n      });\n\n      if (this.cm) {\n        directionChanged(this.cm);\n      }\n    })\n  }); // Public alias.\n\n  Doc.prototype.eachLine = Doc.prototype.iter; // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n      return;\n    }\n\n    e_preventDefault(e);\n\n    if (ie) {\n      lastDrop = +new Date();\n    }\n\n    var pos = posFromMouse(cm, e, true),\n        files = e.dataTransfer.files;\n\n    if (!pos || cm.isReadOnly()) {\n      return;\n    } // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n\n\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length,\n          text = Array(n),\n          read = 0;\n\n      var loadFile = function loadFile(file, i) {\n        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n          return;\n        }\n\n        var reader = new FileReader();\n        reader.onload = operation(cm, function () {\n          var content = reader.result;\n\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n            content = \"\";\n          }\n\n          text[i] = content;\n\n          if (++read == n) {\n            pos = _clipPos(cm.doc, pos);\n            var change = {\n              from: pos,\n              to: pos,\n              text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n              origin: \"paste\"\n            };\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n\n      for (var i = 0; i < n; ++i) {\n        loadFile(files[i], i);\n      }\n    } else {\n      // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e); // Ensure the editor is re-focused\n\n        setTimeout(function () {\n          return cm.display.input.focus();\n        }, 20);\n        return;\n      }\n\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n\n        if (text$1) {\n          var selected;\n\n          if (cm.state.draggingText && !cm.state.draggingText.copy) {\n            selected = cm.listSelections();\n          }\n\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n\n          if (selected) {\n            for (var i$1 = 0; i$1 < selected.length; ++i$1) {\n              _replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\");\n            }\n          }\n\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      } catch (e) {}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {\n      e_stop(e);\n      return;\n    }\n\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n      return;\n    }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\"; // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img); // Force a relayout, or Opera won't use our image for some obscure reason\n\n        img._top = img.offsetTop;\n      }\n\n      e.dataTransfer.setDragImage(img, 0, 0);\n\n      if (presto) {\n        img.parentNode.removeChild(img);\n      }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n\n    if (!pos) {\n      return;\n    }\n\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  } // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) {\n      return;\n    }\n\n    var byClass = document.getElementsByClassName(\"CodeMirror\"),\n        editors = [];\n\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n\n      if (cm) {\n        editors.push(cm);\n      }\n    }\n\n    if (editors.length) {\n      editors[0].operation(function () {\n        for (var i = 0; i < editors.length; i++) {\n          f(editors[i]);\n        }\n      });\n    }\n  }\n\n  var globalsRegistered = false;\n\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) {\n      return;\n    }\n\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) {\n        resizeTimer = setTimeout(function () {\n          resizeTimer = null;\n          forEachCodeMirror(onResize);\n        }, 100);\n      }\n    }); // When the window loses focus, we want to show the editor as blurred\n\n    on(window, \"blur\", function () {\n      return forEachCodeMirror(onBlur);\n    });\n  } // Called when the window resizes\n\n\n  function onResize(cm) {\n    var d = cm.display; // Might be a text scaling operation, clear size caches.\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\",\n    8: \"Backspace\",\n    9: \"Tab\",\n    13: \"Enter\",\n    16: \"Shift\",\n    17: \"Ctrl\",\n    18: \"Alt\",\n    19: \"Pause\",\n    20: \"CapsLock\",\n    27: \"Esc\",\n    32: \"Space\",\n    33: \"PageUp\",\n    34: \"PageDown\",\n    35: \"End\",\n    36: \"Home\",\n    37: \"Left\",\n    38: \"Up\",\n    39: \"Right\",\n    40: \"Down\",\n    44: \"PrintScrn\",\n    45: \"Insert\",\n    46: \"Delete\",\n    59: \";\",\n    61: \"=\",\n    91: \"Mod\",\n    92: \"Mod\",\n    93: \"Mod\",\n    106: \"*\",\n    107: \"=\",\n    109: \"-\",\n    110: \".\",\n    111: \"/\",\n    145: \"ScrollLock\",\n    173: \"-\",\n    186: \";\",\n    187: \"=\",\n    188: \",\",\n    189: \"-\",\n    190: \".\",\n    191: \"/\",\n    192: \"`\",\n    219: \"[\",\n    220: \"\\\\\",\n    221: \"]\",\n    222: \"'\",\n    63232: \"Up\",\n    63233: \"Down\",\n    63234: \"Left\",\n    63235: \"Right\",\n    63272: \"Delete\",\n    63273: \"Home\",\n    63275: \"End\",\n    63276: \"PageUp\",\n    63277: \"PageDown\",\n    63302: \"Insert\"\n  }; // Number keys\n\n  for (var i = 0; i < 10; i++) {\n    keyNames[i + 48] = keyNames[i + 96] = String(i);\n  } // Alphabetic keys\n\n\n  for (var i$1 = 65; i$1 <= 90; i$1++) {\n    keyNames[i$1] = String.fromCharCode(i$1);\n  } // Function keys\n\n\n  for (var i$2 = 1; i$2 <= 12; i$2++) {\n    keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2;\n  }\n\n  var keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\",\n    \"Right\": \"goCharRight\",\n    \"Up\": \"goLineUp\",\n    \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\",\n    \"Home\": \"goLineStartSmart\",\n    \"PageUp\": \"goPageUp\",\n    \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\",\n    \"Backspace\": \"delCharBefore\",\n    \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\",\n    \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  }; // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\",\n    \"Ctrl-D\": \"deleteLine\",\n    \"Ctrl-Z\": \"undo\",\n    \"Shift-Ctrl-Z\": \"redo\",\n    \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\",\n    \"Ctrl-End\": \"goDocEnd\",\n    \"Ctrl-Up\": \"goLineUp\",\n    \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\",\n    \"Ctrl-Right\": \"goGroupRight\",\n    \"Alt-Left\": \"goLineStart\",\n    \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Delete\": \"delGroupAfter\",\n    \"Ctrl-S\": \"save\",\n    \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\",\n    \"Shift-Ctrl-G\": \"findPrev\",\n    \"Shift-Ctrl-F\": \"replace\",\n    \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\",\n    \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\",\n    \"Shift-Ctrl-U\": \"redoSelection\",\n    \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  }; // Very basic readline/emacs-style bindings, which are standard on Mac.\n\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\",\n    \"Ctrl-B\": \"goCharLeft\",\n    \"Ctrl-P\": \"goLineUp\",\n    \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\",\n    \"Alt-B\": \"goWordLeft\",\n    \"Ctrl-A\": \"goLineStart\",\n    \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\",\n    \"Shift-Ctrl-V\": \"goPageUp\",\n    \"Ctrl-D\": \"delCharAfter\",\n    \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\",\n    \"Alt-Backspace\": \"delWordBefore\",\n    \"Ctrl-K\": \"killLine\",\n    \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\",\n    \"Cmd-D\": \"deleteLine\",\n    \"Cmd-Z\": \"undo\",\n    \"Shift-Cmd-Z\": \"redo\",\n    \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\",\n    \"Cmd-Up\": \"goDocStart\",\n    \"Cmd-End\": \"goDocEnd\",\n    \"Cmd-Down\": \"goDocEnd\",\n    \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\",\n    \"Cmd-Left\": \"goLineLeft\",\n    \"Cmd-Right\": \"goLineRight\",\n    \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\",\n    \"Alt-Delete\": \"delGroupAfter\",\n    \"Cmd-S\": \"save\",\n    \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\",\n    \"Shift-Cmd-G\": \"findPrev\",\n    \"Cmd-Alt-F\": \"replace\",\n    \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\",\n    \"Cmd-]\": \"indentMore\",\n    \"Cmd-Backspace\": \"delWrappedLineLeft\",\n    \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\",\n    \"Shift-Cmd-U\": \"redoSelection\",\n    \"Ctrl-Up\": \"goDocStart\",\n    \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault; // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n\n      if (/^(cmd|meta|m)$/i.test(mod)) {\n        cmd = true;\n      } else if (/^a(lt)?$/i.test(mod)) {\n        alt = true;\n      } else if (/^(c|ctrl|control)$/i.test(mod)) {\n        ctrl = true;\n      } else if (/^s(hift)?$/i.test(mod)) {\n        shift = true;\n      } else {\n        throw new Error(\"Unrecognized modifier name: \" + mod);\n      }\n    }\n\n    if (alt) {\n      name = \"Alt-\" + name;\n    }\n\n    if (ctrl) {\n      name = \"Ctrl-\" + name;\n    }\n\n    if (cmd) {\n      name = \"Cmd-\" + name;\n    }\n\n    if (shift) {\n      name = \"Shift-\" + name;\n    }\n\n    return name;\n  } // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n\n\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n\n    for (var keyname in keymap) {\n      if (keymap.hasOwnProperty(keyname)) {\n        var value = keymap[keyname];\n\n        if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {\n          continue;\n        }\n\n        if (value == \"...\") {\n          delete keymap[keyname];\n          continue;\n        }\n\n        var keys = map(keyname.split(\" \"), normalizeKeyName);\n\n        for (var i = 0; i < keys.length; i++) {\n          var val = void 0,\n              name = void 0;\n\n          if (i == keys.length - 1) {\n            name = keys.join(\" \");\n            val = value;\n          } else {\n            name = keys.slice(0, i + 1).join(\" \");\n            val = \"...\";\n          }\n\n          var prev = copy[name];\n\n          if (!prev) {\n            copy[name] = val;\n          } else if (prev != val) {\n            throw new Error(\"Inconsistent bindings for \" + name);\n          }\n        }\n\n        delete keymap[keyname];\n      }\n    }\n\n    for (var prop in copy) {\n      keymap[prop] = copy[prop];\n    }\n\n    return keymap;\n  }\n\n  function lookupKey(key, map$$1, handle, context) {\n    map$$1 = getKeyMap(map$$1);\n    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n\n    if (found === false) {\n      return \"nothing\";\n    }\n\n    if (found === \"...\") {\n      return \"multi\";\n    }\n\n    if (found != null && handle(found)) {\n      return \"handled\";\n    }\n\n    if (map$$1.fallthrough) {\n      if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\") {\n        return lookupKey(key, map$$1.fallthrough, handle, context);\n      }\n\n      for (var i = 0; i < map$$1.fallthrough.length; i++) {\n        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n\n        if (result) {\n          return result;\n        }\n      }\n    }\n  } // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n\n\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n\n    if (event.altKey && base != \"Alt\") {\n      name = \"Alt-\" + name;\n    }\n\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") {\n      name = \"Ctrl-\" + name;\n    }\n\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") {\n      name = \"Cmd-\" + name;\n    }\n\n    if (!noShift && event.shiftKey && base != \"Shift\") {\n      name = \"Shift-\" + name;\n    }\n\n    return name;\n  } // Look up the name of a key as indicated by an event object.\n\n\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) {\n      return false;\n    }\n\n    var name = keyNames[event.keyCode];\n\n    if (name == null || event.altGraphKey) {\n      return false;\n    } // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n\n\n    if (event.keyCode == 3 && event.code) {\n      name = event.code;\n    }\n\n    return addModifierNames(name, event, noShift);\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val;\n  } // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n\n\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges,\n        kill = []; // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break;\n        }\n      }\n\n      kill.push(toKill);\n    } // Next, remove those actual ranges.\n\n\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--) {\n        _replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n      }\n\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\");\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      var order = getOrder(lineObj, cm.doc.direction);\n\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = dir < 0 == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch; // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) {\n            return measureCharPrepared(cm, prep, ch).top == targetTop;\n          }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);\n\n          if (sticky == \"before\") {\n            ch = moveCharLogically(lineObj, ch, 1);\n          }\n        } else {\n          ch = dir < 0 ? part.to : part.from;\n        }\n\n        return new Pos(lineNo, ch, sticky);\n      }\n    }\n\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\");\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n\n    if (!bidi) {\n      return moveLogically(line, start, dir);\n    }\n\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky),\n        part = bidi[partPos];\n\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir);\n    }\n\n    var mv = function mv(pos, dir) {\n      return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);\n    };\n\n    var prep;\n\n    var getWrappedLineExtent = function getWrappedLineExtent(ch) {\n      if (!cm.options.lineWrapping) {\n        return {\n          begin: 0,\n          end: line.text.length\n        };\n      }\n\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch);\n    };\n\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = part.level == 1 == dir < 0;\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky);\n      }\n    } // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n\n    var searchInVisualLine = function searchInVisualLine(partPos, dir, wrappedLineExtent) {\n      var getRes = function getRes(ch, moveInStorageOrder) {\n        return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), \"before\") : new Pos(start.line, ch, \"after\");\n      };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = dir > 0 == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n\n        if (part.from <= ch && ch < part.to) {\n          return getRes(ch, moveInStorageOrder);\n        }\n\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {\n          return getRes(ch, moveInStorageOrder);\n        }\n      }\n    }; // Case 3a: Look for other bidi parts on the same visual line\n\n\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n\n    if (res) {\n      return res;\n    } // Case 3b: Look for other bidi parts on the next visual line\n\n\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n\n      if (res) {\n        return res;\n      }\n    } // Case 4: Nowhere to move\n\n\n    return null;\n  } // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n\n\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function singleSelection(cm) {\n      return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n    },\n    killLine: function killLine(cm) {\n      return deleteNearSelection(cm, function (range) {\n        if (range.empty()) {\n          var len = getLine(cm.doc, range.head.line).text.length;\n\n          if (range.head.ch == len && range.head.line < cm.lastLine()) {\n            return {\n              from: range.head,\n              to: Pos(range.head.line + 1, 0)\n            };\n          } else {\n            return {\n              from: range.head,\n              to: Pos(range.head.line, len)\n            };\n          }\n        } else {\n          return {\n            from: range.from(),\n            to: range.to()\n          };\n        }\n      });\n    },\n    deleteLine: function deleteLine(cm) {\n      return deleteNearSelection(cm, function (range) {\n        return {\n          from: Pos(range.from().line, 0),\n          to: _clipPos(cm.doc, Pos(range.to().line + 1, 0))\n        };\n      });\n    },\n    delLineLeft: function delLineLeft(cm) {\n      return deleteNearSelection(cm, function (range) {\n        return {\n          from: Pos(range.from().line, 0),\n          to: range.from()\n        };\n      });\n    },\n    delWrappedLineLeft: function delWrappedLineLeft(cm) {\n      return deleteNearSelection(cm, function (range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var leftPos = cm.coordsChar({\n          left: 0,\n          top: top\n        }, \"div\");\n        return {\n          from: leftPos,\n          to: range.from()\n        };\n      });\n    },\n    delWrappedLineRight: function delWrappedLineRight(cm) {\n      return deleteNearSelection(cm, function (range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var rightPos = cm.coordsChar({\n          left: cm.display.lineDiv.offsetWidth + 100,\n          top: top\n        }, \"div\");\n        return {\n          from: range.from(),\n          to: rightPos\n        };\n      });\n    },\n    undo: function undo(cm) {\n      return cm.undo();\n    },\n    redo: function redo(cm) {\n      return cm.redo();\n    },\n    undoSelection: function undoSelection(cm) {\n      return cm.undoSelection();\n    },\n    redoSelection: function redoSelection(cm) {\n      return cm.redoSelection();\n    },\n    goDocStart: function goDocStart(cm) {\n      return cm.extendSelection(Pos(cm.firstLine(), 0));\n    },\n    goDocEnd: function goDocEnd(cm) {\n      return cm.extendSelection(Pos(cm.lastLine()));\n    },\n    goLineStart: function goLineStart(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        return lineStart(cm, range.head.line);\n      }, {\n        origin: \"+move\",\n        bias: 1\n      });\n    },\n    goLineStartSmart: function goLineStartSmart(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        return lineStartSmart(cm, range.head);\n      }, {\n        origin: \"+move\",\n        bias: 1\n      });\n    },\n    goLineEnd: function goLineEnd(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        return lineEnd(cm, range.head.line);\n      }, {\n        origin: \"+move\",\n        bias: -1\n      });\n    },\n    goLineRight: function goLineRight(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        var top = cm.cursorCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({\n          left: cm.display.lineDiv.offsetWidth + 100,\n          top: top\n        }, \"div\");\n      }, sel_move);\n    },\n    goLineLeft: function goLineLeft(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        var top = cm.cursorCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({\n          left: 0,\n          top: top\n        }, \"div\");\n      }, sel_move);\n    },\n    goLineLeftSmart: function goLineLeftSmart(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        var top = cm.cursorCoords(range.head, \"div\").top + 5;\n        var pos = cm.coordsChar({\n          left: 0,\n          top: top\n        }, \"div\");\n\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) {\n          return lineStartSmart(cm, range.head);\n        }\n\n        return pos;\n      }, sel_move);\n    },\n    goLineUp: function goLineUp(cm) {\n      return cm.moveV(-1, \"line\");\n    },\n    goLineDown: function goLineDown(cm) {\n      return cm.moveV(1, \"line\");\n    },\n    goPageUp: function goPageUp(cm) {\n      return cm.moveV(-1, \"page\");\n    },\n    goPageDown: function goPageDown(cm) {\n      return cm.moveV(1, \"page\");\n    },\n    goCharLeft: function goCharLeft(cm) {\n      return cm.moveH(-1, \"char\");\n    },\n    goCharRight: function goCharRight(cm) {\n      return cm.moveH(1, \"char\");\n    },\n    goColumnLeft: function goColumnLeft(cm) {\n      return cm.moveH(-1, \"column\");\n    },\n    goColumnRight: function goColumnRight(cm) {\n      return cm.moveH(1, \"column\");\n    },\n    goWordLeft: function goWordLeft(cm) {\n      return cm.moveH(-1, \"word\");\n    },\n    goGroupRight: function goGroupRight(cm) {\n      return cm.moveH(1, \"group\");\n    },\n    goGroupLeft: function goGroupLeft(cm) {\n      return cm.moveH(-1, \"group\");\n    },\n    goWordRight: function goWordRight(cm) {\n      return cm.moveH(1, \"word\");\n    },\n    delCharBefore: function delCharBefore(cm) {\n      return cm.deleteH(-1, \"char\");\n    },\n    delCharAfter: function delCharAfter(cm) {\n      return cm.deleteH(1, \"char\");\n    },\n    delWordBefore: function delWordBefore(cm) {\n      return cm.deleteH(-1, \"word\");\n    },\n    delWordAfter: function delWordAfter(cm) {\n      return cm.deleteH(1, \"word\");\n    },\n    delGroupBefore: function delGroupBefore(cm) {\n      return cm.deleteH(-1, \"group\");\n    },\n    delGroupAfter: function delGroupAfter(cm) {\n      return cm.deleteH(1, \"group\");\n    },\n    indentAuto: function indentAuto(cm) {\n      return cm.indentSelection(\"smart\");\n    },\n    indentMore: function indentMore(cm) {\n      return cm.indentSelection(\"add\");\n    },\n    indentLess: function indentLess(cm) {\n      return cm.indentSelection(\"subtract\");\n    },\n    insertTab: function insertTab(cm) {\n      return cm.replaceSelection(\"\\t\");\n    },\n    insertSoftTab: function insertSoftTab(cm) {\n      var spaces = [],\n          ranges = cm.listSelections(),\n          tabSize = cm.options.tabSize;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function defaultTab(cm) {\n      if (cm.somethingSelected()) {\n        cm.indentSelection(\"add\");\n      } else {\n        cm.execCommand(\"insertTab\");\n      }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function transposeChars(cm) {\n      return runInOp(cm, function () {\n        var ranges = cm.listSelections(),\n            newSel = [];\n\n        for (var i = 0; i < ranges.length; i++) {\n          if (!ranges[i].empty()) {\n            continue;\n          }\n\n          var cur = ranges[i].head,\n              line = getLine(cm.doc, cur.line).text;\n\n          if (line) {\n            if (cur.ch == line.length) {\n              cur = new Pos(cur.line, cur.ch - 1);\n            }\n\n            if (cur.ch > 0) {\n              cur = new Pos(cur.line, cur.ch + 1);\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n            } else if (cur.line > cm.doc.first) {\n              var prev = getLine(cm.doc, cur.line - 1).text;\n\n              if (prev) {\n                cur = new Pos(cur.line, 1);\n                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n              }\n            }\n          }\n\n          newSel.push(new Range(cur, cur));\n        }\n\n        cm.setSelections(newSel);\n      });\n    },\n    newlineAndIndent: function newlineAndIndent(cm) {\n      return runInOp(cm, function () {\n        var sels = cm.listSelections();\n\n        for (var i = sels.length - 1; i >= 0; i--) {\n          cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\");\n        }\n\n        sels = cm.listSelections();\n\n        for (var i$1 = 0; i$1 < sels.length; i$1++) {\n          cm.indentLine(sels[i$1].from().line, null, true);\n        }\n\n        ensureCursorVisible(cm);\n      });\n    },\n    openLine: function openLine(cm) {\n      return cm.replaceSelection(\"\\n\", \"start\");\n    },\n    toggleOverwrite: function toggleOverwrite(cm) {\n      return cm.toggleOverwrite();\n    }\n  };\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n\n    if (visual != line) {\n      lineN = lineNo(visual);\n    }\n\n    return endOfLine(true, cm, visual, lineN, 1);\n  }\n\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n\n    if (visual != line) {\n      lineN = lineNo(visual);\n    }\n\n    return endOfLine(true, cm, line, lineN, -1);\n  }\n\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);\n    }\n\n    return start;\n  } // Run a handler that was bound to a key.\n\n\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n\n      if (!bound) {\n        return false;\n      }\n    } // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n\n\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift,\n        done = false;\n\n    try {\n      if (cm.isReadOnly()) {\n        cm.state.suppressEdits = true;\n      }\n\n      if (dropShift) {\n        cm.display.shift = false;\n      }\n\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n\n    return done;\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);\n  } // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n\n  var stopSeq = new Delayed();\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n\n    if (seq) {\n      if (isModifierKey(name)) {\n        return \"handled\";\n      }\n\n      if (/\\'$/.test(name)) {\n        cm.state.keySeq = null;\n      } else {\n        stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        });\n      }\n\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) {\n        return true;\n      }\n    }\n\n    return dispatchKeyInner(cm, name, e, handle);\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\") {\n      cm.state.keySeq = name;\n    }\n\n    if (result == \"handled\") {\n      signalLater(cm, \"keyHandled\", cm, name, e);\n    }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result;\n  } // Handle a key from the keydown event.\n\n\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n\n    if (!name) {\n      return false;\n    }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) {\n        return doHandleBinding(cm, b, true);\n      }) || dispatchKey(cm, name, e, function (b) {\n        if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion) {\n          return doHandleBinding(cm, b);\n        }\n      });\n    } else {\n      return dispatchKey(cm, name, e, function (b) {\n        return doHandleBinding(cm, b);\n      });\n    }\n  } // Handle a key from the keypress event\n\n\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) {\n      return doHandleBinding(cm, b, true);\n    });\n  }\n\n  var lastStoppedKey = null;\n\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n\n    if (signalDOMEvent(cm, e)) {\n      return;\n    } // IE does strange things with escape.\n\n\n    if (ie && ie_version < 11 && e.keyCode == 27) {\n      e.returnValue = false;\n    }\n\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n\n    if (presto) {\n      lastStoppedKey = handled ? code : null; // Opera has no cut event... we try to at least catch the key combo\n\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {\n        cm.replaceSelection(\"\", null, \"cut\");\n      }\n    } // Turn mouse into crosshair when Alt is held on Mac.\n\n\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className)) {\n      showCrossHair(cm);\n    }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) {\n      this.doc.sel.shift = false;\n    }\n\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {\n      return;\n    }\n\n    var keyCode = e.keyCode,\n        charCode = e.charCode;\n\n    if (presto && keyCode == lastStoppedKey) {\n      lastStoppedKey = null;\n      e_preventDefault(e);\n      return;\n    }\n\n    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {\n      return;\n    }\n\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode); // Some browsers fire keypress events for backspace\n\n    if (ch == \"\\x08\") {\n      return;\n    }\n\n    if (handleCharBinding(cm, e, ch)) {\n      return;\n    }\n\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function PastClick(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;\n  };\n\n  var lastClick, lastDoubleClick;\n\n  function clickRepeat(pos, button) {\n    var now = +new Date();\n\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\";\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\";\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\";\n    }\n  } // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n\n\n  function onMouseDown(e) {\n    var cm = this,\n        display = cm.display;\n\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {\n      return;\n    }\n\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () {\n          return display.scroller.draggable = true;\n        }, 100);\n      }\n\n      return;\n    }\n\n    if (clickInGutter(cm, e)) {\n      return;\n    }\n\n    var pos = posFromMouse(cm, e),\n        button = e_button(e),\n        repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus(); // #3261: make sure, that we're not starting a second selection\n\n    if (button == 1 && cm.state.selectingText) {\n      cm.state.selectingText(e);\n    }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) {\n      return;\n    }\n\n    if (button == 1) {\n      if (pos) {\n        leftButtonDown(cm, pos, repeat, e);\n      } else if (e_target(e) == display.scroller) {\n        e_preventDefault(e);\n      }\n    } else if (button == 2) {\n      if (pos) {\n        extendSelection(cm.doc, pos);\n      }\n\n      setTimeout(function () {\n        return display.input.focus();\n      }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) {\n        cm.display.input.onContextMenu(e);\n      } else {\n        delayBlurEvent(cm);\n      }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n\n    if (repeat == \"double\") {\n      name = \"Double\" + name;\n    } else if (repeat == \"triple\") {\n      name = \"Triple\" + name;\n    }\n\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n    return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") {\n        bound = commands[bound];\n      }\n\n      if (!bound) {\n        return false;\n      }\n\n      var done = false;\n\n      try {\n        if (cm.isReadOnly()) {\n          cm.state.suppressEdits = true;\n        }\n\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n\n      return done;\n    });\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n\n    if (value.extend == null || cm.doc.extend) {\n      value.extend = cm.doc.extend || event.shiftKey;\n    }\n\n    if (value.addNew == null) {\n      value.addNew = mac ? event.metaKey : event.ctrlKey;\n    }\n\n    if (value.moveOnDrag == null) {\n      value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);\n    }\n\n    return value;\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) {\n      setTimeout(bind(ensureFocus, cm), 0);\n    } else {\n      cm.curOp.focus = activeElt();\n    }\n\n    var behavior = configureMouse(cm, repeat, event);\n    var sel = cm.doc.sel,\n        contained;\n\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == \"single\" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {\n      leftButtonStartDrag(cm, event, pos, behavior);\n    } else {\n      leftButtonSelect(cm, event, pos, behavior);\n    }\n  } // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n\n\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display,\n        moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) {\n        display.scroller.draggable = false;\n      }\n\n      cm.state.draggingText = false;\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n\n      if (!moved) {\n        e_preventDefault(e);\n\n        if (!behavior.addNew) {\n          extendSelection(cm.doc, pos, null, null, behavior.extend);\n        } // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n\n\n        if (webkit || ie && ie_version == 9) {\n          setTimeout(function () {\n            display.wrapper.ownerDocument.body.focus();\n            display.input.focus();\n          }, 20);\n        } else {\n          display.input.focus();\n        }\n      }\n    });\n\n    var mouseMove = function mouseMove(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n\n    var dragStart = function dragStart() {\n      return moved = true;\n    }; // Let the drag handler handle this.\n\n\n    if (webkit) {\n      display.scroller.draggable = true;\n    }\n\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag; // IE's approach to draggable\n\n    if (display.scroller.dragDrop) {\n      display.scroller.dragDrop();\n    }\n\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n    delayBlurEvent(cm);\n    setTimeout(function () {\n      return display.input.focus();\n    }, 20);\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") {\n      return new Range(pos, pos);\n    }\n\n    if (unit == \"word\") {\n      return cm.findWordAt(pos);\n    }\n\n    if (unit == \"line\") {\n      return new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));\n    }\n\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to);\n  } // Normal selection, as opposed to text dragging.\n\n\n  function leftButtonSelect(cm, event, start, behavior) {\n    var display = cm.display,\n        doc = cm.doc;\n    e_preventDefault(event);\n    var ourRange,\n        ourIndex,\n        startSel = doc.sel,\n        ranges = startSel.ranges;\n\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n\n      if (ourIndex > -1) {\n        ourRange = ranges[ourIndex];\n      } else {\n        ourRange = new Range(start, start);\n      }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) {\n        ourRange = new Range(start, start);\n      }\n\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range$$1 = rangeForUnit(cm, start, behavior.unit);\n\n      if (behavior.extend) {\n        ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend);\n      } else {\n        ourRange = range$$1;\n      }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), {\n        scroll: false,\n        origin: \"*mouse\"\n      });\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {\n        scroll: false,\n        origin: \"*mouse\"\n      });\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) {\n        return;\n      }\n\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [],\n            tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol),\n            right = Math.max(startCol, posCol);\n\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {\n          var text = getLine(doc, line).text,\n              leftPos = findColumn(text, left, tabSize);\n\n          if (left == right) {\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n          } else if (text.length > leftPos) {\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n          }\n        }\n\n        if (!ranges.length) {\n          ranges.push(new Range(start, start));\n        }\n\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {\n          origin: \"*mouse\",\n          scroll: false\n        });\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor,\n            head;\n\n        if (cmp(range$$1.anchor, anchor) > 0) {\n          head = range$$1.head;\n          anchor = minPos(oldRange.from(), range$$1.anchor);\n        } else {\n          head = range$$1.anchor;\n          anchor = maxPos(oldRange.to(), range$$1.head);\n        }\n\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(_clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect(); // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n\n      if (!cur) {\n        return;\n      }\n\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n\n        if (cur.line >= visible.to || cur.line < visible.from) {\n          setTimeout(operation(cm, function () {\n            if (counter == curCount) {\n              extend(e);\n            }\n          }), 150);\n        }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n\n        if (outside) {\n          setTimeout(operation(cm, function () {\n            if (counter != curCount) {\n              return;\n            }\n\n            display.scroller.scrollTop += outside;\n            extend(e);\n          }), 50);\n        }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity; // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) {\n        done(e);\n      } else {\n        extend(e);\n      }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  } // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n\n\n  function bidiSimplify(cm, range$$1) {\n    var anchor = range$$1.anchor;\n    var head = range$$1.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {\n      return range$$1;\n    }\n\n    var order = getOrder(anchorLine);\n\n    if (!order) {\n      return range$$1;\n    }\n\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky),\n        part = order[index];\n\n    if (part.from != anchor.ch && part.to != anchor.ch) {\n      return range$$1;\n    }\n\n    var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);\n\n    if (boundary == 0 || boundary == order.length) {\n      return range$$1;\n    } // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n\n\n    var leftSide;\n\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n\n      if (headIndex == boundary - 1 || headIndex == boundary) {\n        leftSide = dir < 0;\n      } else {\n        leftSide = dir > 0;\n      }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to,\n        sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head);\n  } // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n\n\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try {\n        mX = e.clientX;\n        mY = e.clientY;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {\n      return false;\n    }\n\n    if (prevent) {\n      e_preventDefault(e);\n    }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) {\n      return e_defaultPrevented(e);\n    }\n\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = _lineAtHeight(cm.doc, mY);\n\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true);\n  } // CONTEXT MENU HANDLING\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n\n\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {\n      return;\n    }\n\n    if (signalDOMEvent(cm, e, \"contextmenu\")) {\n      return;\n    }\n\n    if (!captureRightClick) {\n      cm.display.input.onContextMenu(e);\n    }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) {\n      return false;\n    }\n\n    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") + cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {\n    toString: function toString() {\n      return \"CodeMirror.Init\";\n    }\n  };\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n\n      if (handle) {\n        optionHandlers[name] = notOnInit ? function (cm, val, old) {\n          if (old != Init) {\n            handle(cm, val, old);\n          }\n        } : handle;\n      }\n    }\n\n    CodeMirror.defineOption = option; // Passed to option handlers when there is no old value.\n\n    CodeMirror.Init = Init; // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n\n    option(\"value\", \"\", function (cm, val) {\n      return cm.setValue(val);\n    }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n\n      if (!val) {\n        return;\n      }\n\n      var newBreaks = [],\n          lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n\n          if (found == -1) {\n            break;\n          }\n\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n\n        lineNo++;\n      });\n\n      for (var i = newBreaks.length - 1; i >= 0; i--) {\n        _replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));\n      }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n\n      if (old != Init) {\n        cm.refresh();\n      }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) {\n      return cm.refresh();\n    }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) {\n      return cm.getInputField().spellcheck = val;\n    }, true);\n    option(\"autocorrect\", false, function (cm, val) {\n      return cm.getInputField().autocorrect = val;\n    }, true);\n    option(\"autocapitalize\", false, function (cm, val) {\n      return cm.getInputField().autocapitalize = val;\n    }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n\n      if (prev && prev.detach) {\n        prev.detach(cm, next);\n      }\n\n      if (next.attach) {\n        next.attach(cm, prev || null);\n      }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) {\n      return updateScrollbars(cm);\n    }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, updateGutters, true);\n    option(\"lineNumberFormatter\", function (integer) {\n      return integer;\n    }, updateGutters, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n\n      cm.display.input.readOnlyChanged(val);\n    });\n    option(\"disableInput\", false, function (cm, val) {\n      if (!val) {\n        cm.display.input.reset();\n      }\n    }, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) {\n      return cm.doc.history.undoDepth = val;\n    });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) {\n      return cm.refresh();\n    }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) {\n        cm.display.input.resetPosition();\n      }\n    });\n    option(\"tabindex\", null, function (cm, val) {\n      return cm.display.input.getField().tabIndex = val || \"\";\n    });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) {\n      return cm.doc.setDirection(val);\n    }, true);\n    option(\"phrases\", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () {\n      return updateScrollbars(cm);\n    }, 100);\n  } // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) {\n      return new CodeMirror(place, options);\n    }\n\n    this.options = options = options ? copyObj(options) : {}; // Determine effective options based on given values and defaults.\n\n    copyObj(defaults, options, false);\n    var doc = options.value;\n\n    if (typeof doc == \"string\") {\n      doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);\n    } else if (options.mode) {\n      doc.modeOption = options.mode;\n    }\n\n    this.doc = doc;\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n\n    if (options.lineWrapping) {\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n    }\n\n    initScrollbars(this);\n    this.state = {\n      keyMaps: [],\n      // stores maps added by addKeyMap\n      overlays: [],\n      // highlighting overlays, as added by addOverlay\n      modeGen: 0,\n      // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false,\n      // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1,\n      cutIncoming: -1,\n      // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(),\n      // stores highlight worker timeout\n      keySeq: null,\n      // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) {\n      display.input.focus();\n    } // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n\n\n    if (ie && ie_version < 11) {\n      setTimeout(function () {\n        return this$1.display.input.reset(true);\n      }, 20);\n    }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    _startOperation(this);\n\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if (options.autofocus && !mobile || this.hasFocus()) {\n      setTimeout(bind(onFocus, this), 20);\n    } else {\n      onBlur(this);\n    }\n\n    for (var opt in optionHandlers) {\n      if (optionHandlers.hasOwnProperty(opt)) {\n        optionHandlers[opt](this$1, options[opt], Init);\n      }\n    }\n\n    maybeUpdateLineNumberWidth(this);\n\n    if (options.finishInit) {\n      options.finishInit(this);\n    }\n\n    for (var i = 0; i < initHooks.length; ++i) {\n      initHooks[i](this$1);\n    }\n\n    _endOperation(this); // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n\n\n    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\") {\n      display.lineDiv.style.textRendering = \"auto\";\n    }\n  } // The default configuration options.\n\n\n  CodeMirror.defaults = defaults; // Functions to run when options are changed.\n\n  CodeMirror.optionHandlers = optionHandlers; // Attach the necessary event handlers when initializing the editor\n\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown)); // Older IE's will not fire a second mousedown for a double click\n\n    if (ie && ie_version < 11) {\n      on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) {\n          return;\n        }\n\n        var pos = posFromMouse(cm, e);\n\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {\n          return;\n        }\n\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      }));\n    } else {\n      on(d.scroller, \"dblclick\", function (e) {\n        return signalDOMEvent(cm, e) || e_preventDefault(e);\n      });\n    } // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n\n\n    on(d.scroller, \"contextmenu\", function (e) {\n      return onContextMenu(cm, e);\n    }); // Used to suppress mouse event handling when a touch happens\n\n    var touchFinished,\n        prevTouch = {\n      end: 0\n    };\n\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () {\n          return d.activeTouch = null;\n        }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date();\n      }\n    }\n\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) {\n        return false;\n      }\n\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1;\n    }\n\n    function farAway(touch, other) {\n      if (other.left == null) {\n        return true;\n      }\n\n      var dx = other.left - touch.left,\n          dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20;\n    }\n\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date();\n        d.activeTouch = {\n          start: now,\n          moved: false,\n          prev: now - prevTouch.end <= 300 ? prevTouch : null\n        };\n\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) {\n        d.activeTouch.moved = true;\n      }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n\n      if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"),\n            range;\n\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          {\n            range = new Range(pos, pos);\n          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          {\n            range = cm.findWordAt(pos);\n          } else // Triple tap\n          {\n            range = new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));\n          }\n\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch); // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    }); // Listen to wheel events in order to try and update the viewport on time.\n\n    on(d.scroller, \"mousewheel\", function (e) {\n      return onScrollWheel(cm, e);\n    });\n    on(d.scroller, \"DOMMouseScroll\", function (e) {\n      return onScrollWheel(cm, e);\n    }); // Prevent wrapper from ever scrolling\n\n    on(d.wrapper, \"scroll\", function () {\n      return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;\n    });\n    d.dragFunctions = {\n      enter: function enter(e) {\n        if (!signalDOMEvent(cm, e)) {\n          e_stop(e);\n        }\n      },\n      over: function over(e) {\n        if (!signalDOMEvent(cm, e)) {\n          onDragOver(cm, e);\n          e_stop(e);\n        }\n      },\n      start: function start(e) {\n        return onDragStart(cm, e);\n      },\n      drop: operation(cm, onDrop),\n      leave: function leave(e) {\n        if (!signalDOMEvent(cm, e)) {\n          clearDragCursor(cm);\n        }\n      }\n    };\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) {\n      return onKeyUp.call(cm, e);\n    });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) {\n      return onFocus(cm, e);\n    });\n    on(inp, \"blur\", function (e) {\n      return onBlur(cm, e);\n    });\n  }\n\n  var initHooks = [];\n\n  CodeMirror.defineInitHook = function (f) {\n    return initHooks.push(f);\n  }; // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n\n\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc,\n        state;\n\n    if (how == null) {\n      how = \"add\";\n    }\n\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) {\n        how = \"prev\";\n      } else {\n        state = getContextBefore(cm, n).state;\n      }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n),\n        curSpace = countColumn(line.text, null, tabSize);\n\n    if (line.stateAfter) {\n      line.stateAfter = null;\n    }\n\n    var curSpaceString = line.text.match(/^\\s*/)[0],\n        indentation;\n\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) {\n          return;\n        }\n\n        how = \"prev\";\n      }\n    }\n\n    if (how == \"prev\") {\n      if (n > doc.first) {\n        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);\n      } else {\n        indentation = 0;\n      }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n\n    indentation = Math.max(0, indentation);\n    var indentString = \"\",\n        pos = 0;\n\n    if (cm.options.indentWithTabs) {\n      for (var i = Math.floor(indentation / tabSize); i; --i) {\n        pos += tabSize;\n        indentString += \"\\t\";\n      }\n    }\n\n    if (pos < indentation) {\n      indentString += spaceStr(indentation - pos);\n    }\n\n    if (indentString != curSpaceString) {\n      _replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n\n      line.stateAfter = null;\n      return true;\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break;\n        }\n      }\n    }\n  } // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n\n\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n\n    if (!sel) {\n      sel = doc.sel;\n    }\n\n    var recent = +new Date() - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted),\n        multiPaste = null; // When pasting N lines into N selections, insert one line per selection\n\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n\n          for (var i = 0; i < lastCopied.text.length; i++) {\n            multiPaste.push(doc.splitLines(lastCopied.text[i]));\n          }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) {\n          return [l];\n        });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput; // Normal behavior is to insert the new text into every selection\n\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range$$1 = sel.ranges[i$1];\n      var from = range$$1.from(),\n          to = range$$1.to();\n\n      if (range$$1.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          {\n            from = Pos(from.line, from.ch - deleted);\n          } else if (cm.state.overwrite && !paste) // Handle overwrite\n          {\n            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted) {\n          from = to = Pos(from.line, 0);\n        }\n      }\n\n      var changeEvent = {\n        from: from,\n        to: to,\n        text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n        origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")\n      };\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n\n    if (inserted && !paste) {\n      triggerElectric(cm, inserted);\n    }\n\n    ensureCursorVisible(cm);\n\n    if (cm.curOp.updateInput < 2) {\n      cm.curOp.updateInput = updateInput;\n    }\n\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n\n    if (pasted) {\n      e.preventDefault();\n\n      if (!cm.isReadOnly() && !cm.options.disableInput) {\n        runInOp(cm, function () {\n          return applyTextInput(cm, pasted, 0, null, \"paste\");\n        });\n      }\n\n      return true;\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) {\n      return;\n    }\n\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range$$1 = sel.ranges[i];\n\n      if (range$$1.head.ch > 100 || i && sel.ranges[i - 1].head.line == range$$1.head.line) {\n        continue;\n      }\n\n      var mode = cm.getModeAt(range$$1.head);\n      var indented = false;\n\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++) {\n          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range$$1.head.line, \"smart\");\n            break;\n          }\n        }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch))) {\n          indented = indentLine(cm, range$$1.head.line, \"smart\");\n        }\n      }\n\n      if (indented) {\n        signalLater(cm, \"electricInput\", cm, range$$1.head.line);\n      }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [],\n        ranges = [];\n\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {\n        anchor: Pos(line, 0),\n        head: Pos(line + 1, 0)\n      };\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n\n    return {\n      text: text,\n      ranges: ranges\n    };\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", autocorrect ? \"\" : \"off\");\n    field.setAttribute(\"autocapitalize\", autocapitalize ? \"\" : \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\"); // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n\n    if (webkit) {\n      te.style.width = \"1000px\";\n    } else {\n      te.setAttribute(\"wrap\", \"off\");\n    } // If border: 0; -- iOS fails to open keyboard (issue #1287)\n\n\n    if (ios) {\n      te.style.border = \"1px solid black\";\n    }\n\n    disableBrowserMagic(te);\n    return div;\n  } // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n    var helpers = CodeMirror.helpers = {};\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function focus() {\n        window.focus();\n        this.display.input.focus();\n      },\n      setOption: function setOption(option, value) {\n        var options = this.options,\n            old = options[option];\n\n        if (options[option] == value && option != \"mode\") {\n          return;\n        }\n\n        options[option] = value;\n\n        if (optionHandlers.hasOwnProperty(option)) {\n          operation(this, optionHandlers[option])(this, value, old);\n        }\n\n        signal(this, \"optionChange\", this, option);\n      },\n      getOption: function getOption(option) {\n        return this.options[option];\n      },\n      getDoc: function getDoc() {\n        return this.doc;\n      },\n      addKeyMap: function addKeyMap(map$$1, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n      },\n      removeKeyMap: function removeKeyMap(map$$1) {\n        var maps = this.state.keyMaps;\n\n        for (var i = 0; i < maps.length; ++i) {\n          if (maps[i] == map$$1 || maps[i].name == map$$1) {\n            maps.splice(i, 1);\n            return true;\n          }\n        }\n      },\n      addOverlay: methodOp(function (spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n\n        if (mode.startState) {\n          throw new Error(\"Overlays may not be stateful.\");\n        }\n\n        insertSorted(this.state.overlays, {\n          mode: mode,\n          modeSpec: spec,\n          opaque: options && options.opaque,\n          priority: options && options.priority || 0\n        }, function (overlay) {\n          return overlay.priority;\n        });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function (spec) {\n        var this$1 = this;\n        var overlays = this.state.overlays;\n\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this$1.state.modeGen++;\n            regChange(this$1);\n            return;\n          }\n        }\n      }),\n      indentLine: methodOp(function (n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) {\n            dir = this.options.smartIndent ? \"smart\" : \"prev\";\n          } else {\n            dir = dir ? \"add\" : \"subtract\";\n          }\n        }\n\n        if (isLine(this.doc, n)) {\n          indentLine(this, n, dir, aggressive);\n        }\n      }),\n      indentSelection: methodOp(function (how) {\n        var this$1 = this;\n        var ranges = this.doc.sel.ranges,\n            end = -1;\n\n        for (var i = 0; i < ranges.length; i++) {\n          var range$$1 = ranges[i];\n\n          if (!range$$1.empty()) {\n            var from = range$$1.from(),\n                to = range$$1.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n\n            for (var j = start; j < end; ++j) {\n              indentLine(this$1, j, how);\n            }\n\n            var newRanges = this$1.doc.sel.ranges;\n\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {\n              replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n            }\n          } else if (range$$1.head.line > end) {\n            indentLine(this$1, range$$1.head.line, how, true);\n            end = range$$1.head.line;\n\n            if (i == this$1.doc.sel.primIndex) {\n              ensureCursorVisible(this$1);\n            }\n          }\n        }\n      }),\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function getTokenAt(pos, precise) {\n        return takeToken(this, pos, precise);\n      },\n      getLineTokens: function getLineTokens(line, precise) {\n        return takeToken(this, Pos(line), precise, true);\n      },\n      getTokenTypeAt: function getTokenTypeAt(pos) {\n        pos = _clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0,\n            after = (styles.length - 1) / 2,\n            ch = pos.ch;\n        var type;\n\n        if (ch == 0) {\n          type = styles[2];\n        } else {\n          for (;;) {\n            var mid = before + after >> 1;\n\n            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {\n              after = mid;\n            } else if (styles[mid * 2 + 1] < ch) {\n              before = mid + 1;\n            } else {\n              type = styles[mid * 2 + 2];\n              break;\n            }\n          }\n        }\n\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n      },\n      getModeAt: function getModeAt(pos) {\n        var mode = this.doc.mode;\n\n        if (!mode.innerMode) {\n          return mode;\n        }\n\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n      },\n      getHelper: function getHelper(pos, type) {\n        return this.getHelpers(pos, type)[0];\n      },\n      getHelpers: function getHelpers(pos, type) {\n        var this$1 = this;\n        var found = [];\n\n        if (!helpers.hasOwnProperty(type)) {\n          return found;\n        }\n\n        var help = helpers[type],\n            mode = this.getModeAt(pos);\n\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) {\n            found.push(help[mode[type]]);\n          }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n\n            if (val) {\n              found.push(val);\n            }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n\n          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1) {\n            found.push(cur.val);\n          }\n        }\n\n        return found;\n      },\n      getStateAfter: function getStateAfter(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);\n        return getContextBefore(this, line + 1, precise).state;\n      },\n      cursorCoords: function cursorCoords(start, mode) {\n        var pos,\n            range$$1 = this.doc.sel.primary();\n\n        if (start == null) {\n          pos = range$$1.head;\n        } else if (typeof start == \"object\") {\n          pos = _clipPos(this.doc, start);\n        } else {\n          pos = start ? range$$1.from() : range$$1.to();\n        }\n\n        return _cursorCoords(this, pos, mode || \"page\");\n      },\n      charCoords: function charCoords(pos, mode) {\n        return _charCoords(this, _clipPos(this.doc, pos), mode || \"page\");\n      },\n      coordsChar: function coordsChar(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return _coordsChar(this, coords.left, coords.top);\n      },\n      lineAtHeight: function lineAtHeight(height, mode) {\n        height = fromCoordSystem(this, {\n          top: height,\n          left: 0\n        }, mode || \"page\").top;\n        return _lineAtHeight(this.doc, height + this.display.viewOffset);\n      },\n      heightAtLine: function heightAtLine(line, mode, includeWidgets) {\n        var end = false,\n            lineObj;\n\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n\n          if (line < this.doc.first) {\n            line = this.doc.first;\n          } else if (line > last) {\n            line = last;\n            end = true;\n          }\n\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n\n        return intoCoordSystem(this, lineObj, {\n          top: 0,\n          left: 0\n        }, mode || \"page\", includeWidgets || end).top + (end ? this.doc.height - _heightAtLine(lineObj) : 0);\n      },\n      defaultTextHeight: function defaultTextHeight() {\n        return textHeight(this.display);\n      },\n      defaultCharWidth: function defaultCharWidth() {\n        return charWidth(this.display);\n      },\n      getViewport: function getViewport() {\n        return {\n          from: this.display.viewFrom,\n          to: this.display.viewTo\n        };\n      },\n      addWidget: function addWidget(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = _cursorCoords(this, _clipPos(this.doc, pos));\n        var top = pos.bottom,\n            left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n              hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth); // Default to positioning above (if specified and possible); otherwise default to positioning below\n\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {\n            top = pos.top - node.offsetHeight;\n          } else if (pos.bottom + node.offsetHeight <= vspace) {\n            top = pos.bottom;\n          }\n\n          if (left + node.offsetWidth > hspace) {\n            left = hspace - node.offsetWidth;\n          }\n        }\n\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") {\n            left = 0;\n          } else if (horiz == \"middle\") {\n            left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n          }\n\n          node.style.left = left + \"px\";\n        }\n\n        if (scroll) {\n          scrollIntoView(this, {\n            left: left,\n            top: top,\n            right: left + node.offsetWidth,\n            bottom: top + node.offsetHeight\n          });\n        }\n      },\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n      execCommand: function execCommand(cmd) {\n        if (commands.hasOwnProperty(cmd)) {\n          return commands[cmd].call(null, this);\n        }\n      },\n      triggerElectric: methodOp(function (text) {\n        triggerElectric(this, text);\n      }),\n      findPosH: function findPosH(from, amount, unit, visually) {\n        var this$1 = this;\n        var dir = 1;\n\n        if (amount < 0) {\n          dir = -1;\n          amount = -amount;\n        }\n\n        var cur = _clipPos(this.doc, from);\n\n        for (var i = 0; i < amount; ++i) {\n          cur = _findPosH(this$1.doc, cur, dir, unit, visually);\n\n          if (cur.hitSide) {\n            break;\n          }\n        }\n\n        return cur;\n      },\n      moveH: methodOp(function (dir, unit) {\n        var this$1 = this;\n        this.extendSelectionsBy(function (range$$1) {\n          if (this$1.display.shift || this$1.doc.extend || range$$1.empty()) {\n            return _findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually);\n          } else {\n            return dir < 0 ? range$$1.from() : range$$1.to();\n          }\n        }, sel_move);\n      }),\n      deleteH: methodOp(function (dir, unit) {\n        var sel = this.doc.sel,\n            doc = this.doc;\n\n        if (sel.somethingSelected()) {\n          doc.replaceSelection(\"\", null, \"+delete\");\n        } else {\n          deleteNearSelection(this, function (range$$1) {\n            var other = _findPosH(doc, range$$1.head, dir, unit, false);\n\n            return dir < 0 ? {\n              from: other,\n              to: range$$1.head\n            } : {\n              from: range$$1.head,\n              to: other\n            };\n          });\n        }\n      }),\n      findPosV: function findPosV(from, amount, unit, goalColumn) {\n        var this$1 = this;\n        var dir = 1,\n            x = goalColumn;\n\n        if (amount < 0) {\n          dir = -1;\n          amount = -amount;\n        }\n\n        var cur = _clipPos(this.doc, from);\n\n        for (var i = 0; i < amount; ++i) {\n          var coords = _cursorCoords(this$1, cur, \"div\");\n\n          if (x == null) {\n            x = coords.left;\n          } else {\n            coords.left = x;\n          }\n\n          cur = _findPosV(this$1, coords, dir, unit);\n\n          if (cur.hitSide) {\n            break;\n          }\n        }\n\n        return cur;\n      },\n      moveV: methodOp(function (dir, unit) {\n        var this$1 = this;\n        var doc = this.doc,\n            goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range$$1) {\n          if (collapse) {\n            return dir < 0 ? range$$1.from() : range$$1.to();\n          }\n\n          var headPos = _cursorCoords(this$1, range$$1.head, \"div\");\n\n          if (range$$1.goalColumn != null) {\n            headPos.left = range$$1.goalColumn;\n          }\n\n          goals.push(headPos.left);\n\n          var pos = _findPosV(this$1, headPos, dir, unit);\n\n          if (unit == \"page\" && range$$1 == doc.sel.primary()) {\n            addToScrollTop(this$1, _charCoords(this$1, pos, \"div\").top - headPos.top);\n          }\n\n          return pos;\n        }, sel_move);\n\n        if (goals.length) {\n          for (var i = 0; i < doc.sel.ranges.length; i++) {\n            doc.sel.ranges[i].goalColumn = goals[i];\n          }\n        }\n      }),\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function findWordAt(pos) {\n        var doc = this.doc,\n            line = getLine(doc, pos.line).text;\n        var start = pos.ch,\n            end = pos.ch;\n\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n\n          if ((pos.sticky == \"before\" || end == line.length) && start) {\n            --start;\n          } else {\n            ++end;\n          }\n\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper) ? function (ch) {\n            return isWordChar(ch, helper);\n          } : /\\s/.test(startChar) ? function (ch) {\n            return /\\s/.test(ch);\n          } : function (ch) {\n            return !/\\s/.test(ch) && !isWordChar(ch);\n          };\n\n          while (start > 0 && check(line.charAt(start - 1))) {\n            --start;\n          }\n\n          while (end < line.length && check(line.charAt(end))) {\n            ++end;\n          }\n        }\n\n        return new Range(Pos(pos.line, start), Pos(pos.line, end));\n      },\n      toggleOverwrite: function toggleOverwrite(value) {\n        if (value != null && value == this.state.overwrite) {\n          return;\n        }\n\n        if (this.state.overwrite = !this.state.overwrite) {\n          addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n        } else {\n          rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n        }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function hasFocus() {\n        return this.display.input.getField() == activeElt();\n      },\n      isReadOnly: function isReadOnly() {\n        return !!(this.options.readOnly || this.doc.cantEdit);\n      },\n      scrollTo: methodOp(function (x, y) {\n        scrollToCoords(this, x, y);\n      }),\n      getScrollInfo: function getScrollInfo() {\n        var scroller = this.display.scroller;\n        return {\n          left: scroller.scrollLeft,\n          top: scroller.scrollTop,\n          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n          clientHeight: displayHeight(this),\n          clientWidth: displayWidth(this)\n        };\n      },\n      scrollIntoView: methodOp(function (range$$1, margin) {\n        if (range$$1 == null) {\n          range$$1 = {\n            from: this.doc.sel.primary().head,\n            to: null\n          };\n\n          if (margin == null) {\n            margin = this.options.cursorScrollMargin;\n          }\n        } else if (typeof range$$1 == \"number\") {\n          range$$1 = {\n            from: Pos(range$$1, 0),\n            to: null\n          };\n        } else if (range$$1.from == null) {\n          range$$1 = {\n            from: range$$1,\n            to: null\n          };\n        }\n\n        if (!range$$1.to) {\n          range$$1.to = range$$1.from;\n        }\n\n        range$$1.margin = margin || 0;\n\n        if (range$$1.from.line != null) {\n          scrollToRange(this, range$$1);\n        } else {\n          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n        }\n      }),\n      setSize: methodOp(function (width, height) {\n        var this$1 = this;\n\n        var interpret = function interpret(val) {\n          return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n        };\n\n        if (width != null) {\n          this.display.wrapper.style.width = interpret(width);\n        }\n\n        if (height != null) {\n          this.display.wrapper.style.height = interpret(height);\n        }\n\n        if (this.options.lineWrapping) {\n          clearLineMeasurementCache(this);\n        }\n\n        var lineNo$$1 = this.display.viewFrom;\n        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n          if (line.widgets) {\n            for (var i = 0; i < line.widgets.length; i++) {\n              if (line.widgets[i].noHScroll) {\n                regLineChange(this$1, lineNo$$1, \"widget\");\n                break;\n              }\n            }\n          }\n\n          ++lineNo$$1;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n      operation: function operation(f) {\n        return runInOp(this, f);\n      },\n      startOperation: function startOperation() {\n        return _startOperation(this);\n      },\n      endOperation: function endOperation() {\n        return _endOperation(this);\n      },\n      refresh: methodOp(function () {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5) {\n          estimateLineHeights(this);\n        }\n\n        signal(this, \"refresh\", this);\n      }),\n      swapDoc: methodOp(function (doc) {\n        var old = this.doc;\n        old.cm = null; // Cancel the current text selection if any (#5821)\n\n        if (this.state.selectingText) {\n          this.state.selectingText();\n        }\n\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old;\n      }),\n      phrase: function phrase(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;\n      },\n      getInputField: function getInputField() {\n        return this.display.input.getField();\n      },\n      getWrapperElement: function getWrapperElement() {\n        return this.display.wrapper;\n      },\n      getScrollerElement: function getScrollerElement() {\n        return this.display.scroller;\n      },\n      getGutterElement: function getGutterElement() {\n        return this.display.gutters;\n      }\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function (type, name, value) {\n      if (!helpers.hasOwnProperty(type)) {\n        helpers[type] = CodeMirror[type] = {\n          _global: []\n        };\n      }\n\n      helpers[type][name] = value;\n    };\n\n    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n\n      helpers[type]._global.push({\n        pred: predicate,\n        val: value\n      });\n    };\n  } // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n\n\n  function _findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n\n    function findNextLine() {\n      var l = pos.line + dir;\n\n      if (l < doc.first || l >= doc.first + doc.size) {\n        return false;\n      }\n\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l);\n    }\n\n    function moveOnce(boundToLine) {\n      var next;\n\n      if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir);\n        } else {\n          return false;\n        }\n      } else {\n        pos = next;\n      }\n\n      return true;\n    }\n\n    if (unit == \"char\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null,\n          group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) {\n          break;\n        }\n\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\" : group && cur == \"\\n\" ? \"n\" : !group || /\\s/.test(cur) ? null : \"p\";\n\n        if (group && !first && !type) {\n          type = \"s\";\n        }\n\n        if (sawType && sawType != type) {\n          if (dir < 0) {\n            dir = 1;\n            moveOnce();\n            pos.sticky = \"after\";\n          }\n\n          break;\n        }\n\n        if (type) {\n          sawType = type;\n        }\n\n        if (dir > 0 && !moveOnce(!first)) {\n          break;\n        }\n      }\n    }\n\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n\n    if (equalCursorPos(oldPos, result)) {\n      result.hitSide = true;\n    }\n\n    return result;\n  } // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n\n\n  function _findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc,\n        x = pos.left,\n        y;\n\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n\n    var target;\n\n    for (;;) {\n      target = _coordsChar(cm, x, y);\n\n      if (!target.outside) {\n        break;\n      }\n\n      if (dir < 0 ? y <= 0 : y >= doc.height) {\n        target.hitSide = true;\n        break;\n      }\n\n      y += dir * 5;\n    }\n\n    return target;\n  } // CONTENTEDITABLE INPUT STYLE\n\n\n  var ContentEditableInput = function ContentEditableInput(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n    var this$1 = this;\n    var input = this,\n        cm = input.cm;\n    var div = input.div = display.lineDiv;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n    on(div, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n        return;\n      } // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n\n\n      if (ie_version <= 11) {\n        setTimeout(operation(cm, function () {\n          return this$1.updateFromDOM();\n        }), 20);\n      }\n    });\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {\n        data: e.data,\n        done: false\n      };\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) {\n        this$1.composing = {\n          data: e.data,\n          done: false\n        };\n      }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) {\n          this$1.readFromDOMSoon();\n        }\n\n        this$1.composing.done = true;\n      }\n    });\n    on(div, \"touchstart\", function () {\n      return input.forceCompositionEnd();\n    });\n    on(div, \"input\", function () {\n      if (!this$1.composing) {\n        this$1.readFromDOMSoon();\n      }\n    });\n\n    function onCopyCut(e) {\n      if (signalDOMEvent(cm, e)) {\n        return;\n      }\n\n      if (cm.somethingSelected()) {\n        setLastCopied({\n          lineWise: false,\n          text: cm.getSelections()\n        });\n\n        if (e.type == \"cut\") {\n          cm.replaceSelection(\"\", null, \"cut\");\n        }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return;\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({\n          lineWise: true,\n          text: ranges.text\n        });\n\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\"); // iOS exposes the clipboard API, but seems to discard content inserted into it\n\n        e.clipboardData.setData(\"Text\", content);\n\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return;\n        }\n      } // Old-fashioned briefly-focus-a-textarea hack\n\n\n      var kludge = hiddenTextarea(),\n          te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = document.activeElement;\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n\n        if (hadFocus == div) {\n          input.showPrimarySelection();\n        }\n      }, 50);\n    }\n\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = this.cm.state.focused;\n    return result;\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) {\n      return;\n    }\n\n    if (info.focus || takeFocus) {\n      this.showPrimarySelection();\n    }\n\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection();\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(),\n        cm = this.cm,\n        prim = cm.doc.sel.primary();\n    var from = prim.from(),\n        to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return;\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {\n      return;\n    }\n\n    var view = cm.display.view;\n    var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {\n      node: view[0].measure.map[2],\n      offset: 0\n    };\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {\n        node: map$$1[map$$1.length - 1],\n        offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]\n      };\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return;\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0),\n        rng;\n\n    try {\n      rng = range(start.node, start.offset, end.offset, end.node);\n    } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n\n\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n\n      if (old && sel.anchorNode == null) {\n        sel.addRange(old);\n      } else if (gecko) {\n        this.startGracePeriod();\n      }\n    }\n\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n    var this$1 = this;\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n\n      if (this$1.selectionChanged()) {\n        this$1.cm.operation(function () {\n          return this$1.cm.curOp.selectionChanged = true;\n        });\n      }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode;\n    this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode;\n    this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n\n    if (!sel.rangeCount) {\n      return false;\n    }\n\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node);\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor()) {\n        this.showSelection(this.prepareSelection(), true);\n      }\n\n      this.div.focus();\n    }\n  };\n\n  ContentEditableInput.prototype.blur = function () {\n    this.div.blur();\n  };\n\n  ContentEditableInput.prototype.getField = function () {\n    return this.div;\n  };\n\n  ContentEditableInput.prototype.supportsTouch = function () {\n    return true;\n  };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n\n    if (this.selectionInEditor()) {\n      this.pollSelection();\n    } else {\n      runInOp(this.cm, function () {\n        return input.cm.curOp.selectionChanged = true;\n      });\n    }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {\n      return;\n    }\n\n    var sel = this.getSelection(),\n        cm = this.cm; // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n\n    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({\n        type: \"keydown\",\n        keyCode: 8,\n        preventDefault: Math.abs\n      });\n      this.blur();\n      this.focus();\n      return;\n    }\n\n    if (this.composing) {\n      return;\n    }\n\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n\n    if (anchor && head) {\n      runInOp(cm, function () {\n        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n\n        if (anchor.bad || head.bad) {\n          cm.curOp.selectionChanged = true;\n        }\n      });\n    }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm,\n        display = cm.display,\n        sel = cm.doc.sel.primary();\n    var from = sel.from(),\n        to = sel.to();\n\n    if (from.ch == 0 && from.line > cm.firstLine()) {\n      from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);\n    }\n\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {\n      to = Pos(to.line + 1, 0);\n    }\n\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) {\n      return false;\n    }\n\n    var fromIndex, fromLine, fromNode;\n\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) {\n      return false;\n    }\n\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) {\n        newText.pop();\n        oldText.pop();\n        toLine--;\n      } else if (newText[0] == oldText[0]) {\n        newText.shift();\n        oldText.shift();\n        fromLine++;\n      } else {\n        break;\n      }\n    }\n\n    var cutFront = 0,\n        cutEnd = 0;\n    var newTop = newText[0],\n        oldTop = oldText[0],\n        maxCutFront = Math.min(newTop.length, oldTop.length);\n\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {\n      ++cutFront;\n    }\n\n    var newBot = lst(newText),\n        oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));\n\n    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n      ++cutEnd;\n    } // Try to move start of change to start of selection if ambiguous\n\n\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      _replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n\n      return true;\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) {\n      return;\n    }\n\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n    var this$1 = this;\n\n    if (this.readDOMTimeout != null) {\n      return;\n    }\n\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n\n      if (this$1.composing) {\n        if (this$1.composing.done) {\n          this$1.composing = null;\n        } else {\n          return;\n        }\n      }\n\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n    var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent()) {\n      runInOp(this.cm, function () {\n        return regChange(this$1.cm);\n      });\n    }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) {\n      return;\n    }\n\n    e.preventDefault();\n\n    if (!this.cm.isReadOnly()) {\n      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n    }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n\n    if (!view || view.hidden) {\n      return null;\n    }\n\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n    var order = getOrder(line, cm.doc.direction),\n        side = \"left\";\n\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result;\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode) {\n      if (/CodeMirror-gutter-wrapper/.test(scan.className)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function badPos(pos, bad) {\n    if (bad) {\n      pos.bad = true;\n    }\n\n    return pos;\n  }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\",\n        closing = false,\n        lineSep = cm.doc.lineSeparator(),\n        extraLinebreak = false;\n\n    function recognizeMarker(id) {\n      return function (marker) {\n        return marker.id == id;\n      };\n    }\n\n    function close() {\n      if (closing) {\n        text += lineSep;\n\n        if (extraLinebreak) {\n          text += lineSep;\n        }\n\n        closing = extraLinebreak = false;\n      }\n    }\n\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n\n        if (cmText) {\n          addText(cmText);\n          return;\n        }\n\n        var markerID = node.getAttribute(\"cm-marker\"),\n            range$$1;\n\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n\n          if (found.length && (range$$1 = found[0].find(0))) {\n            addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep));\n          }\n\n          return;\n        }\n\n        if (node.getAttribute(\"contenteditable\") == \"false\") {\n          return;\n        }\n\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {\n          return;\n        }\n\n        if (isBlock) {\n          close();\n        }\n\n        for (var i = 0; i < node.childNodes.length; i++) {\n          walk(node.childNodes[i]);\n        }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) {\n          extraLinebreak = true;\n        }\n\n        if (isBlock) {\n          closing = true;\n        }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n\n    for (;;) {\n      walk(from);\n\n      if (from == to) {\n        break;\n      }\n\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n\n    return text;\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n\n      if (!lineNode) {\n        return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n      }\n\n      node = null;\n      offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) {\n          return null;\n        }\n\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {\n          break;\n        }\n      }\n    }\n\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n\n      if (lineView.node == lineNode) {\n        return locateNodeInLineView(lineView, node, offset);\n      }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild,\n        bad = false;\n\n    if (!node || !contains(wrapper, node)) {\n      return badPos(Pos(lineNo(lineView.line), 0), true);\n    }\n\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad);\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null,\n        topNode = node;\n\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n\n      if (offset) {\n        offset = textNode.nodeValue.length;\n      }\n    }\n\n    while (topNode.parentNode != wrapper) {\n      topNode = topNode.parentNode;\n    }\n\n    var measure = lineView.measure,\n        maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map$$1 = i < 0 ? measure.map : maps[i];\n\n        for (var j = 0; j < map$$1.length; j += 3) {\n          var curNode = map$$1[j + 2];\n\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map$$1[j] + offset;\n\n            if (offset < 0 || curNode != textNode) {\n              ch = map$$1[j + (offset ? 1 : 0)];\n            }\n\n            return Pos(line, ch);\n          }\n        }\n      }\n    }\n\n    var found = find(textNode, topNode, offset);\n\n    if (found) {\n      return badPos(found, bad);\n    } // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n\n\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n\n      if (found) {\n        return badPos(Pos(found.line, found.ch - dist), bad);\n      } else {\n        dist += after.textContent.length;\n      }\n    }\n\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n\n      if (found) {\n        return badPos(Pos(found.line, found.ch + dist$1), bad);\n      } else {\n        dist$1 += before.textContent.length;\n      }\n    }\n  } // TEXTAREA INPUT STYLE\n\n\n  var TextareaInput = function TextareaInput(cm) {\n    this.cm = cm; // See input.poll and input.reset\n\n    this.prevInput = \"\"; // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n\n    this.pollingFast = false; // Self-resetting timeout for the poller\n\n    this.polling = new Delayed(); // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n    var this$1 = this;\n    var input = this,\n        cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild); // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n\n    if (ios) {\n      te.style.width = \"0px\";\n    }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) {\n        this$1.hasSelection = null;\n      }\n\n      input.poll();\n    });\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n        return;\n      }\n\n      cm.state.pasteIncoming = +new Date();\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) {\n        return;\n      }\n\n      if (cm.somethingSelected()) {\n        setLastCopied({\n          lineWise: false,\n          text: cm.getSelections()\n        });\n      } else if (!cm.options.lineWiseCopyCut) {\n        return;\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({\n          lineWise: true,\n          text: ranges.text\n        });\n\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n\n      if (e.type == \"cut\") {\n        cm.state.cutIncoming = +new Date();\n      }\n    }\n\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {\n        return;\n      }\n\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date();\n        input.focus();\n        return;\n      } // Pass the `paste` event to the textarea so it's handled by its event listener.\n\n\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    }); // Prevent normal selection in the editor (we handle our own)\n\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) {\n        e_preventDefault(e);\n      }\n    });\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n\n      if (input.composing) {\n        input.composing.range.clear();\n      }\n\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {\n          className: \"CodeMirror-composing\"\n        })\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea(); // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm,\n        display = cm.display,\n        doc = cm.doc;\n    var result = prepareSelection(cm); // Move the hidden textarea near the cursor to prevent scrolling artifacts\n\n    if (cm.options.moveInputWithCursor) {\n      var headPos = _cursorCoords(cm, doc.sel.primary().head, \"div\");\n\n      var wrapOff = display.wrapper.getBoundingClientRect(),\n          lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result;\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm,\n        display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  }; // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n\n\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) {\n      return;\n    }\n\n    var cm = this.cm;\n\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n\n      if (cm.state.focused) {\n        selectInput(this.textarea);\n      }\n\n      if (ie && ie_version >= 9) {\n        this.hasSelection = content;\n      }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n\n      if (ie && ie_version >= 9) {\n        this.hasSelection = null;\n      }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () {\n    return this.textarea;\n  };\n\n  TextareaInput.prototype.supportsTouch = function () {\n    return false;\n  };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n      try {\n        this.textarea.focus();\n      } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n\n    }\n  };\n\n  TextareaInput.prototype.blur = function () {\n    this.textarea.blur();\n  };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () {\n    this.slowPoll();\n  }; // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n\n\n  TextareaInput.prototype.slowPoll = function () {\n    var this$1 = this;\n\n    if (this.pollingFast) {\n      return;\n    }\n\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n\n      if (this$1.cm.state.focused) {\n        this$1.slowPoll();\n      }\n    });\n  }; // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n\n\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false,\n        input = this;\n    input.pollingFast = true;\n\n    function p() {\n      var changed = input.poll();\n\n      if (!changed && !missed) {\n        missed = true;\n        input.polling.set(60, p);\n      } else {\n        input.pollingFast = false;\n        input.slowPoll();\n      }\n    }\n\n    input.polling.set(20, p);\n  }; // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n\n\n  TextareaInput.prototype.poll = function () {\n    var this$1 = this;\n    var cm = this.cm,\n        input = this.textarea,\n        prevInput = this.prevInput; // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n\n    if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {\n      return false;\n    }\n\n    var text = input.value; // If nothing changed, bail.\n\n    if (text == prevInput && !cm.somethingSelected()) {\n      return false;\n    } // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n\n\n    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false;\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n\n      if (first == 0x200b && !prevInput) {\n        prevInput = \"\\u200B\";\n      }\n\n      if (first == 0x21da) {\n        this.reset();\n        return this.cm.execCommand(\"undo\");\n      }\n    } // Find the part of the input that is actually new\n\n\n    var same = 0,\n        l = Math.min(prevInput.length, text.length);\n\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {\n      ++same;\n    }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? \"*compose\" : null); // Don't leave long text in the textarea, since it makes further polling slow\n\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) {\n        input.value = this$1.prevInput = \"\";\n      } else {\n        this$1.prevInput = text;\n      }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"), {\n          className: \"CodeMirror-composing\"\n        });\n      }\n    });\n    return true;\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) {\n      this.pollingFast = false;\n    }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) {\n      this.hasSelection = null;\n    }\n\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this,\n        cm = input.cm,\n        display = cm.display,\n        te = input.textarea;\n\n    if (input.contextMenuPending) {\n      input.contextMenuPending();\n    }\n\n    var pos = posFromMouse(cm, e),\n        scrollPos = display.scroller.scrollTop;\n\n    if (!pos || presto) {\n      return;\n    } // Opera is difficult.\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n\n\n    var reset = cm.options.resetSelectionOnContextMenu;\n\n    if (reset && cm.doc.sel.contains(pos) == -1) {\n      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n    }\n\n    var oldCSS = te.style.cssText,\n        oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n\n    if (webkit) {\n      oldScrollY = window.scrollY;\n    } // Work around Chrome issue (#2712)\n\n\n    display.input.focus();\n\n    if (webkit) {\n      window.scrollTo(null, oldScrollY);\n    }\n\n    display.input.reset(); // Adds \"Select all\" to context menu in FF\n\n    if (!cm.somethingSelected()) {\n      te.value = input.prevInput = \" \";\n    }\n\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll); // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200B\" + (selected ? te.value : \"\");\n        te.value = \"\\u21DA\"; // Used to catch context-menu undo\n\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200B\";\n        te.selectionStart = 1;\n        te.selectionEnd = extval.length; // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n\n    function rehide() {\n      if (input.contextMenuPending != rehide) {\n        return;\n      }\n\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n\n      if (ie && ie_version < 9) {\n        display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n      } // Try to detect the user choosing select-all\n\n\n      if (te.selectionStart != null) {\n        if (!ie || ie && ie_version < 9) {\n          prepareSelectAllHack();\n        }\n\n        var i = 0,\n            poll = function poll() {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == \"\\u200B\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) {\n      prepareSelectAllHack();\n    }\n\n    if (captureRightClick) {\n      e_stop(e);\n\n      var mouseup = function mouseup() {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) {\n      this.reset();\n    }\n\n    this.textarea.disabled = val == \"nocursor\";\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n\n    if (!options.tabindex && textarea.tabIndex) {\n      options.tabindex = textarea.tabIndex;\n    }\n\n    if (!options.placeholder && textarea.placeholder) {\n      options.placeholder = textarea.placeholder;\n    } // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n\n\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea || textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {\n      textarea.value = cm.getValue();\n    }\n\n    var realSubmit;\n\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save); // Deplorable hack to make the submit method do the right thing.\n\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch (e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n\n      cm.getTextArea = function () {\n        return textarea;\n      };\n\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n\n          if (typeof textarea.form.submit == \"function\") {\n            textarea.form.submit = realSubmit;\n          }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) {\n      return textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    return cm;\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  } // EDITOR CONSTRUCTOR\n\n\n  defineOptions(CodeMirror);\n  addEditorMethods(CodeMirror); // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n\n  for (var prop in Doc.prototype) {\n    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {\n      CodeMirror.prototype[prop] = function (method) {\n        return function () {\n          return method.apply(this.doc, arguments);\n        };\n      }(Doc.prototype[prop]);\n    }\n  }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\n    \"textarea\": TextareaInput,\n    \"contenteditable\": ContentEditableInput\n  }; // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n\n  CodeMirror.defineMode = function (name\n  /*, mode, */\n  ) {\n    if (!CodeMirror.defaults.mode && name != \"null\") {\n      CodeMirror.defaults.mode = name;\n    }\n\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME; // Minimal default mode.\n\n  CodeMirror.defineMode(\"null\", function () {\n    return {\n      token: function token(stream) {\n        return stream.skipToEnd();\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\"); // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n  addLegacyProps(CodeMirror);\n  CodeMirror.version = \"5.48.0\";\n  return CodeMirror;\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.modeInfo = [{\n    name: \"APL\",\n    mime: \"text/apl\",\n    mode: \"apl\",\n    ext: [\"dyalog\", \"apl\"]\n  }, {\n    name: \"PGP\",\n    mimes: [\"application/pgp\", \"application/pgp-encrypted\", \"application/pgp-keys\", \"application/pgp-signature\"],\n    mode: \"asciiarmor\",\n    ext: [\"asc\", \"pgp\", \"sig\"]\n  }, {\n    name: \"ASN.1\",\n    mime: \"text/x-ttcn-asn\",\n    mode: \"asn.1\",\n    ext: [\"asn\", \"asn1\"]\n  }, {\n    name: \"Asterisk\",\n    mime: \"text/x-asterisk\",\n    mode: \"asterisk\",\n    file: /^extensions\\.conf$/i\n  }, {\n    name: \"Brainfuck\",\n    mime: \"text/x-brainfuck\",\n    mode: \"brainfuck\",\n    ext: [\"b\", \"bf\"]\n  }, {\n    name: \"C\",\n    mime: \"text/x-csrc\",\n    mode: \"clike\",\n    ext: [\"c\", \"h\", \"ino\"]\n  }, {\n    name: \"C++\",\n    mime: \"text/x-c++src\",\n    mode: \"clike\",\n    ext: [\"cpp\", \"c++\", \"cc\", \"cxx\", \"hpp\", \"h++\", \"hh\", \"hxx\"],\n    alias: [\"cpp\"]\n  }, {\n    name: \"Cobol\",\n    mime: \"text/x-cobol\",\n    mode: \"cobol\",\n    ext: [\"cob\", \"cpy\"]\n  }, {\n    name: \"C#\",\n    mime: \"text/x-csharp\",\n    mode: \"clike\",\n    ext: [\"cs\"],\n    alias: [\"csharp\", \"cs\"]\n  }, {\n    name: \"Clojure\",\n    mime: \"text/x-clojure\",\n    mode: \"clojure\",\n    ext: [\"clj\", \"cljc\", \"cljx\"]\n  }, {\n    name: \"ClojureScript\",\n    mime: \"text/x-clojurescript\",\n    mode: \"clojure\",\n    ext: [\"cljs\"]\n  }, {\n    name: \"Closure Stylesheets (GSS)\",\n    mime: \"text/x-gss\",\n    mode: \"css\",\n    ext: [\"gss\"]\n  }, {\n    name: \"CMake\",\n    mime: \"text/x-cmake\",\n    mode: \"cmake\",\n    ext: [\"cmake\", \"cmake.in\"],\n    file: /^CMakeLists.txt$/\n  }, {\n    name: \"CoffeeScript\",\n    mimes: [\"application/vnd.coffeescript\", \"text/coffeescript\", \"text/x-coffeescript\"],\n    mode: \"coffeescript\",\n    ext: [\"coffee\"],\n    alias: [\"coffee\", \"coffee-script\"]\n  }, {\n    name: \"Common Lisp\",\n    mime: \"text/x-common-lisp\",\n    mode: \"commonlisp\",\n    ext: [\"cl\", \"lisp\", \"el\"],\n    alias: [\"lisp\"]\n  }, {\n    name: \"Cypher\",\n    mime: \"application/x-cypher-query\",\n    mode: \"cypher\",\n    ext: [\"cyp\", \"cypher\"]\n  }, {\n    name: \"Cython\",\n    mime: \"text/x-cython\",\n    mode: \"python\",\n    ext: [\"pyx\", \"pxd\", \"pxi\"]\n  }, {\n    name: \"Crystal\",\n    mime: \"text/x-crystal\",\n    mode: \"crystal\",\n    ext: [\"cr\"]\n  }, {\n    name: \"CSS\",\n    mime: \"text/css\",\n    mode: \"css\",\n    ext: [\"css\"]\n  }, {\n    name: \"CQL\",\n    mime: \"text/x-cassandra\",\n    mode: \"sql\",\n    ext: [\"cql\"]\n  }, {\n    name: \"D\",\n    mime: \"text/x-d\",\n    mode: \"d\",\n    ext: [\"d\"]\n  }, {\n    name: \"Dart\",\n    mimes: [\"application/dart\", \"text/x-dart\"],\n    mode: \"dart\",\n    ext: [\"dart\"]\n  }, {\n    name: \"diff\",\n    mime: \"text/x-diff\",\n    mode: \"diff\",\n    ext: [\"diff\", \"patch\"]\n  }, {\n    name: \"Django\",\n    mime: \"text/x-django\",\n    mode: \"django\"\n  }, {\n    name: \"Dockerfile\",\n    mime: \"text/x-dockerfile\",\n    mode: \"dockerfile\",\n    file: /^Dockerfile$/\n  }, {\n    name: \"DTD\",\n    mime: \"application/xml-dtd\",\n    mode: \"dtd\",\n    ext: [\"dtd\"]\n  }, {\n    name: \"Dylan\",\n    mime: \"text/x-dylan\",\n    mode: \"dylan\",\n    ext: [\"dylan\", \"dyl\", \"intr\"]\n  }, {\n    name: \"EBNF\",\n    mime: \"text/x-ebnf\",\n    mode: \"ebnf\"\n  }, {\n    name: \"ECL\",\n    mime: \"text/x-ecl\",\n    mode: \"ecl\",\n    ext: [\"ecl\"]\n  }, {\n    name: \"edn\",\n    mime: \"application/edn\",\n    mode: \"clojure\",\n    ext: [\"edn\"]\n  }, {\n    name: \"Eiffel\",\n    mime: \"text/x-eiffel\",\n    mode: \"eiffel\",\n    ext: [\"e\"]\n  }, {\n    name: \"Elm\",\n    mime: \"text/x-elm\",\n    mode: \"elm\",\n    ext: [\"elm\"]\n  }, {\n    name: \"Embedded Javascript\",\n    mime: \"application/x-ejs\",\n    mode: \"htmlembedded\",\n    ext: [\"ejs\"]\n  }, {\n    name: \"Embedded Ruby\",\n    mime: \"application/x-erb\",\n    mode: \"htmlembedded\",\n    ext: [\"erb\"]\n  }, {\n    name: \"Erlang\",\n    mime: \"text/x-erlang\",\n    mode: \"erlang\",\n    ext: [\"erl\"]\n  }, {\n    name: \"Esper\",\n    mime: \"text/x-esper\",\n    mode: \"sql\"\n  }, {\n    name: \"Factor\",\n    mime: \"text/x-factor\",\n    mode: \"factor\",\n    ext: [\"factor\"]\n  }, {\n    name: \"FCL\",\n    mime: \"text/x-fcl\",\n    mode: \"fcl\"\n  }, {\n    name: \"Forth\",\n    mime: \"text/x-forth\",\n    mode: \"forth\",\n    ext: [\"forth\", \"fth\", \"4th\"]\n  }, {\n    name: \"Fortran\",\n    mime: \"text/x-fortran\",\n    mode: \"fortran\",\n    ext: [\"f\", \"for\", \"f77\", \"f90\", \"f95\"]\n  }, {\n    name: \"F#\",\n    mime: \"text/x-fsharp\",\n    mode: \"mllike\",\n    ext: [\"fs\"],\n    alias: [\"fsharp\"]\n  }, {\n    name: \"Gas\",\n    mime: \"text/x-gas\",\n    mode: \"gas\",\n    ext: [\"s\"]\n  }, {\n    name: \"Gherkin\",\n    mime: \"text/x-feature\",\n    mode: \"gherkin\",\n    ext: [\"feature\"]\n  }, {\n    name: \"GitHub Flavored Markdown\",\n    mime: \"text/x-gfm\",\n    mode: \"gfm\",\n    file: /^(readme|contributing|history).md$/i\n  }, {\n    name: \"Go\",\n    mime: \"text/x-go\",\n    mode: \"go\",\n    ext: [\"go\"]\n  }, {\n    name: \"Groovy\",\n    mime: \"text/x-groovy\",\n    mode: \"groovy\",\n    ext: [\"groovy\", \"gradle\"],\n    file: /^Jenkinsfile$/\n  }, {\n    name: \"HAML\",\n    mime: \"text/x-haml\",\n    mode: \"haml\",\n    ext: [\"haml\"]\n  }, {\n    name: \"Haskell\",\n    mime: \"text/x-haskell\",\n    mode: \"haskell\",\n    ext: [\"hs\"]\n  }, {\n    name: \"Haskell (Literate)\",\n    mime: \"text/x-literate-haskell\",\n    mode: \"haskell-literate\",\n    ext: [\"lhs\"]\n  }, {\n    name: \"Haxe\",\n    mime: \"text/x-haxe\",\n    mode: \"haxe\",\n    ext: [\"hx\"]\n  }, {\n    name: \"HXML\",\n    mime: \"text/x-hxml\",\n    mode: \"haxe\",\n    ext: [\"hxml\"]\n  }, {\n    name: \"ASP.NET\",\n    mime: \"application/x-aspx\",\n    mode: \"htmlembedded\",\n    ext: [\"aspx\"],\n    alias: [\"asp\", \"aspx\"]\n  }, {\n    name: \"HTML\",\n    mime: \"text/html\",\n    mode: \"htmlmixed\",\n    ext: [\"html\", \"htm\", \"handlebars\", \"hbs\"],\n    alias: [\"xhtml\"]\n  }, {\n    name: \"HTTP\",\n    mime: \"message/http\",\n    mode: \"http\"\n  }, {\n    name: \"IDL\",\n    mime: \"text/x-idl\",\n    mode: \"idl\",\n    ext: [\"pro\"]\n  }, {\n    name: \"Pug\",\n    mime: \"text/x-pug\",\n    mode: \"pug\",\n    ext: [\"jade\", \"pug\"],\n    alias: [\"jade\"]\n  }, {\n    name: \"Java\",\n    mime: \"text/x-java\",\n    mode: \"clike\",\n    ext: [\"java\"]\n  }, {\n    name: \"Java Server Pages\",\n    mime: \"application/x-jsp\",\n    mode: \"htmlembedded\",\n    ext: [\"jsp\"],\n    alias: [\"jsp\"]\n  }, {\n    name: \"JavaScript\",\n    mimes: [\"text/javascript\", \"text/ecmascript\", \"application/javascript\", \"application/x-javascript\", \"application/ecmascript\"],\n    mode: \"javascript\",\n    ext: [\"js\"],\n    alias: [\"ecmascript\", \"js\", \"node\"]\n  }, {\n    name: \"JSON\",\n    mimes: [\"application/json\", \"application/x-json\"],\n    mode: \"javascript\",\n    ext: [\"json\", \"map\"],\n    alias: [\"json5\"]\n  }, {\n    name: \"JSON-LD\",\n    mime: \"application/ld+json\",\n    mode: \"javascript\",\n    ext: [\"jsonld\"],\n    alias: [\"jsonld\"]\n  }, {\n    name: \"JSX\",\n    mime: \"text/jsx\",\n    mode: \"jsx\",\n    ext: [\"jsx\"]\n  }, {\n    name: \"Jinja2\",\n    mime: \"text/jinja2\",\n    mode: \"jinja2\",\n    ext: [\"j2\", \"jinja\", \"jinja2\"]\n  }, {\n    name: \"Julia\",\n    mime: \"text/x-julia\",\n    mode: \"julia\",\n    ext: [\"jl\"]\n  }, {\n    name: \"Kotlin\",\n    mime: \"text/x-kotlin\",\n    mode: \"clike\",\n    ext: [\"kt\"]\n  }, {\n    name: \"LESS\",\n    mime: \"text/x-less\",\n    mode: \"css\",\n    ext: [\"less\"]\n  }, {\n    name: \"LiveScript\",\n    mime: \"text/x-livescript\",\n    mode: \"livescript\",\n    ext: [\"ls\"],\n    alias: [\"ls\"]\n  }, {\n    name: \"Lua\",\n    mime: \"text/x-lua\",\n    mode: \"lua\",\n    ext: [\"lua\"]\n  }, {\n    name: \"Markdown\",\n    mime: \"text/x-markdown\",\n    mode: \"markdown\",\n    ext: [\"markdown\", \"md\", \"mkd\"]\n  }, {\n    name: \"mIRC\",\n    mime: \"text/mirc\",\n    mode: \"mirc\"\n  }, {\n    name: \"MariaDB SQL\",\n    mime: \"text/x-mariadb\",\n    mode: \"sql\"\n  }, {\n    name: \"Mathematica\",\n    mime: \"text/x-mathematica\",\n    mode: \"mathematica\",\n    ext: [\"m\", \"nb\"]\n  }, {\n    name: \"Modelica\",\n    mime: \"text/x-modelica\",\n    mode: \"modelica\",\n    ext: [\"mo\"]\n  }, {\n    name: \"MUMPS\",\n    mime: \"text/x-mumps\",\n    mode: \"mumps\",\n    ext: [\"mps\"]\n  }, {\n    name: \"MS SQL\",\n    mime: \"text/x-mssql\",\n    mode: \"sql\"\n  }, {\n    name: \"mbox\",\n    mime: \"application/mbox\",\n    mode: \"mbox\",\n    ext: [\"mbox\"]\n  }, {\n    name: \"MySQL\",\n    mime: \"text/x-mysql\",\n    mode: \"sql\"\n  }, {\n    name: \"Nginx\",\n    mime: \"text/x-nginx-conf\",\n    mode: \"nginx\",\n    file: /nginx.*\\.conf$/i\n  }, {\n    name: \"NSIS\",\n    mime: \"text/x-nsis\",\n    mode: \"nsis\",\n    ext: [\"nsh\", \"nsi\"]\n  }, {\n    name: \"NTriples\",\n    mimes: [\"application/n-triples\", \"application/n-quads\", \"text/n-triples\"],\n    mode: \"ntriples\",\n    ext: [\"nt\", \"nq\"]\n  }, {\n    name: \"Objective-C\",\n    mime: \"text/x-objectivec\",\n    mode: \"clike\",\n    ext: [\"m\", \"mm\"],\n    alias: [\"objective-c\", \"objc\"]\n  }, {\n    name: \"OCaml\",\n    mime: \"text/x-ocaml\",\n    mode: \"mllike\",\n    ext: [\"ml\", \"mli\", \"mll\", \"mly\"]\n  }, {\n    name: \"Octave\",\n    mime: \"text/x-octave\",\n    mode: \"octave\",\n    ext: [\"m\"]\n  }, {\n    name: \"Oz\",\n    mime: \"text/x-oz\",\n    mode: \"oz\",\n    ext: [\"oz\"]\n  }, {\n    name: \"Pascal\",\n    mime: \"text/x-pascal\",\n    mode: \"pascal\",\n    ext: [\"p\", \"pas\"]\n  }, {\n    name: \"PEG.js\",\n    mime: \"null\",\n    mode: \"pegjs\",\n    ext: [\"jsonld\"]\n  }, {\n    name: \"Perl\",\n    mime: \"text/x-perl\",\n    mode: \"perl\",\n    ext: [\"pl\", \"pm\"]\n  }, {\n    name: \"PHP\",\n    mimes: [\"text/x-php\", \"application/x-httpd-php\", \"application/x-httpd-php-open\"],\n    mode: \"php\",\n    ext: [\"php\", \"php3\", \"php4\", \"php5\", \"php7\", \"phtml\"]\n  }, {\n    name: \"Pig\",\n    mime: \"text/x-pig\",\n    mode: \"pig\",\n    ext: [\"pig\"]\n  }, {\n    name: \"Plain Text\",\n    mime: \"text/plain\",\n    mode: \"null\",\n    ext: [\"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\"]\n  }, {\n    name: \"PLSQL\",\n    mime: \"text/x-plsql\",\n    mode: \"sql\",\n    ext: [\"pls\"]\n  }, {\n    name: \"PostgreSQL\",\n    mime: \"text/x-pgsql\",\n    mode: \"sql\"\n  }, {\n    name: \"PowerShell\",\n    mime: \"application/x-powershell\",\n    mode: \"powershell\",\n    ext: [\"ps1\", \"psd1\", \"psm1\"]\n  }, {\n    name: \"Properties files\",\n    mime: \"text/x-properties\",\n    mode: \"properties\",\n    ext: [\"properties\", \"ini\", \"in\"],\n    alias: [\"ini\", \"properties\"]\n  }, {\n    name: \"ProtoBuf\",\n    mime: \"text/x-protobuf\",\n    mode: \"protobuf\",\n    ext: [\"proto\"]\n  }, {\n    name: \"Python\",\n    mime: \"text/x-python\",\n    mode: \"python\",\n    ext: [\"BUILD\", \"bzl\", \"py\", \"pyw\"],\n    file: /^(BUCK|BUILD)$/\n  }, {\n    name: \"Puppet\",\n    mime: \"text/x-puppet\",\n    mode: \"puppet\",\n    ext: [\"pp\"]\n  }, {\n    name: \"Q\",\n    mime: \"text/x-q\",\n    mode: \"q\",\n    ext: [\"q\"]\n  }, {\n    name: \"R\",\n    mime: \"text/x-rsrc\",\n    mode: \"r\",\n    ext: [\"r\", \"R\"],\n    alias: [\"rscript\"]\n  }, {\n    name: \"reStructuredText\",\n    mime: \"text/x-rst\",\n    mode: \"rst\",\n    ext: [\"rst\"],\n    alias: [\"rst\"]\n  }, {\n    name: \"RPM Changes\",\n    mime: \"text/x-rpm-changes\",\n    mode: \"rpm\"\n  }, {\n    name: \"RPM Spec\",\n    mime: \"text/x-rpm-spec\",\n    mode: \"rpm\",\n    ext: [\"spec\"]\n  }, {\n    name: \"Ruby\",\n    mime: \"text/x-ruby\",\n    mode: \"ruby\",\n    ext: [\"rb\"],\n    alias: [\"jruby\", \"macruby\", \"rake\", \"rb\", \"rbx\"]\n  }, {\n    name: \"Rust\",\n    mime: \"text/x-rustsrc\",\n    mode: \"rust\",\n    ext: [\"rs\"]\n  }, {\n    name: \"SAS\",\n    mime: \"text/x-sas\",\n    mode: \"sas\",\n    ext: [\"sas\"]\n  }, {\n    name: \"Sass\",\n    mime: \"text/x-sass\",\n    mode: \"sass\",\n    ext: [\"sass\"]\n  }, {\n    name: \"Scala\",\n    mime: \"text/x-scala\",\n    mode: \"clike\",\n    ext: [\"scala\"]\n  }, {\n    name: \"Scheme\",\n    mime: \"text/x-scheme\",\n    mode: \"scheme\",\n    ext: [\"scm\", \"ss\"]\n  }, {\n    name: \"SCSS\",\n    mime: \"text/x-scss\",\n    mode: \"css\",\n    ext: [\"scss\"]\n  }, {\n    name: \"Shell\",\n    mimes: [\"text/x-sh\", \"application/x-sh\"],\n    mode: \"shell\",\n    ext: [\"sh\", \"ksh\", \"bash\"],\n    alias: [\"bash\", \"sh\", \"zsh\"],\n    file: /^PKGBUILD$/\n  }, {\n    name: \"Sieve\",\n    mime: \"application/sieve\",\n    mode: \"sieve\",\n    ext: [\"siv\", \"sieve\"]\n  }, {\n    name: \"Slim\",\n    mimes: [\"text/x-slim\", \"application/x-slim\"],\n    mode: \"slim\",\n    ext: [\"slim\"]\n  }, {\n    name: \"Smalltalk\",\n    mime: \"text/x-stsrc\",\n    mode: \"smalltalk\",\n    ext: [\"st\"]\n  }, {\n    name: \"Smarty\",\n    mime: \"text/x-smarty\",\n    mode: \"smarty\",\n    ext: [\"tpl\"]\n  }, {\n    name: \"Solr\",\n    mime: \"text/x-solr\",\n    mode: \"solr\"\n  }, {\n    name: \"SML\",\n    mime: \"text/x-sml\",\n    mode: \"mllike\",\n    ext: [\"sml\", \"sig\", \"fun\", \"smackspec\"]\n  }, {\n    name: \"Soy\",\n    mime: \"text/x-soy\",\n    mode: \"soy\",\n    ext: [\"soy\"],\n    alias: [\"closure template\"]\n  }, {\n    name: \"SPARQL\",\n    mime: \"application/sparql-query\",\n    mode: \"sparql\",\n    ext: [\"rq\", \"sparql\"],\n    alias: [\"sparul\"]\n  }, {\n    name: \"Spreadsheet\",\n    mime: \"text/x-spreadsheet\",\n    mode: \"spreadsheet\",\n    alias: [\"excel\", \"formula\"]\n  }, {\n    name: \"SQL\",\n    mime: \"text/x-sql\",\n    mode: \"sql\",\n    ext: [\"sql\"]\n  }, {\n    name: \"SQLite\",\n    mime: \"text/x-sqlite\",\n    mode: \"sql\"\n  }, {\n    name: \"Squirrel\",\n    mime: \"text/x-squirrel\",\n    mode: \"clike\",\n    ext: [\"nut\"]\n  }, {\n    name: \"Stylus\",\n    mime: \"text/x-styl\",\n    mode: \"stylus\",\n    ext: [\"styl\"]\n  }, {\n    name: \"Swift\",\n    mime: \"text/x-swift\",\n    mode: \"swift\",\n    ext: [\"swift\"]\n  }, {\n    name: \"sTeX\",\n    mime: \"text/x-stex\",\n    mode: \"stex\"\n  }, {\n    name: \"LaTeX\",\n    mime: \"text/x-latex\",\n    mode: \"stex\",\n    ext: [\"text\", \"ltx\", \"tex\"],\n    alias: [\"tex\"]\n  }, {\n    name: \"SystemVerilog\",\n    mime: \"text/x-systemverilog\",\n    mode: \"verilog\",\n    ext: [\"v\", \"sv\", \"svh\"]\n  }, {\n    name: \"Tcl\",\n    mime: \"text/x-tcl\",\n    mode: \"tcl\",\n    ext: [\"tcl\"]\n  }, {\n    name: \"Textile\",\n    mime: \"text/x-textile\",\n    mode: \"textile\",\n    ext: [\"textile\"]\n  }, {\n    name: \"TiddlyWiki \",\n    mime: \"text/x-tiddlywiki\",\n    mode: \"tiddlywiki\"\n  }, {\n    name: \"Tiki wiki\",\n    mime: \"text/tiki\",\n    mode: \"tiki\"\n  }, {\n    name: \"TOML\",\n    mime: \"text/x-toml\",\n    mode: \"toml\",\n    ext: [\"toml\"]\n  }, {\n    name: \"Tornado\",\n    mime: \"text/x-tornado\",\n    mode: \"tornado\"\n  }, {\n    name: \"troff\",\n    mime: \"text/troff\",\n    mode: \"troff\",\n    ext: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n  }, {\n    name: \"TTCN\",\n    mime: \"text/x-ttcn\",\n    mode: \"ttcn\",\n    ext: [\"ttcn\", \"ttcn3\", \"ttcnpp\"]\n  }, {\n    name: \"TTCN_CFG\",\n    mime: \"text/x-ttcn-cfg\",\n    mode: \"ttcn-cfg\",\n    ext: [\"cfg\"]\n  }, {\n    name: \"Turtle\",\n    mime: \"text/turtle\",\n    mode: \"turtle\",\n    ext: [\"ttl\"]\n  }, {\n    name: \"TypeScript\",\n    mime: \"application/typescript\",\n    mode: \"javascript\",\n    ext: [\"ts\"],\n    alias: [\"ts\"]\n  }, {\n    name: \"TypeScript-JSX\",\n    mime: \"text/typescript-jsx\",\n    mode: \"jsx\",\n    ext: [\"tsx\"],\n    alias: [\"tsx\"]\n  }, {\n    name: \"Twig\",\n    mime: \"text/x-twig\",\n    mode: \"twig\"\n  }, {\n    name: \"Web IDL\",\n    mime: \"text/x-webidl\",\n    mode: \"webidl\",\n    ext: [\"webidl\"]\n  }, {\n    name: \"VB.NET\",\n    mime: \"text/x-vb\",\n    mode: \"vb\",\n    ext: [\"vb\"]\n  }, {\n    name: \"VBScript\",\n    mime: \"text/vbscript\",\n    mode: \"vbscript\",\n    ext: [\"vbs\"]\n  }, {\n    name: \"Velocity\",\n    mime: \"text/velocity\",\n    mode: \"velocity\",\n    ext: [\"vtl\"]\n  }, {\n    name: \"Verilog\",\n    mime: \"text/x-verilog\",\n    mode: \"verilog\",\n    ext: [\"v\"]\n  }, {\n    name: \"VHDL\",\n    mime: \"text/x-vhdl\",\n    mode: \"vhdl\",\n    ext: [\"vhd\", \"vhdl\"]\n  }, {\n    name: \"Vue.js Component\",\n    mimes: [\"script/x-vue\", \"text/x-vue\"],\n    mode: \"vue\",\n    ext: [\"vue\"]\n  }, {\n    name: \"XML\",\n    mimes: [\"application/xml\", \"text/xml\"],\n    mode: \"xml\",\n    ext: [\"xml\", \"xsl\", \"xsd\", \"svg\"],\n    alias: [\"rss\", \"wsdl\", \"xsd\"]\n  }, {\n    name: \"XQuery\",\n    mime: \"application/xquery\",\n    mode: \"xquery\",\n    ext: [\"xy\", \"xquery\"]\n  }, {\n    name: \"Yacas\",\n    mime: \"text/x-yacas\",\n    mode: \"yacas\",\n    ext: [\"ys\"]\n  }, {\n    name: \"YAML\",\n    mimes: [\"text/x-yaml\", \"text/yaml\"],\n    mode: \"yaml\",\n    ext: [\"yaml\", \"yml\"],\n    alias: [\"yml\"]\n  }, {\n    name: \"Z80\",\n    mime: \"text/x-z80\",\n    mode: \"z80\",\n    ext: [\"z80\"]\n  }, {\n    name: \"mscgen\",\n    mime: \"text/x-mscgen\",\n    mode: \"mscgen\",\n    ext: [\"mscgen\", \"mscin\", \"msc\"]\n  }, {\n    name: \"xu\",\n    mime: \"text/x-xu\",\n    mode: \"mscgen\",\n    ext: [\"xu\"]\n  }, {\n    name: \"msgenny\",\n    mime: \"text/x-msgenny\",\n    mode: \"mscgen\",\n    ext: [\"msgenny\"]\n  }]; // Ensure all modes have a mime property for backwards compatibility\n\n  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n    var info = CodeMirror.modeInfo[i];\n    if (info.mimes) info.mime = info.mimes[0];\n  }\n\n  CodeMirror.findModeByMIME = function (mime) {\n    mime = mime.toLowerCase();\n\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.mime == mime) return info;\n      if (info.mimes) for (var j = 0; j < info.mimes.length; j++) {\n        if (info.mimes[j] == mime) return info;\n      }\n    }\n\n    if (/\\+xml$/.test(mime)) return CodeMirror.findModeByMIME(\"application/xml\");\n    if (/\\+json$/.test(mime)) return CodeMirror.findModeByMIME(\"application/json\");\n  };\n\n  CodeMirror.findModeByExtension = function (ext) {\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.ext) for (var j = 0; j < info.ext.length; j++) {\n        if (info.ext[j] == ext) return info;\n      }\n    }\n  };\n\n  CodeMirror.findModeByFileName = function (filename) {\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.file && info.file.test(filename)) return info;\n    }\n\n    var dot = filename.lastIndexOf(\".\");\n    var ext = dot > -1 && filename.substring(dot + 1, filename.length);\n    if (ext) return CodeMirror.findModeByExtension(ext);\n  };\n\n  CodeMirror.findModeByName = function (name) {\n    name = name.toLowerCase();\n\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.name.toLowerCase() == name) return info;\n      if (info.alias) for (var j = 0; j < info.alias.length; j++) {\n        if (info.alias[j].toLowerCase() == name) return info;\n      }\n    }\n  };\n});","function _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nmodule.exports = _interopRequireWildcard;","module.exports = require(\"regenerator-runtime\");\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nrequire(\"codemirror/lib/codemirror.css\");\n\nvar _CodeMirror = _interopRequireDefault(require(\"./CodeMirror\"));\n\nrequire(\"./index.css\");\n\nvar ReactCodeMirror =\n/*#__PURE__*/\nfunction (_Component) {\n  (0, _inherits2.default)(ReactCodeMirror, _Component);\n\n  function ReactCodeMirror(props) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ReactCodeMirror);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ReactCodeMirror).call(this, props));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"getInstance\", function (instance) {\n      if (instance) {\n        _this.codemirror = instance.codemirror;\n        _this.editor = instance.editor;\n      }\n    });\n    _this.state = {\n      codeMirrorOptions: {}\n    };\n    return _this;\n  }\n\n  (0, _createClass2.default)(ReactCodeMirror, [{\n    key: \"componentDidMount\",\n    value: function () {\n      var _componentDidMount = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee() {\n        var options, codeMirrorOptions;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = this.props.options;\n                codeMirrorOptions = Object.assign({\n                  tabSize: 2,\n                  autoCloseBrackets: true,\n                  matchBrackets: true,\n                  showCursorWhenSelecting: true,\n                  // \n                  lineNumbers: true,\n                  fullScreen: true\n                }, options);\n                this.setState({\n                  codeMirrorOptions: codeMirrorOptions\n                });\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function componentDidMount() {\n        return _componentDidMount.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function () {\n      var _componentWillReceiveProps = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee2(nextPros) {\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.setState({\n                  codeMirrorOptions: Object.assign({}, this.state.codeMirrorOptions, nextPros.options)\n                });\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function componentWillReceiveProps(_x) {\n        return _componentWillReceiveProps.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          options = _this$props.options,\n          otherProps = (0, _objectWithoutProperties2.default)(_this$props, [\"options\"]);\n      var codeMirrorOptions = this.state.codeMirrorOptions;\n      return _react.default.createElement(_CodeMirror.default, (0, _extends2.default)({}, otherProps, {\n        ref: this.getInstance,\n        options: Object.assign({}, codeMirrorOptions)\n      }));\n    }\n  }]);\n  return ReactCodeMirror;\n}(_react.Component);\n\nexports.default = ReactCodeMirror;\nReactCodeMirror.defaultProps = {\n  value: '',\n  options: {}\n};\nReactCodeMirror.propTypes = {\n  value: _propTypes.default.string,\n  options: _propTypes.default.object\n};","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n\n\n  var IteratorPrototype = {};\n\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      prototype[method] = function (arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }; // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    } // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n\n  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  } // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n      context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    } // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n\n\n    context.delegate = null;\n    return ContinueSentinel;\n  } // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n\n\n  defineIteratorMethods(Gp);\n  Gp[toStringTagSymbol] = \"Generator\"; // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n  Gp[iteratorSymbol] = function () {\n    return this;\n  };\n\n  Gp.toString = function () {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse(); // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      } // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    } // Return an iterator with no values.\n\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      this.prev = 0;\n      this.next = 0; // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function stop() {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      } // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  }; // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n\n  return exports;\n}( // If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\ntypeof module === \"object\" ? module.exports : {});\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _codemirror = _interopRequireDefault(require(\"codemirror\"));\n\nrequire(\"codemirror/mode/meta\");\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar ReactCodeMirror =\n/*#__PURE__*/\nfunction (_Component) {\n  (0, _inherits2.default)(ReactCodeMirror, _Component);\n\n  function ReactCodeMirror(props) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ReactCodeMirror);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ReactCodeMirror).call(this, props));\n    _this.codemirror = null;\n    _this.editor = null;\n    return _this;\n  }\n\n  (0, _createClass2.default)(ReactCodeMirror, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.renderCodeMirror();\n    }\n  }, {\n    key: \"renderCodeMirror\",\n    value: function renderCodeMirror() {\n      var _this2 = this; // codemirror\n\n\n      this.editor = _codemirror.default.fromTextArea(this.textarea, this.props.options); // CodeMirror\n\n      this.codemirror = _codemirror.default; // \n\n      var eventDict = this.getEventHandleFromProps();\n      Object.keys(eventDict).forEach(function (event) {\n        _this2.editor.on(eventDict[event], _this2.props[event]);\n      });\n      var _this$props = this.props,\n          value = _this$props.value,\n          width = _this$props.width,\n          height = _this$props.height; // \n\n      this.editor.setValue(value || '');\n\n      if (width || height) {\n        // \n        this.editor.setSize(width, height);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function () {\n      var _componentWillReceiveProps = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee(nextProps) {\n        var val, next, options, width, height;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                val = this.editor.getValue();\n                next = nextProps.value;\n\n                if (next !== undefined && next !== this.props.value && next !== val) {\n                  this.editor.setValue(nextProps.value);\n                }\n\n                options = nextProps.options, width = nextProps.width, height = nextProps.height;\n                _context.next = 6;\n                return this.setOptions(options);\n\n              case 6:\n                if (width !== this.props.width || height !== this.props.height) {\n                  this.editor.setSize(width, height);\n                }\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function componentWillReceiveProps(_x) {\n        return _componentWillReceiveProps.apply(this, arguments);\n      };\n    }() // http://codemirror.net/doc/manual.html#config\n\n  }, {\n    key: \"setOptions\",\n    value: function () {\n      var _setOptions = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee2(options) {\n        var _this3 = this;\n\n        var mode;\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!((0, _typeof2.default)(options) === 'object')) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                mode = _codemirror.default.findModeByName(options.mode);\n\n                if (!(mode && mode.mode)) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 5;\n                return import(\"codemirror/mode/\".concat(mode.mode, \"/\").concat(mode.mode, \".js\"));\n\n              case 5:\n                if (mode) {\n                  options.mode = mode.mime;\n                }\n\n                Object.keys(options).forEach(function (name) {\n                  if (options[name] && JSON.stringify(options[name])) {\n                    _this3.editor.setOption(name, options[name]);\n                  }\n                });\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function setOptions(_x2) {\n        return _setOptions.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.editor) {\n        this.editor.toTextArea();\n      }\n    } // props\n\n  }, {\n    key: \"getEventHandleFromProps\",\n    value: function getEventHandleFromProps() {\n      var propNames = Object.keys(this.props);\n      var eventHandle = propNames.filter(function (prop) {\n        return /^on+/.test(prop);\n      });\n      var eventDict = {};\n      eventHandle.forEach(function (ele) {\n        eventDict[ele] = ele.replace(/^on[A-Z]/g, function (s) {\n          return s.slice(2).toLowerCase();\n        });\n      });\n      return eventDict;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      return _react.default.createElement(\"textarea\", {\n        ref: function ref(instance) {\n          _this4.textarea = instance;\n        }\n      });\n    }\n  }]);\n  return ReactCodeMirror;\n}(_react.Component);\n\nexports.default = ReactCodeMirror;\nReactCodeMirror.defaultProps = {\n  value: '',\n  options: {},\n  width: '100%',\n  height: '100%'\n};\nReactCodeMirror.propTypes = {\n  value: _propTypes.default.string,\n  options: _propTypes.default.object,\n  width: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),\n  height: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number])\n};","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos; // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\",\n        type;\n\n    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n\n      if (state == \"start\") {\n        if (cat != \"o\") {\n          state = \"in\";\n          type = cat;\n        }\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n\n          if (type == \"W\" && cat == \"w\" && dir > 0) {\n            type = \"w\";\n            continue;\n          }\n\n          break;\n        }\n      }\n    }\n\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function (range) {\n      if (cm.display.shift || cm.doc.extend || range.empty()) return findPosSubword(cm.doc, range.head, dir);else return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  cmds.goSubwordLeft = function (cm) {\n    moveSubword(cm, -1);\n  };\n\n  cmds.goSubwordRight = function (cm) {\n    moveSubword(cm, 1);\n  };\n\n  cmds.scrollLineUp = function (cm) {\n    var info = cm.getScrollInfo();\n\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine) cm.execCommand(\"goLineUp\");\n    }\n\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n\n  cmds.scrollLineDown = function (cm) {\n    var info = cm.getScrollInfo();\n\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\") + 1;\n      if (cm.getCursor().line <= visibleTopLine) cm.execCommand(\"goLineDown\");\n    }\n\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds.splitSelectionByLine = function (cm) {\n    var ranges = cm.listSelections(),\n        lineRanges = [];\n\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(),\n          to = ranges[i].to();\n\n      for (var line = from.line; line <= to.line; ++line) {\n        if (!(to.line > from.line && line == to.line && to.ch == 0)) lineRanges.push({\n          anchor: line == from.line ? from : Pos(line, 0),\n          head: line == to.line ? to : Pos(line)\n        });\n      }\n    }\n\n    cm.setSelections(lineRanges, 0);\n  };\n\n  cmds.singleSelectionTop = function (cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {\n      scroll: false\n    });\n  };\n\n  cmds.selectLine = function (cm) {\n    var ranges = cm.listSelections(),\n        extended = [];\n\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({\n        anchor: Pos(range.from().line, 0),\n        head: Pos(range.to().line + 1, 0)\n      });\n    }\n\n    cm.setSelections(extended);\n  };\n\n  function insertLine(cm, above) {\n    if (cm.isReadOnly()) return CodeMirror.Pass;\n    cm.operation(function () {\n      var len = cm.listSelections().length,\n          newSelection = [],\n          last = -1;\n\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({\n          head: at,\n          anchor: at\n        });\n        last = head.line + 1;\n      }\n\n      cm.setSelections(newSelection);\n    });\n    cm.execCommand(\"indentAuto\");\n  }\n\n  cmds.insertLineAfter = function (cm) {\n    return insertLine(cm, false);\n  };\n\n  cmds.insertLineBefore = function (cm) {\n    return insertLine(cm, true);\n  };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch,\n        end = start,\n        line = cm.getLine(pos.line);\n\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) {\n      --start;\n    }\n\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) {\n      ++end;\n    }\n\n    return {\n      from: Pos(pos.line, start),\n      to: Pos(pos.line, end),\n      word: line.slice(start, end)\n    };\n  }\n\n  cmds.selectNextOccurrence = function (cm) {\n    var from = cm.getCursor(\"from\"),\n        to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      var found = cur.findNext();\n\n      if (!found) {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        found = cur.findNext();\n      }\n\n      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to())) return CodeMirror.Pass;\n      cm.addSelection(cur.from(), cur.to());\n    }\n\n    if (fullWord) cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  function addCursorToSelection(cm, dir) {\n    var ranges = cm.listSelections(),\n        newRanges = [];\n\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var newAnchor = cm.findPosV(range.anchor, dir, \"line\", range.anchor.goalColumn);\n      var newHead = cm.findPosV(range.head, dir, \"line\", range.head.goalColumn);\n      newAnchor.goalColumn = range.anchor.goalColumn != null ? range.anchor.goalColumn : cm.cursorCoords(range.anchor, \"div\").left;\n      newHead.goalColumn = range.head.goalColumn != null ? range.head.goalColumn : cm.cursorCoords(range.head, \"div\").left;\n      var newRange = {\n        anchor: newAnchor,\n        head: newHead\n      };\n      newRanges.push(range);\n      newRanges.push(newRange);\n    }\n\n    cm.setSelections(newRanges);\n  }\n\n  cmds.addCursorToPrevLine = function (cm) {\n    addCursorToSelection(cm, -1);\n  };\n\n  cmds.addCursorToNextLine = function (cm) {\n    addCursorToSelection(cm, 1);\n  };\n\n  function isSelectedRange(ranges, from, to) {\n    for (var i = 0; i < ranges.length; i++) {\n      if (ranges[i].from() == from && ranges[i].to() == to) return true;\n    }\n\n    return false;\n  }\n\n  var mirror = \"(){}[]\";\n\n  function selectBetweenBrackets(cm) {\n    var ranges = cm.listSelections(),\n        newRanges = [];\n\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i],\n          pos = range.head,\n          opening = cm.scanForBracket(pos, -1);\n      if (!opening) return false;\n\n      for (;;) {\n        var closing = cm.scanForBracket(pos, 1);\n        if (!closing) return false;\n\n        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n          var startPos = Pos(opening.pos.line, opening.pos.ch + 1);\n\n          if (CodeMirror.cmpPos(startPos, range.from()) == 0 && CodeMirror.cmpPos(closing.pos, range.to()) == 0) {\n            opening = cm.scanForBracket(opening.pos, -1);\n            if (!opening) return false;\n          } else {\n            newRanges.push({\n              anchor: startPos,\n              head: closing.pos\n            });\n            break;\n          }\n        }\n\n        pos = Pos(closing.pos.line, closing.pos.ch + 1);\n      }\n    }\n\n    cm.setSelections(newRanges);\n    return true;\n  }\n\n  cmds.selectScope = function (cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n\n  cmds.selectBetweenBrackets = function (cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  cmds.goToBracket = function (cm) {\n    cm.extendSelectionsBy(function (range) {\n      var next = cm.scanForBracket(range.head, 1);\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1);\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  cmds.swapLineUp = function (cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass;\n    var ranges = cm.listSelections(),\n        linesToMove = [],\n        at = cm.firstLine() - 1,\n        newSels = [];\n\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i],\n          from = range.from().line - 1,\n          to = range.to().line;\n      newSels.push({\n        anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n        head: Pos(range.head.line - 1, range.head.ch)\n      });\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n\n    cm.operation(function () {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i],\n            to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine()) cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");else cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.swapLineDown = function (cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass;\n    var ranges = cm.listSelections(),\n        linesToMove = [],\n        at = cm.lastLine() + 1;\n\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i],\n          from = range.to().line + 1,\n          to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n\n    cm.operation(function () {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i],\n            to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine()) cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");else cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.toggleCommentIndented = function (cm) {\n    cm.toggleComment({\n      indent: true\n    });\n  };\n\n  cmds.joinLines = function (cm) {\n    var ranges = cm.listSelections(),\n        joined = [];\n\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i],\n          from = range.from();\n      var start = from.line,\n          end = range.to().line;\n\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end) {\n        end = ranges[++i].to().line;\n      }\n\n      joined.push({\n        start: start,\n        end: end,\n        anchor: !range.empty() && from\n      });\n    }\n\n    cm.operation(function () {\n      var offset = 0,\n          ranges = [];\n\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch),\n            head;\n\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n\n        ranges.push({\n          anchor: anchor || head,\n          head: head\n        });\n      }\n\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds.duplicateLine = function (cm) {\n    cm.operation(function () {\n      var rangeCount = cm.listSelections().length;\n\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty()) cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));else cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n\n      cm.scrollIntoView();\n    });\n  };\n\n  function sortLines(cm, caseSensitive) {\n    if (cm.isReadOnly()) return CodeMirror.Pass;\n    var ranges = cm.listSelections(),\n        toSort = [],\n        selected;\n\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line,\n          to = range.to().line;\n\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to) {\n        to = ranges[++i].to().line;\n      }\n\n      if (!ranges[i].to().ch) to--;\n      toSort.push(from, to);\n    }\n\n    if (toSort.length) selected = true;else toSort.push(cm.firstLine(), cm.lastLine());\n    cm.operation(function () {\n      var ranges = [];\n\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i],\n            to = toSort[i + 1];\n        var start = Pos(from, 0),\n            end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive) lines.sort();else lines.sort(function (a, b) {\n          var au = a.toUpperCase(),\n              bu = b.toUpperCase();\n\n          if (au != bu) {\n            a = au;\n            b = bu;\n          }\n\n          return a < b ? -1 : a == b ? 0 : 1;\n        });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({\n          anchor: start,\n          head: Pos(to + 1, 0)\n        });\n      }\n\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds.sortLines = function (cm) {\n    sortLines(cm, true);\n  };\n\n  cmds.sortLinesInsensitive = function (cm) {\n    sortLines(cm, false);\n  };\n\n  cmds.nextBookmark = function (cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds.prevBookmark = function (cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found) marks.pop();else return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds.toggleBookmark = function (cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(),\n          to = ranges[i].to();\n      var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);\n\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n\n          for (var k = 0; k < marks.length; k++) {\n            if (marks[k] == found[j]) marks.splice(k--, 1);\n          }\n\n          break;\n        }\n      }\n\n      if (j == found.length) marks.push(cm.markText(from, to, {\n        sublimeBookmark: true,\n        clearWhenEmpty: false\n      }));\n    }\n  };\n\n  cmds.clearBookmarks = function (cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      marks[i].clear();\n    }\n    marks.length = 0;\n  };\n\n  cmds.selectBookmarks = function (cm) {\n    var marks = cm.state.sublimeBookmarks,\n        ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found) marks.splice(i--, 0);else ranges.push({\n        anchor: found.from,\n        head: found.to\n      });\n    }\n    if (ranges.length) cm.setSelections(ranges, 0);\n  };\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function () {\n      var ranges = cm.listSelections(),\n          indices = [],\n          replacements = [];\n\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n\n        if (range.empty()) {\n          indices.push(i);\n          replacements.push(\"\");\n        } else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n\n      cm.replaceSelections(replacements, \"around\", \"case\");\n\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  cmds.smartBackspace = function (cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n    cm.operation(function () {\n      var cursors = cm.listSelections();\n      var indentUnit = cm.getOption(\"indentUnit\");\n\n      for (var i = cursors.length - 1; i >= 0; i--) {\n        var cursor = cursors[i].head;\n        var toStartOfLine = cm.getRange({\n          line: cursor.line,\n          ch: 0\n        }, cursor);\n        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\")); // Delete by one character by default\n\n        var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n\n        if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n          var prevIndent = new Pos(cursor.line, CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit)); // Smart delete only if we found a valid prevIndent location\n\n          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;\n        }\n\n        cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n      }\n    });\n  };\n\n  cmds.delLineRight = function (cm) {\n    cm.operation(function () {\n      var ranges = cm.listSelections();\n\n      for (var i = ranges.length - 1; i >= 0; i--) {\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      }\n\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.upcaseAtCursor = function (cm) {\n    modifyWordOrSelection(cm, function (str) {\n      return str.toUpperCase();\n    });\n  };\n\n  cmds.downcaseAtCursor = function (cm) {\n    modifyWordOrSelection(cm, function (str) {\n      return str.toLowerCase();\n    });\n  };\n\n  cmds.setSublimeMark = function (cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n\n  cmds.selectToSublimeMark = function (cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n\n  cmds.deleteToSublimeMark = function (cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n\n    if (found) {\n      var from = cm.getCursor(),\n          to = found;\n\n      if (CodeMirror.cmpPos(from, to) > 0) {\n        var tmp = to;\n        to = from;\n        from = tmp;\n      }\n\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n\n  cmds.swapWithSublimeMark = function (cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n\n  cmds.sublimeYank = function (cm) {\n    if (cm.state.sublimeKilled != null) cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  cmds.showInCenter = function (cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"),\n        to = cm.getCursor(\"to\");\n\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n\n    return {\n      from: from,\n      to: to,\n      query: cm.getRange(from, to),\n      word: word\n    };\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0) : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious()) cm.setSelection(cur.from(), cur.to());else if (target.word) cm.setSelection(target.from, target.to);\n    }\n  }\n\n  ;\n\n  cmds.findUnder = function (cm) {\n    findAndGoTo(cm, true);\n  };\n\n  cmds.findUnderPrevious = function (cm) {\n    findAndGoTo(cm, false);\n  };\n\n  cmds.findAllUnder = function (cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n\n    while (cur.findNext()) {\n      matches.push({\n        anchor: cur.from(),\n        head: cur.to()\n      });\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch) primaryIndex++;\n    }\n\n    cm.setSelections(matches, primaryIndex);\n  };\n\n  var keyMap = CodeMirror.keyMap;\n  keyMap.macSublime = {\n    \"Cmd-Left\": \"goLineStartSmart\",\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-Left\": \"goSubwordLeft\",\n    \"Ctrl-Right\": \"goSubwordRight\",\n    \"Ctrl-Alt-Up\": \"scrollLineUp\",\n    \"Ctrl-Alt-Down\": \"scrollLineDown\",\n    \"Cmd-L\": \"selectLine\",\n    \"Shift-Cmd-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Cmd-Enter\": \"insertLineAfter\",\n    \"Shift-Cmd-Enter\": \"insertLineBefore\",\n    \"Cmd-D\": \"selectNextOccurrence\",\n    \"Shift-Cmd-Space\": \"selectScope\",\n    \"Shift-Cmd-M\": \"selectBetweenBrackets\",\n    \"Cmd-M\": \"goToBracket\",\n    \"Cmd-Ctrl-Up\": \"swapLineUp\",\n    \"Cmd-Ctrl-Down\": \"swapLineDown\",\n    \"Cmd-/\": \"toggleCommentIndented\",\n    \"Cmd-J\": \"joinLines\",\n    \"Shift-Cmd-D\": \"duplicateLine\",\n    \"F5\": \"sortLines\",\n    \"Cmd-F5\": \"sortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Cmd-F2\": \"toggleBookmark\",\n    \"Shift-Cmd-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Cmd-K Cmd-K\": \"delLineRight\",\n    \"Cmd-K Cmd-U\": \"upcaseAtCursor\",\n    \"Cmd-K Cmd-L\": \"downcaseAtCursor\",\n    \"Cmd-K Cmd-Space\": \"setSublimeMark\",\n    \"Cmd-K Cmd-A\": \"selectToSublimeMark\",\n    \"Cmd-K Cmd-W\": \"deleteToSublimeMark\",\n    \"Cmd-K Cmd-X\": \"swapWithSublimeMark\",\n    \"Cmd-K Cmd-Y\": \"sublimeYank\",\n    \"Cmd-K Cmd-C\": \"showInCenter\",\n    \"Cmd-K Cmd-G\": \"clearBookmarks\",\n    \"Cmd-K Cmd-Backspace\": \"delLineLeft\",\n    \"Cmd-K Cmd-0\": \"unfoldAll\",\n    \"Cmd-K Cmd-J\": \"unfoldAll\",\n    \"Ctrl-Shift-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Shift-Down\": \"addCursorToNextLine\",\n    \"Cmd-F3\": \"findUnder\",\n    \"Shift-Cmd-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Cmd-[\": \"fold\",\n    \"Shift-Cmd-]\": \"unfold\",\n    \"Cmd-I\": \"findIncremental\",\n    \"Shift-Cmd-I\": \"findIncrementalReverse\",\n    \"Cmd-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"macDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.macSublime);\n  keyMap.pcSublime = {\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-T\": \"transposeChars\",\n    \"Alt-Left\": \"goSubwordLeft\",\n    \"Alt-Right\": \"goSubwordRight\",\n    \"Ctrl-Up\": \"scrollLineUp\",\n    \"Ctrl-Down\": \"scrollLineDown\",\n    \"Ctrl-L\": \"selectLine\",\n    \"Shift-Ctrl-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Ctrl-Enter\": \"insertLineAfter\",\n    \"Shift-Ctrl-Enter\": \"insertLineBefore\",\n    \"Ctrl-D\": \"selectNextOccurrence\",\n    \"Shift-Ctrl-Space\": \"selectScope\",\n    \"Shift-Ctrl-M\": \"selectBetweenBrackets\",\n    \"Ctrl-M\": \"goToBracket\",\n    \"Shift-Ctrl-Up\": \"swapLineUp\",\n    \"Shift-Ctrl-Down\": \"swapLineDown\",\n    \"Ctrl-/\": \"toggleCommentIndented\",\n    \"Ctrl-J\": \"joinLines\",\n    \"Shift-Ctrl-D\": \"duplicateLine\",\n    \"F9\": \"sortLines\",\n    \"Ctrl-F9\": \"sortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Ctrl-F2\": \"toggleBookmark\",\n    \"Shift-Ctrl-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Ctrl-K Ctrl-K\": \"delLineRight\",\n    \"Ctrl-K Ctrl-U\": \"upcaseAtCursor\",\n    \"Ctrl-K Ctrl-L\": \"downcaseAtCursor\",\n    \"Ctrl-K Ctrl-Space\": \"setSublimeMark\",\n    \"Ctrl-K Ctrl-A\": \"selectToSublimeMark\",\n    \"Ctrl-K Ctrl-W\": \"deleteToSublimeMark\",\n    \"Ctrl-K Ctrl-X\": \"swapWithSublimeMark\",\n    \"Ctrl-K Ctrl-Y\": \"sublimeYank\",\n    \"Ctrl-K Ctrl-C\": \"showInCenter\",\n    \"Ctrl-K Ctrl-G\": \"clearBookmarks\",\n    \"Ctrl-K Ctrl-Backspace\": \"delLineLeft\",\n    \"Ctrl-K Ctrl-0\": \"unfoldAll\",\n    \"Ctrl-K Ctrl-J\": \"unfoldAll\",\n    \"Ctrl-Alt-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Alt-Down\": \"addCursorToNextLine\",\n    \"Ctrl-F3\": \"findUnder\",\n    \"Shift-Ctrl-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Ctrl-[\": \"fold\",\n    \"Shift-Ctrl-]\": \"unfold\",\n    \"Ctrl-I\": \"findIncremental\",\n    \"Shift-Ctrl-I\": \"findIncrementalReverse\",\n    \"Ctrl-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"pcDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.pcSublime);\n  var mac = keyMap.default == keyMap.macDefault;\n  keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags;\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\") + (regexp.global ? \"g\" : \"\") + (regexp.multiline ? \"m\" : \"\");\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp),\n        target = current;\n\n    for (var i = 0; i < flags.length; i++) {\n      if (target.indexOf(flags.charAt(i)) == -1) target += flags.charAt(i);\n    }\n\n    return current == target ? regexp : new RegExp(regexp.source, target);\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source);\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\");\n\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch;\n      var string = doc.getLine(line),\n          match = regexp.exec(string);\n      if (match) return {\n        from: Pos(line, match.index),\n        to: Pos(line, match.index + match[0].length),\n        match: match\n      };\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start);\n    regexp = ensureFlags(regexp, \"gm\");\n    var string,\n        chunk = 1;\n\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break;\n        var curLine = doc.getLine(line++);\n        string = string == null ? curLine : string + \"\\n\" + curLine;\n      }\n\n      chunk = chunk * 2;\n      regexp.lastIndex = start.ch;\n      var match = regexp.exec(string);\n\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"),\n            inside = match[0].split(\"\\n\");\n        var startLine = start.line + before.length - 1,\n            startCh = before[before.length - 1].length;\n        return {\n          from: Pos(startLine, startCh),\n          to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n          match: match\n        };\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp) {\n    var cutOff = 0,\n        match;\n\n    for (;;) {\n      regexp.lastIndex = cutOff;\n      var newMatch = regexp.exec(string);\n      if (!newMatch) return match;\n      match = newMatch;\n      cutOff = match.index + (match[0].length || 1);\n      if (cutOff == string.length) return match;\n    }\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\");\n\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line);\n      if (ch > -1) string = string.slice(0, ch);\n      var match = lastMatchIn(string, regexp);\n      if (match) return {\n        from: Pos(line, match.index),\n        to: Pos(line, match.index + match[0].length),\n        match: match\n      };\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"gm\");\n    var string,\n        chunk = 1;\n\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line--);\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string;\n      }\n\n      chunk *= 2;\n      var match = lastMatchIn(string, regexp);\n\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"),\n            inside = match[0].split(\"\\n\");\n        var startLine = line + before.length,\n            startCh = before[before.length - 1].length;\n        return {\n          from: Pos(startLine, startCh),\n          to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n          match: match\n        };\n      }\n    }\n  }\n\n  var doFold, noFold;\n\n  if (String.prototype.normalize) {\n    doFold = function doFold(str) {\n      return str.normalize(\"NFD\").toLowerCase();\n    };\n\n    noFold = function noFold(str) {\n      return str.normalize(\"NFD\");\n    };\n  } else {\n    doFold = function doFold(str) {\n      return str.toLowerCase();\n    };\n\n    noFold = function noFold(str) {\n      return str;\n    };\n  } // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n\n\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos;\n\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min;\n      var mid = min + max >> 1;\n      var len = foldFunc(orig.slice(0, mid)).length;\n      if (len == pos) return mid;else if (len > pos) max = mid;else min = mid + 1;\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null;\n    var fold = caseFold ? doFold : noFold;\n    var lines = fold(query).split(/\\r|\\n\\r?/);\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch),\n          string = fold(orig);\n\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0]);\n        if (found == -1) continue search;\n        var start = adjustPos(orig, string, found, fold) + ch;\n        return {\n          from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n          to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)\n        };\n      } else {\n        var cutFrom = string.length - lines[0].length;\n        if (string.slice(cutFrom) != lines[0]) continue search;\n\n        for (var i = 1; i < lines.length - 1; i++) {\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search;\n        }\n\n        var end = doc.getLine(line + lines.length - 1),\n            endString = fold(end),\n            lastLine = lines[lines.length - 1];\n        if (endString.slice(0, lastLine.length) != lastLine) continue search;\n        return {\n          from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n          to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))\n        };\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null;\n    var fold = caseFold ? doFold : noFold;\n    var lines = fold(query).split(/\\r|\\n\\r?/);\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line);\n      if (ch > -1) orig = orig.slice(0, ch);\n      var string = fold(orig);\n\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0]);\n        if (found == -1) continue search;\n        return {\n          from: Pos(line, adjustPos(orig, string, found, fold)),\n          to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))\n        };\n      } else {\n        var lastLine = lines[lines.length - 1];\n        if (string.slice(0, lastLine.length) != lastLine) continue search;\n\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++) {\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search;\n        }\n\n        var top = doc.getLine(line + 1 - lines.length),\n            topString = fold(top);\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search;\n        return {\n          from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n          to: Pos(line, adjustPos(orig, string, lastLine.length, fold))\n        };\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false;\n    this.doc = doc;\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n    this.pos = {\n      from: pos,\n      to: pos\n    };\n    var caseFold;\n\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold;\n    } else {\n      // Backwards compat for when caseFold was the 4th argument\n      caseFold = options;\n      options = null;\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false;\n\n      this.matches = function (reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold);\n      };\n    } else {\n      query = ensureFlags(query, \"gm\");\n      if (!options || options.multiline !== false) this.matches = function (reverse, pos) {\n        return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos);\n      };else this.matches = function (reverse, pos) {\n        return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos);\n      };\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function findNext() {\n      return this.find(false);\n    },\n    findPrevious: function findPrevious() {\n      return this.find(true);\n    },\n    find: function find(reverse) {\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to)); // Implements weird auto-growing behavior on null-matches for\n      // backwards-compatiblity with the vim code (unfortunately)\n\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\n        if (reverse) {\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1);else if (result.from.line == this.doc.firstLine()) result = null;else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)));\n        } else {\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1);else if (result.to.line == this.doc.lastLine()) result = null;else result = this.matches(reverse, Pos(result.to.line + 1, 0));\n        }\n      }\n\n      if (result) {\n        this.pos = result;\n        this.atOccurrence = true;\n        return this.pos.match || true;\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);\n        this.pos = {\n          from: end,\n          to: end\n        };\n        return this.atOccurrence = false;\n      }\n    },\n    from: function from() {\n      if (this.atOccurrence) return this.pos.from;\n    },\n    to: function to() {\n      if (this.atOccurrence) return this.pos.to;\n    },\n    replace: function replace(newText, origin) {\n      if (!this.atOccurrence) return;\n      var lines = CodeMirror.splitLines(newText);\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n    }\n  };\n  CodeMirror.defineExtension(\"getSearchCursor\", function (query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold);\n  });\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function (query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold);\n  });\n  CodeMirror.defineExtension(\"selectMatches\", function (query, caseFold) {\n    var ranges = [];\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break;\n      ranges.push({\n        anchor: cur.from(),\n        head: cur.to()\n      });\n    }\n\n    if (ranges.length) this.setSelections(ranges, 0);\n  });\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);\n  var Pos = CodeMirror.Pos;\n  var matching = {\n    \"(\": \")>\",\n    \")\": \"(<\",\n    \"[\": \"]>\",\n    \"]\": \"[<\",\n    \"{\": \"}>\",\n    \"}\": \"{<\",\n    \"<\": \">>\",\n    \">\": \"<<\"\n  };\n\n  function bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/;\n  }\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line),\n        pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor;\n    if (afterCursor == null) afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);\n    var re = bracketRegex(config); // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n\n    var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && dir > 0 != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {\n      from: Pos(where.line, pos),\n      to: found && found.pos,\n      match: found && found.ch == match.charAt(0),\n      forward: dir > 0\n    };\n  } // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n\n\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = config && config.maxScanLineLength || 10000;\n    var maxScanLines = config && config.maxScanLines || 1000;\n    var stack = [];\n    var re = bracketRegex(config);\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1,\n          end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if (match && match.charAt(1) == \">\" == dir > 0) stack.push(ch);else if (!stack.length) return {\n            pos: Pos(lineNo, pos),\n            ch: ch\n          };else stack.pop();\n        }\n      }\n    }\n\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [],\n        ranges = cm.listSelections();\n\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {\n          className: style\n        }));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen) marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {\n          className: style\n        }));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function clear() {\n        cm.operation(function () {\n          for (var i = 0; i < marks.length; i++) {\n            marks[i].clear();\n          }\n        });\n      };\n\n      if (autoclear) setTimeout(clear, 800);else return clear;\n    }\n  }\n\n  function doMatchBrackets(cm) {\n    cm.operation(function () {\n      if (cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n\n      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function (cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n\n      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n    }\n\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n  CodeMirror.defineExtension(\"matchBrackets\", function () {\n    matchBrackets(this, true);\n  });\n  CodeMirror.defineExtension(\"findMatchingBracket\", function (pos, config, oldConfig) {\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {\n          strict: true\n        } : null;\n      } else {\n        oldConfig.strict = config;\n        config = oldConfig;\n      }\n    }\n\n    return findMatchingBracket(this, pos, config);\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function (pos, dir, style, config) {\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});"],"sourceRoot":""}