{"version":3,"sources":["../node_modules/codemirror/addon/mode/overlay.js","../node_modules/codemirror/mode/python/python.js","../node_modules/codemirror/mode/stex/stex.js","../node_modules/codemirror/mode/rst/rst.js"],"names":["CodeMirror","overlayMode","base","overlay","combine","startState","basePos","baseCur","overlayPos","overlayCur","streamSeen","copyState","state","token","stream","Math","min","start","pos","combineTokens","indent","textAfter","line","electricChars","innerMode","mode","blankLine","baseToken","overlayToken","mod","__webpack_require__","wordRegexp","words","RegExp","join","str","wordOperators","commonKeywords","commonBuiltins","top","scopes","length","registerHelper","concat","defineMode","conf","parserConf","ERRORCLASS","delimiters","singleDelimiters","operators","singleOperators","doubleOperators","doubleDelimiters","tripleDelimiters","i","splice","hangingIndent","indentUnit","myKeywords","myBuiltins","undefined","extra_keywords","extra_builtins","py3","version","Number","identifiers","stringPrefixes","keywords","builtins","tokenBase","sol","lastToken","indentation","type","scopeOffset","offset","eatSpace","lineOffset","pushPyScope","dedent","peek","errorToken","style","tokenBaseInner","match","floatLiteral","eat","intLiteral","isFmtString","current","toLowerCase","indexOf","tokenize","delimiter","tokenOuter","charAt","substr","singleline","OUTCLASS","tokenNestedExpr","depth","inner","tokenString","eol","eatWhile","next","singleLineStringErrors","isString","formatStringFactory","tokenStringFactory","pop","push","align","indented","tokenLexer","beginningOfLine","test","lambda","delimiter_index","column","pushBracketScope","slice","external","basecolumn","addErr","Pass","scope","closing","electricInput","closeBrackets","triples","lineComment","fold","defineMIME","name","split","_config","parserConfig","pushCommand","command","cmdState","peekCommand","addPluginPattern","pluginName","cmdStyle","styles","this","bracketNo","argument","styleIdentifier","openBracket","closeBracket","plugins","setState","f","normal","source","plug","cmdName","beginParams","inMathMode","ch","skipToEnd","context","getMostPowerful","endModeSeq","popCommand","s","config","options","rx_strong","rx_emphasis","rx_literal","rx_number","rx_positive","rx_negative","rx_uri","getMode","backdrop","format","string","args","Array","prototype","call","arguments","replace","n","mode_python","mode_stex","TAIL","rx_TAIL","NAME","rx_NAME","REF_NAME","TEXT1","TEXT2","rx_TEXT2","rx_section","rx_explicit","rx_link","rx_directive","rx_substitution","rx_footnote","rx_citation","rx_substitution_ref","rx_footnote_ref","rx_citation_ref","rx_link_ref1","rx_link_ref2","rx_role_pre","rx_role_suf","rx_role","rx_directive_name","rx_directive_tail","rx_substitution_text","rx_substitution_sepa","rx_substitution_name","rx_substitution_tail","rx_link_head","rx_link_name","rx_link_tail","rx_verbatim","rx_examples","to_normal","change","to_mode","local","to_explicit","phase","stage","tmp_stex","tmp","to_verbatim","tmp_py","to_comment","as_block","ctx","tok"],"mappings":"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","file":"static/js/17.542cd5e3.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// Utility function that allows modes to be combined. The mode given\n// as the base argument takes care of most of the normal mode\n// functionality, but a second (typically simple) mode is used, which\n// can override the style of text. Both modes get to parse all of the\n// text, but when both assign a non-null style to a piece of code, the\n// overlay wins, unless the combine argument was true and not overridden,\n// or state.overlay.combineTokens was true, in which case the styles are\n// combined.\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.overlayMode = function (base, overlay, combine) {\n    return {\n      startState: function startState() {\n        return {\n          base: CodeMirror.startState(base),\n          overlay: CodeMirror.startState(overlay),\n          basePos: 0,\n          baseCur: null,\n          overlayPos: 0,\n          overlayCur: null,\n          streamSeen: null\n        };\n      },\n      copyState: function copyState(state) {\n        return {\n          base: CodeMirror.copyState(base, state.base),\n          overlay: CodeMirror.copyState(overlay, state.overlay),\n          basePos: state.basePos,\n          baseCur: null,\n          overlayPos: state.overlayPos,\n          overlayCur: null\n        };\n      },\n      token: function token(stream, state) {\n        if (stream != state.streamSeen || Math.min(state.basePos, state.overlayPos) < stream.start) {\n          state.streamSeen = stream;\n          state.basePos = state.overlayPos = stream.start;\n        }\n\n        if (stream.start == state.basePos) {\n          state.baseCur = base.token(stream, state.base);\n          state.basePos = stream.pos;\n        }\n\n        if (stream.start == state.overlayPos) {\n          stream.pos = stream.start;\n          state.overlayCur = overlay.token(stream, state.overlay);\n          state.overlayPos = stream.pos;\n        }\n\n        stream.pos = Math.min(state.basePos, state.overlayPos); // state.overlay.combineTokens always takes precedence over combine,\n        // unless set to null\n\n        if (state.overlayCur == null) return state.baseCur;else if (state.baseCur != null && state.overlay.combineTokens || combine && state.overlay.combineTokens == null) return state.baseCur + \" \" + state.overlayCur;else return state.overlayCur;\n      },\n      indent: base.indent && function (state, textAfter, line) {\n        return base.indent(state.base, textAfter, line);\n      },\n      electricChars: base.electricChars,\n      innerMode: function innerMode(state) {\n        return {\n          state: state.base,\n          mode: base\n        };\n      },\n      blankLine: function blankLine(state) {\n        var baseToken, overlayToken;\n        if (base.blankLine) baseToken = base.blankLine(state.base);\n        if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);\n        return overlayToken == null ? baseToken : combine && baseToken != null ? baseToken + \" \" + overlayToken : overlayToken;\n      }\n    };\n  };\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\", \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\", \"for\", \"from\", \"global\", \"if\", \"import\", \"lambda\", \"pass\", \"raise\", \"return\", \"try\", \"while\", \"with\", \"yield\", \"in\"];\n  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\", \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\", \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\", \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\", \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\", \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\", \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\", \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\", \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\", \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\", \"Ellipsis\", \"__debug__\"];\n  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n\n  function top(state) {\n    return state.scopes[state.scopes.length - 1];\n  }\n\n  CodeMirror.defineMode(\"python\", function (conf, parserConf) {\n    var ERRORCLASS = \"error\";\n    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/; //               (Backwards-compatiblity with old, cumbersome config system)\n\n    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters, parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/];\n\n    for (var i = 0; i < operators.length; i++) {\n      if (!operators[i]) operators.splice(i--, 1);\n    }\n\n    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n    var myKeywords = commonKeywords,\n        myBuiltins = commonBuiltins;\n    if (parserConf.extra_keywords != undefined) myKeywords = myKeywords.concat(parserConf.extra_keywords);\n    if (parserConf.extra_builtins != undefined) myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n    var py3 = !(parserConf.version && Number(parserConf.version) < 3);\n\n    if (py3) {\n      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n      var identifiers = parserConf.identifiers || /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n      myKeywords = myKeywords.concat([\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]);\n      myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n      var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(fr))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n      var identifiers = parserConf.identifiers || /^[_A-Za-z][_A-Za-z0-9]*/;\n      myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n      myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\", \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\", \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"]);\n      var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n\n    var keywords = wordRegexp(myKeywords);\n    var builtins = wordRegexp(myBuiltins); // tokenizers\n\n    function tokenBase(stream, state) {\n      var sol = stream.sol() && state.lastToken != \"\\\\\";\n      if (sol) state.indent = stream.indentation(); // Handle scope changes\n\n      if (sol && top(state).type == \"py\") {\n        var scopeOffset = top(state).offset;\n\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset) pushPyScope(state);else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\") state.errorToken = true;\n          return null;\n        } else {\n          var style = tokenBaseInner(stream, state);\n          if (scopeOffset > 0 && dedent(stream, state)) style += \" \" + ERRORCLASS;\n          return style;\n        }\n      }\n\n      return tokenBaseInner(stream, state);\n    }\n\n    function tokenBaseInner(stream, state) {\n      if (stream.eatSpace()) return null; // Handle Comments\n\n      if (stream.match(/^#.*/)) return \"comment\"; // Handle Number Literals\n\n      if (stream.match(/^[0-9\\.]/, false)) {\n        var floatLiteral = false; // Floats\n\n        if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n          floatLiteral = true;\n        }\n\n        if (stream.match(/^[\\d_]+\\.\\d*/)) {\n          floatLiteral = true;\n        }\n\n        if (stream.match(/^\\.\\d+/)) {\n          floatLiteral = true;\n        }\n\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return \"number\";\n        } // Integers\n\n\n        var intLiteral = false; // Hex\n\n        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true; // Binary\n\n        if (stream.match(/^0b[01_]+/i)) intLiteral = true; // Octal\n\n        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true; // Decimal\n\n        if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n          // Decimal literals may be \"imaginary\"\n          stream.eat(/J/i); // TODO - Can you have imaginary longs?\n\n          intLiteral = true;\n        } // Zero by itself with no other piece of number.\n\n\n        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return \"number\";\n        }\n      } // Handle Strings\n\n\n      if (stream.match(stringPrefixes)) {\n        var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n\n        if (!isFmtString) {\n          state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        } else {\n          state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        }\n      }\n\n      for (var i = 0; i < operators.length; i++) {\n        if (stream.match(operators[i])) return \"operator\";\n      }\n\n      if (stream.match(delimiters)) return \"punctuation\";\n      if (state.lastToken == \".\" && stream.match(identifiers)) return \"property\";\n      if (stream.match(keywords) || stream.match(wordOperators)) return \"keyword\";\n      if (stream.match(builtins)) return \"builtin\";\n      if (stream.match(/^(self|cls)\\b/)) return \"variable-2\";\n\n      if (stream.match(identifiers)) {\n        if (state.lastToken == \"def\" || state.lastToken == \"class\") return \"def\";\n        return \"variable\";\n      } // Handle non-detected items\n\n\n      stream.next();\n      return ERRORCLASS;\n    }\n\n    function formatStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0) {\n        delimiter = delimiter.substr(1);\n      }\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenNestedExpr(depth) {\n        return function (stream, state) {\n          var inner = tokenBaseInner(stream, state);\n\n          if (inner == \"punctuation\") {\n            if (stream.current() == \"{\") {\n              state.tokenize = tokenNestedExpr(depth + 1);\n            } else if (stream.current() == \"}\") {\n              if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1);else state.tokenize = tokenString;\n            }\n          }\n\n          return inner;\n        };\n      }\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol()) return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else if (stream.match('{{')) {\n            // ignore {{ in f-str\n            return OUTCLASS;\n          } else if (stream.match('{', false)) {\n            // switch to nested mode\n            state.tokenize = tokenNestedExpr(0);\n            if (stream.current()) return OUTCLASS;else return state.tokenize(stream, state);\n          } else if (stream.match('}}')) {\n            return OUTCLASS;\n          } else if (stream.match('}')) {\n            // single } in f-string is an error\n            return ERRORCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) return ERRORCLASS;else state.tokenize = tokenOuter;\n        }\n\n        return OUTCLASS;\n      }\n\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function tokenStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0) {\n        delimiter = delimiter.substr(1);\n      }\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\\\]/);\n\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol()) return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) return ERRORCLASS;else state.tokenize = tokenOuter;\n        }\n\n        return OUTCLASS;\n      }\n\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function pushPyScope(state) {\n      while (top(state).type != \"py\") {\n        state.scopes.pop();\n      }\n\n      state.scopes.push({\n        offset: top(state).offset + conf.indentUnit,\n        type: \"py\",\n        align: null\n      });\n    }\n\n    function pushBracketScope(stream, state, type) {\n      var align = stream.match(/^([\\s\\[\\{\\(]|#.*)*$/, false) ? null : stream.column() + 1;\n      state.scopes.push({\n        offset: state.indent + hangingIndent,\n        type: type,\n        align: align\n      });\n    }\n\n    function dedent(stream, state) {\n      var indented = stream.indentation();\n\n      while (state.scopes.length > 1 && top(state).offset > indented) {\n        if (top(state).type != \"py\") return true;\n        state.scopes.pop();\n      }\n\n      return top(state).offset != indented;\n    }\n\n    function tokenLexer(stream, state) {\n      if (stream.sol()) state.beginningOfLine = true;\n      var style = state.tokenize(stream, state);\n      var current = stream.current(); // Handle decorators\n\n      if (state.beginningOfLine && current == \"@\") return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n      if (/\\S/.test(current)) state.beginningOfLine = false;\n      if ((style == \"variable\" || style == \"builtin\") && state.lastToken == \"meta\") style = \"meta\"; // Handle scope changes.\n\n      if (current == \"pass\" || current == \"return\") state.dedent += 1;\n      if (current == \"lambda\") state.lambda = true;\n      if (current == \":\" && !state.lambda && top(state).type == \"py\") pushPyScope(state);\n\n      if (current.length == 1 && !/string|comment/.test(style)) {\n        var delimiter_index = \"[({\".indexOf(current);\n        if (delimiter_index != -1) pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index + 1));\n        delimiter_index = \"])}\".indexOf(current);\n\n        if (delimiter_index != -1) {\n          if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent;else return ERRORCLASS;\n        }\n      }\n\n      if (state.dedent > 0 && stream.eol() && top(state).type == \"py\") {\n        if (state.scopes.length > 1) state.scopes.pop();\n        state.dedent -= 1;\n      }\n\n      return style;\n    }\n\n    var external = {\n      startState: function startState(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scopes: [{\n            offset: basecolumn || 0,\n            type: \"py\",\n            align: null\n          }],\n          indent: basecolumn || 0,\n          lastToken: null,\n          lambda: false,\n          dedent: 0\n        };\n      },\n      token: function token(stream, state) {\n        var addErr = state.errorToken;\n        if (addErr) state.errorToken = false;\n        var style = tokenLexer(stream, state);\n        if (style && style != \"comment\") state.lastToken = style == \"keyword\" || style == \"punctuation\" ? stream.current() : style;\n        if (style == \"punctuation\") style = null;\n        if (stream.eol() && state.lambda) state.lambda = false;\n        return addErr ? style + \" \" + ERRORCLASS : style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase) return state.tokenize.isString ? CodeMirror.Pass : 0;\n        var scope = top(state),\n            closing = scope.type == textAfter.charAt(0);\n        if (scope.align != null) return scope.align - (closing ? 1 : 0);else return scope.offset - (closing ? hangingIndent : 0);\n      },\n      electricInput: /^\\s*[\\}\\]\\)]$/,\n      closeBrackets: {\n        triples: \"'\\\"\"\n      },\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n\n  var words = function words(str) {\n    return str.split(\" \");\n  };\n\n  CodeMirror.defineMIME(\"text/x-cython\", {\n    name: \"python\",\n    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \" + \"extern gil include nogil property public \" + \"readonly struct union DEF IF ELIF ELSE\")\n  });\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/*\n * Author: Constantin Jucovschi (c.jucovschi@jacobs-university.de)\n * Licence: MIT\n */\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"stex\", function (_config, parserConfig) {\n    \"use strict\";\n\n    function pushCommand(state, command) {\n      state.cmdState.push(command);\n    }\n\n    function peekCommand(state) {\n      if (state.cmdState.length > 0) {\n        return state.cmdState[state.cmdState.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    function popCommand(state) {\n      var plug = state.cmdState.pop();\n\n      if (plug) {\n        plug.closeBracket();\n      }\n    } // returns the non-default plugin closest to the end of the list\n\n\n    function getMostPowerful(state) {\n      var context = state.cmdState;\n\n      for (var i = context.length - 1; i >= 0; i--) {\n        var plug = context[i];\n\n        if (plug.name == \"DEFAULT\") {\n          continue;\n        }\n\n        return plug;\n      }\n\n      return {\n        styleIdentifier: function styleIdentifier() {\n          return null;\n        }\n      };\n    }\n\n    function addPluginPattern(pluginName, cmdStyle, styles) {\n      return function () {\n        this.name = pluginName;\n        this.bracketNo = 0;\n        this.style = cmdStyle;\n        this.styles = styles;\n        this.argument = null; // \\begin and \\end have arguments that follow. These are stored in the plugin\n\n        this.styleIdentifier = function () {\n          return this.styles[this.bracketNo - 1] || null;\n        };\n\n        this.openBracket = function () {\n          this.bracketNo++;\n          return \"bracket\";\n        };\n\n        this.closeBracket = function () {};\n      };\n    }\n\n    var plugins = {};\n    plugins[\"importmodule\"] = addPluginPattern(\"importmodule\", \"tag\", [\"string\", \"builtin\"]);\n    plugins[\"documentclass\"] = addPluginPattern(\"documentclass\", \"tag\", [\"\", \"atom\"]);\n    plugins[\"usepackage\"] = addPluginPattern(\"usepackage\", \"tag\", [\"atom\"]);\n    plugins[\"begin\"] = addPluginPattern(\"begin\", \"tag\", [\"atom\"]);\n    plugins[\"end\"] = addPluginPattern(\"end\", \"tag\", [\"atom\"]);\n    plugins[\"label\"] = addPluginPattern(\"label\", \"tag\", [\"atom\"]);\n    plugins[\"ref\"] = addPluginPattern(\"ref\", \"tag\", [\"atom\"]);\n    plugins[\"eqref\"] = addPluginPattern(\"eqref\", \"tag\", [\"atom\"]);\n    plugins[\"cite\"] = addPluginPattern(\"cite\", \"tag\", [\"atom\"]);\n    plugins[\"bibitem\"] = addPluginPattern(\"bibitem\", \"tag\", [\"atom\"]);\n    plugins[\"Bibitem\"] = addPluginPattern(\"Bibitem\", \"tag\", [\"atom\"]);\n    plugins[\"RBibitem\"] = addPluginPattern(\"RBibitem\", \"tag\", [\"atom\"]);\n\n    plugins[\"DEFAULT\"] = function () {\n      this.name = \"DEFAULT\";\n      this.style = \"tag\";\n\n      this.styleIdentifier = this.openBracket = this.closeBracket = function () {};\n    };\n\n    function setState(state, f) {\n      state.f = f;\n    } // called when in a normal (no environment) context\n\n\n    function normal(source, state) {\n      var plug; // Do we look like '\\command' ?  If so, attempt to apply the plugin 'command'\n\n      if (source.match(/^\\\\[a-zA-Z@]+/)) {\n        var cmdName = source.current().slice(1);\n        plug = plugins[cmdName] || plugins[\"DEFAULT\"];\n        plug = new plug();\n        pushCommand(state, plug);\n        setState(state, beginParams);\n        return plug.style;\n      } // escape characters\n\n\n      if (source.match(/^\\\\[$&%#{}_]/)) {\n        return \"tag\";\n      } // white space control characters\n\n\n      if (source.match(/^\\\\[,;!\\/\\\\]/)) {\n        return \"tag\";\n      } // find if we're starting various math modes\n\n\n      if (source.match(\"\\\\[\")) {\n        setState(state, function (source, state) {\n          return inMathMode(source, state, \"\\\\]\");\n        });\n        return \"keyword\";\n      }\n\n      if (source.match(\"\\\\(\")) {\n        setState(state, function (source, state) {\n          return inMathMode(source, state, \"\\\\)\");\n        });\n        return \"keyword\";\n      }\n\n      if (source.match(\"$$\")) {\n        setState(state, function (source, state) {\n          return inMathMode(source, state, \"$$\");\n        });\n        return \"keyword\";\n      }\n\n      if (source.match(\"$\")) {\n        setState(state, function (source, state) {\n          return inMathMode(source, state, \"$\");\n        });\n        return \"keyword\";\n      }\n\n      var ch = source.next();\n\n      if (ch == \"%\") {\n        source.skipToEnd();\n        return \"comment\";\n      } else if (ch == '}' || ch == ']') {\n        plug = peekCommand(state);\n\n        if (plug) {\n          plug.closeBracket(ch);\n          setState(state, beginParams);\n        } else {\n          return \"error\";\n        }\n\n        return \"bracket\";\n      } else if (ch == '{' || ch == '[') {\n        plug = plugins[\"DEFAULT\"];\n        plug = new plug();\n        pushCommand(state, plug);\n        return \"bracket\";\n      } else if (/\\d/.test(ch)) {\n        source.eatWhile(/[\\w.%]/);\n        return \"atom\";\n      } else {\n        source.eatWhile(/[\\w\\-_]/);\n        plug = getMostPowerful(state);\n\n        if (plug.name == 'begin') {\n          plug.argument = source.current();\n        }\n\n        return plug.styleIdentifier();\n      }\n    }\n\n    function inMathMode(source, state, endModeSeq) {\n      if (source.eatSpace()) {\n        return null;\n      }\n\n      if (endModeSeq && source.match(endModeSeq)) {\n        setState(state, normal);\n        return \"keyword\";\n      }\n\n      if (source.match(/^\\\\[a-zA-Z@]+/)) {\n        return \"tag\";\n      }\n\n      if (source.match(/^[a-zA-Z]+/)) {\n        return \"variable-2\";\n      } // escape characters\n\n\n      if (source.match(/^\\\\[$&%#{}_]/)) {\n        return \"tag\";\n      } // white space control characters\n\n\n      if (source.match(/^\\\\[,;!\\/]/)) {\n        return \"tag\";\n      } // special math-mode characters\n\n\n      if (source.match(/^[\\^_&]/)) {\n        return \"tag\";\n      } // non-special characters\n\n\n      if (source.match(/^[+\\-<>|=,\\/@!*:;'\"`~#?]/)) {\n        return null;\n      }\n\n      if (source.match(/^(\\d+\\.\\d*|\\d*\\.\\d+|\\d+)/)) {\n        return \"number\";\n      }\n\n      var ch = source.next();\n\n      if (ch == \"{\" || ch == \"}\" || ch == \"[\" || ch == \"]\" || ch == \"(\" || ch == \")\") {\n        return \"bracket\";\n      }\n\n      if (ch == \"%\") {\n        source.skipToEnd();\n        return \"comment\";\n      }\n\n      return \"error\";\n    }\n\n    function beginParams(source, state) {\n      var ch = source.peek(),\n          lastPlug;\n\n      if (ch == '{' || ch == '[') {\n        lastPlug = peekCommand(state);\n        lastPlug.openBracket(ch);\n        source.eat(ch);\n        setState(state, normal);\n        return \"bracket\";\n      }\n\n      if (/[ \\t\\r]/.test(ch)) {\n        source.eat(ch);\n        return null;\n      }\n\n      setState(state, normal);\n      popCommand(state);\n      return normal(source, state);\n    }\n\n    return {\n      startState: function startState() {\n        var f = parserConfig.inMathMode ? function (source, state) {\n          return inMathMode(source, state);\n        } : normal;\n        return {\n          cmdState: [],\n          f: f\n        };\n      },\n      copyState: function copyState(s) {\n        return {\n          cmdState: s.cmdState.slice(),\n          f: s.f\n        };\n      },\n      token: function token(stream, state) {\n        return state.f(stream, state);\n      },\n      blankLine: function blankLine(state) {\n        state.f = normal;\n        state.cmdState.length = 0;\n      },\n      lineComment: \"%\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-stex\", \"stex\");\n  CodeMirror.defineMIME(\"text/x-latex\", \"stex\");\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../python/python\"), require(\"../stex/stex\"), require(\"../../addon/mode/overlay\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../python/python\", \"../stex/stex\", \"../../addon/mode/overlay\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode('rst', function (config, options) {\n    var rx_strong = /^\\*\\*[^\\*\\s](?:[^\\*]*[^\\*\\s])?\\*\\*/;\n    var rx_emphasis = /^\\*[^\\*\\s](?:[^\\*]*[^\\*\\s])?\\*/;\n    var rx_literal = /^``[^`\\s](?:[^`]*[^`\\s])``/;\n    var rx_number = /^(?:[\\d]+(?:[\\.,]\\d+)*)/;\n    var rx_positive = /^(?:\\s\\+[\\d]+(?:[\\.,]\\d+)*)/;\n    var rx_negative = /^(?:\\s\\-[\\d]+(?:[\\.,]\\d+)*)/;\n    var rx_uri_protocol = \"[Hh][Tt][Tt][Pp][Ss]?://\";\n    var rx_uri_domain = \"(?:[\\\\d\\\\w.-]+)\\\\.(?:\\\\w{2,6})\";\n    var rx_uri_path = \"(?:/[\\\\d\\\\w\\\\#\\\\%\\\\&\\\\-\\\\.\\\\,\\\\/\\\\:\\\\=\\\\?\\\\~]+)*\";\n    var rx_uri = new RegExp(\"^\" + rx_uri_protocol + rx_uri_domain + rx_uri_path);\n    var overlay = {\n      token: function token(stream) {\n        if (stream.match(rx_strong) && stream.match(/\\W+|$/, false)) return 'strong';\n        if (stream.match(rx_emphasis) && stream.match(/\\W+|$/, false)) return 'em';\n        if (stream.match(rx_literal) && stream.match(/\\W+|$/, false)) return 'string-2';\n        if (stream.match(rx_number)) return 'number';\n        if (stream.match(rx_positive)) return 'positive';\n        if (stream.match(rx_negative)) return 'negative';\n        if (stream.match(rx_uri)) return 'link';\n\n        while (stream.next() != null) {\n          if (stream.match(rx_strong, false)) break;\n          if (stream.match(rx_emphasis, false)) break;\n          if (stream.match(rx_literal, false)) break;\n          if (stream.match(rx_number, false)) break;\n          if (stream.match(rx_positive, false)) break;\n          if (stream.match(rx_negative, false)) break;\n          if (stream.match(rx_uri, false)) break;\n        }\n\n        return null;\n      }\n    };\n    var mode = CodeMirror.getMode(config, options.backdrop || 'rst-base');\n    return CodeMirror.overlayMode(mode, overlay, true); // combine\n  }, 'python', 'stex'); ///////////////////////////////////////////////////////////////////////////////\n  ///////////////////////////////////////////////////////////////////////////////\n\n  CodeMirror.defineMode('rst-base', function (config) {\n    ///////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////\n    function format(string) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      return string.replace(/{(\\d+)}/g, function (match, n) {\n        return typeof args[n] != 'undefined' ? args[n] : match;\n      });\n    } ///////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////\n\n\n    var mode_python = CodeMirror.getMode(config, 'python');\n    var mode_stex = CodeMirror.getMode(config, 'stex'); ///////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    var SEPA = \"\\\\s+\";\n    var TAIL = \"(?:\\\\s*|\\\\W|$)\",\n        rx_TAIL = new RegExp(format('^{0}', TAIL));\n    var NAME = \"(?:[^\\\\W\\\\d_](?:[\\\\w!\\\"#$%&'()\\\\*\\\\+,\\\\-\\\\.\\/:;<=>\\\\?]*[^\\\\W_])?)\",\n        rx_NAME = new RegExp(format('^{0}', NAME));\n    var NAME_WWS = \"(?:[^\\\\W\\\\d_](?:[\\\\w\\\\s!\\\"#$%&'()\\\\*\\\\+,\\\\-\\\\.\\/:;<=>\\\\?]*[^\\\\W_])?)\";\n    var REF_NAME = format('(?:{0}|`{1}`)', NAME, NAME_WWS);\n    var TEXT1 = \"(?:[^\\\\s\\\\|](?:[^\\\\|]*[^\\\\s\\\\|])?)\";\n    var TEXT2 = \"(?:[^\\\\`]+)\",\n        rx_TEXT2 = new RegExp(format('^{0}', TEXT2));\n    var rx_section = new RegExp(\"^([!'#$%&\\\"()*+,-./:;<=>?@\\\\[\\\\\\\\\\\\]^_`{|}~])\\\\1{3,}\\\\s*$\");\n    var rx_explicit = new RegExp(format('^\\\\.\\\\.{0}', SEPA));\n    var rx_link = new RegExp(format('^_{0}:{1}|^__:{1}', REF_NAME, TAIL));\n    var rx_directive = new RegExp(format('^{0}::{1}', REF_NAME, TAIL));\n    var rx_substitution = new RegExp(format('^\\\\|{0}\\\\|{1}{2}::{3}', TEXT1, SEPA, REF_NAME, TAIL));\n    var rx_footnote = new RegExp(format('^\\\\[(?:\\\\d+|#{0}?|\\\\*)]{1}', REF_NAME, TAIL));\n    var rx_citation = new RegExp(format('^\\\\[{0}\\\\]{1}', REF_NAME, TAIL));\n    var rx_substitution_ref = new RegExp(format('^\\\\|{0}\\\\|', TEXT1));\n    var rx_footnote_ref = new RegExp(format('^\\\\[(?:\\\\d+|#{0}?|\\\\*)]_', REF_NAME));\n    var rx_citation_ref = new RegExp(format('^\\\\[{0}\\\\]_', REF_NAME));\n    var rx_link_ref1 = new RegExp(format('^{0}__?', REF_NAME));\n    var rx_link_ref2 = new RegExp(format('^`{0}`_', TEXT2));\n    var rx_role_pre = new RegExp(format('^:{0}:`{1}`{2}', NAME, TEXT2, TAIL));\n    var rx_role_suf = new RegExp(format('^`{1}`:{0}:{2}', NAME, TEXT2, TAIL));\n    var rx_role = new RegExp(format('^:{0}:{1}', NAME, TAIL));\n    var rx_directive_name = new RegExp(format('^{0}', REF_NAME));\n    var rx_directive_tail = new RegExp(format('^::{0}', TAIL));\n    var rx_substitution_text = new RegExp(format('^\\\\|{0}\\\\|', TEXT1));\n    var rx_substitution_sepa = new RegExp(format('^{0}', SEPA));\n    var rx_substitution_name = new RegExp(format('^{0}', REF_NAME));\n    var rx_substitution_tail = new RegExp(format('^::{0}', TAIL));\n    var rx_link_head = new RegExp(\"^_\");\n    var rx_link_name = new RegExp(format('^{0}|_', REF_NAME));\n    var rx_link_tail = new RegExp(format('^:{0}', TAIL));\n    var rx_verbatim = new RegExp('^::\\\\s*$');\n    var rx_examples = new RegExp('^\\\\s+(?:>>>|In \\\\[\\\\d+\\\\]:)\\\\s'); ///////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    function to_normal(stream, state) {\n      var token = null;\n\n      if (stream.sol() && stream.match(rx_examples, false)) {\n        change(state, to_mode, {\n          mode: mode_python,\n          local: CodeMirror.startState(mode_python)\n        });\n      } else if (stream.sol() && stream.match(rx_explicit)) {\n        change(state, to_explicit);\n        token = 'meta';\n      } else if (stream.sol() && stream.match(rx_section)) {\n        change(state, to_normal);\n        token = 'header';\n      } else if (phase(state) == rx_role_pre || stream.match(rx_role_pre, false)) {\n        switch (stage(state)) {\n          case 0:\n            change(state, to_normal, context(rx_role_pre, 1));\n            stream.match(/^:/);\n            token = 'meta';\n            break;\n\n          case 1:\n            change(state, to_normal, context(rx_role_pre, 2));\n            stream.match(rx_NAME);\n            token = 'keyword';\n\n            if (stream.current().match(/^(?:math|latex)/)) {\n              state.tmp_stex = true;\n            }\n\n            break;\n\n          case 2:\n            change(state, to_normal, context(rx_role_pre, 3));\n            stream.match(/^:`/);\n            token = 'meta';\n            break;\n\n          case 3:\n            if (state.tmp_stex) {\n              state.tmp_stex = undefined;\n              state.tmp = {\n                mode: mode_stex,\n                local: CodeMirror.startState(mode_stex)\n              };\n            }\n\n            if (state.tmp) {\n              if (stream.peek() == '`') {\n                change(state, to_normal, context(rx_role_pre, 4));\n                state.tmp = undefined;\n                break;\n              }\n\n              token = state.tmp.mode.token(stream, state.tmp.local);\n              break;\n            }\n\n            change(state, to_normal, context(rx_role_pre, 4));\n            stream.match(rx_TEXT2);\n            token = 'string';\n            break;\n\n          case 4:\n            change(state, to_normal, context(rx_role_pre, 5));\n            stream.match(/^`/);\n            token = 'meta';\n            break;\n\n          case 5:\n            change(state, to_normal, context(rx_role_pre, 6));\n            stream.match(rx_TAIL);\n            break;\n\n          default:\n            change(state, to_normal);\n        }\n      } else if (phase(state) == rx_role_suf || stream.match(rx_role_suf, false)) {\n        switch (stage(state)) {\n          case 0:\n            change(state, to_normal, context(rx_role_suf, 1));\n            stream.match(/^`/);\n            token = 'meta';\n            break;\n\n          case 1:\n            change(state, to_normal, context(rx_role_suf, 2));\n            stream.match(rx_TEXT2);\n            token = 'string';\n            break;\n\n          case 2:\n            change(state, to_normal, context(rx_role_suf, 3));\n            stream.match(/^`:/);\n            token = 'meta';\n            break;\n\n          case 3:\n            change(state, to_normal, context(rx_role_suf, 4));\n            stream.match(rx_NAME);\n            token = 'keyword';\n            break;\n\n          case 4:\n            change(state, to_normal, context(rx_role_suf, 5));\n            stream.match(/^:/);\n            token = 'meta';\n            break;\n\n          case 5:\n            change(state, to_normal, context(rx_role_suf, 6));\n            stream.match(rx_TAIL);\n            break;\n\n          default:\n            change(state, to_normal);\n        }\n      } else if (phase(state) == rx_role || stream.match(rx_role, false)) {\n        switch (stage(state)) {\n          case 0:\n            change(state, to_normal, context(rx_role, 1));\n            stream.match(/^:/);\n            token = 'meta';\n            break;\n\n          case 1:\n            change(state, to_normal, context(rx_role, 2));\n            stream.match(rx_NAME);\n            token = 'keyword';\n            break;\n\n          case 2:\n            change(state, to_normal, context(rx_role, 3));\n            stream.match(/^:/);\n            token = 'meta';\n            break;\n\n          case 3:\n            change(state, to_normal, context(rx_role, 4));\n            stream.match(rx_TAIL);\n            break;\n\n          default:\n            change(state, to_normal);\n        }\n      } else if (phase(state) == rx_substitution_ref || stream.match(rx_substitution_ref, false)) {\n        switch (stage(state)) {\n          case 0:\n            change(state, to_normal, context(rx_substitution_ref, 1));\n            stream.match(rx_substitution_text);\n            token = 'variable-2';\n            break;\n\n          case 1:\n            change(state, to_normal, context(rx_substitution_ref, 2));\n            if (stream.match(/^_?_?/)) token = 'link';\n            break;\n\n          default:\n            change(state, to_normal);\n        }\n      } else if (stream.match(rx_footnote_ref)) {\n        change(state, to_normal);\n        token = 'quote';\n      } else if (stream.match(rx_citation_ref)) {\n        change(state, to_normal);\n        token = 'quote';\n      } else if (stream.match(rx_link_ref1)) {\n        change(state, to_normal);\n\n        if (!stream.peek() || stream.peek().match(/^\\W$/)) {\n          token = 'link';\n        }\n      } else if (phase(state) == rx_link_ref2 || stream.match(rx_link_ref2, false)) {\n        switch (stage(state)) {\n          case 0:\n            if (!stream.peek() || stream.peek().match(/^\\W$/)) {\n              change(state, to_normal, context(rx_link_ref2, 1));\n            } else {\n              stream.match(rx_link_ref2);\n            }\n\n            break;\n\n          case 1:\n            change(state, to_normal, context(rx_link_ref2, 2));\n            stream.match(/^`/);\n            token = 'link';\n            break;\n\n          case 2:\n            change(state, to_normal, context(rx_link_ref2, 3));\n            stream.match(rx_TEXT2);\n            break;\n\n          case 3:\n            change(state, to_normal, context(rx_link_ref2, 4));\n            stream.match(/^`_/);\n            token = 'link';\n            break;\n\n          default:\n            change(state, to_normal);\n        }\n      } else if (stream.match(rx_verbatim)) {\n        change(state, to_verbatim);\n      } else {\n        if (stream.next()) change(state, to_normal);\n      }\n\n      return token;\n    } ///////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////\n\n\n    function to_explicit(stream, state) {\n      var token = null;\n\n      if (phase(state) == rx_substitution || stream.match(rx_substitution, false)) {\n        switch (stage(state)) {\n          case 0:\n            change(state, to_explicit, context(rx_substitution, 1));\n            stream.match(rx_substitution_text);\n            token = 'variable-2';\n            break;\n\n          case 1:\n            change(state, to_explicit, context(rx_substitution, 2));\n            stream.match(rx_substitution_sepa);\n            break;\n\n          case 2:\n            change(state, to_explicit, context(rx_substitution, 3));\n            stream.match(rx_substitution_name);\n            token = 'keyword';\n            break;\n\n          case 3:\n            change(state, to_explicit, context(rx_substitution, 4));\n            stream.match(rx_substitution_tail);\n            token = 'meta';\n            break;\n\n          default:\n            change(state, to_normal);\n        }\n      } else if (phase(state) == rx_directive || stream.match(rx_directive, false)) {\n        switch (stage(state)) {\n          case 0:\n            change(state, to_explicit, context(rx_directive, 1));\n            stream.match(rx_directive_name);\n            token = 'keyword';\n            if (stream.current().match(/^(?:math|latex)/)) state.tmp_stex = true;else if (stream.current().match(/^python/)) state.tmp_py = true;\n            break;\n\n          case 1:\n            change(state, to_explicit, context(rx_directive, 2));\n            stream.match(rx_directive_tail);\n            token = 'meta';\n\n            if (stream.match(/^latex\\s*$/) || state.tmp_stex) {\n              state.tmp_stex = undefined;\n              change(state, to_mode, {\n                mode: mode_stex,\n                local: CodeMirror.startState(mode_stex)\n              });\n            }\n\n            break;\n\n          case 2:\n            change(state, to_explicit, context(rx_directive, 3));\n\n            if (stream.match(/^python\\s*$/) || state.tmp_py) {\n              state.tmp_py = undefined;\n              change(state, to_mode, {\n                mode: mode_python,\n                local: CodeMirror.startState(mode_python)\n              });\n            }\n\n            break;\n\n          default:\n            change(state, to_normal);\n        }\n      } else if (phase(state) == rx_link || stream.match(rx_link, false)) {\n        switch (stage(state)) {\n          case 0:\n            change(state, to_explicit, context(rx_link, 1));\n            stream.match(rx_link_head);\n            stream.match(rx_link_name);\n            token = 'link';\n            break;\n\n          case 1:\n            change(state, to_explicit, context(rx_link, 2));\n            stream.match(rx_link_tail);\n            token = 'meta';\n            break;\n\n          default:\n            change(state, to_normal);\n        }\n      } else if (stream.match(rx_footnote)) {\n        change(state, to_normal);\n        token = 'quote';\n      } else if (stream.match(rx_citation)) {\n        change(state, to_normal);\n        token = 'quote';\n      } else {\n        stream.eatSpace();\n\n        if (stream.eol()) {\n          change(state, to_normal);\n        } else {\n          stream.skipToEnd();\n          change(state, to_comment);\n          token = 'comment';\n        }\n      }\n\n      return token;\n    } ///////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////\n\n\n    function to_comment(stream, state) {\n      return as_block(stream, state, 'comment');\n    }\n\n    function to_verbatim(stream, state) {\n      return as_block(stream, state, 'meta');\n    }\n\n    function as_block(stream, state, token) {\n      if (stream.eol() || stream.eatSpace()) {\n        stream.skipToEnd();\n        return token;\n      } else {\n        change(state, to_normal);\n        return null;\n      }\n    } ///////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////\n\n\n    function to_mode(stream, state) {\n      if (state.ctx.mode && state.ctx.local) {\n        if (stream.sol()) {\n          if (!stream.eatSpace()) change(state, to_normal);\n          return null;\n        }\n\n        return state.ctx.mode.token(stream, state.ctx.local);\n      }\n\n      change(state, to_normal);\n      return null;\n    } ///////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////\n\n\n    function context(phase, stage, mode, local) {\n      return {\n        phase: phase,\n        stage: stage,\n        mode: mode,\n        local: local\n      };\n    }\n\n    function change(state, tok, ctx) {\n      state.tok = tok;\n      state.ctx = ctx || {};\n    }\n\n    function stage(state) {\n      return state.ctx.stage || 0;\n    }\n\n    function phase(state) {\n      return state.ctx.phase;\n    } ///////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////\n\n\n    return {\n      startState: function startState() {\n        return {\n          tok: to_normal,\n          ctx: context(undefined, 0)\n        };\n      },\n      copyState: function copyState(state) {\n        var ctx = state.ctx,\n            tmp = state.tmp;\n        if (ctx.local) ctx = {\n          mode: ctx.mode,\n          local: CodeMirror.copyState(ctx.mode, ctx.local)\n        };\n        if (tmp) tmp = {\n          mode: tmp.mode,\n          local: CodeMirror.copyState(tmp.mode, tmp.local)\n        };\n        return {\n          tok: state.tok,\n          ctx: ctx,\n          tmp: tmp\n        };\n      },\n      innerMode: function innerMode(state) {\n        return state.tmp ? {\n          state: state.tmp.local,\n          mode: state.tmp.mode\n        } : state.ctx.mode ? {\n          state: state.ctx.local,\n          mode: state.ctx.mode\n        } : null;\n      },\n      token: function token(stream, state) {\n        return state.tok(stream, state);\n      }\n    };\n  }, 'python', 'stex'); ///////////////////////////////////////////////////////////////////////////////\n  ///////////////////////////////////////////////////////////////////////////////\n\n  CodeMirror.defineMIME('text/x-rst', 'rst'); ///////////////////////////////////////////////////////////////////////////////\n  ///////////////////////////////////////////////////////////////////////////////\n});"],"sourceRoot":""}